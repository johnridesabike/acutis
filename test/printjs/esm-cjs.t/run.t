  $ acutis \
  >   --mode js \
  >   template.acutis \
  >   --fun ./jsfile.mjs externalFunction "children = string"
  /* THIS FILE WAS GENERATED BY ACUTIS. */
  let buffer_add_escape$0 =
    (arg$0) => {
      return (
        (arg$1) => {
          for (let item$0 of arg$1[Symbol.iterator]()) {
            switch (item$0) {
              case "&": arg$0.contents += "&amp;"; break;
              case "\"": arg$0.contents += "&quot;"; break;
              case "'": arg$0.contents += "&apos;"; break;
              case ">": arg$0.contents += "&gt;"; break;
              case "<": arg$0.contents += "&lt;"; break;
              case "/": arg$0.contents += "&sol;"; break;
              case "`": arg$0.contents += "&grave;"; break;
              case "=": arg$0.contents += "&equals;"; break;
              default: arg$0.contents += item$0;
            }
          }
        }
      );
    };
  let buffer_add_sep$0 =
    (arg$0) => {
      return (
        (arg$1) => {
          return (
            (arg$2) => {
              if (!(arg$0.contents.length === 0)) { arg$0.contents += arg$1; }
              arg$0.contents += arg$2;
            }
          );
        }
      );
    };
  let stack_empty$0 = (arg$0) => {  };
  let stack_is_empty$0 =
    (arg$0) => {
      let result$0 = true;
      arg$0((arg$1) => { result$0 = false; });
      return (result$0);
    };
  let stack_add$0 =
    (arg$0) => {
      return (
        (arg$1) => {
          return ((arg$2) => { arg$1(arg$2); return (arg$2(arg$0)); });
        }
      );
    };
  function Int$0(arg$0) { this.v = arg$0; }
  function String$0(arg$0) { this.v = arg$0; }
  function Float$0(arg$0) { this.v = arg$0; }
  function Array$0(arg$0) { this.v = arg$0; }
  function Hashtbl$0(arg$0) { this.v = arg$0; }
  function Unknown$0(arg$0) { this.v = arg$0; }
  import {"externalFunction" as import$0} from "./jsfile.mjs";
  let ExternalFunction$0 =
    (arg$0) => {
      let seq$0 =
        (function* () { yield (["children", arg$0.get("children").v]); })();
      return (import$0(Object.fromEntries(seq$0)));
    };
  export default async (arg$0) => {
    let errors$0 = {contents: ""};
    let error_aux$0 =
      (arg$1) => {
        return (
          (arg$2) => {
            return (
              (arg$3) => {
                return (
                  (arg$4) => {
                    if (!(errors$0.contents.length === 0)) {
                      errors$0.contents += "\n\n";
                    }
                    errors$0.contents += "File \"";
                    errors$0.contents += "template.acutis";
                    errors$0.contents +=
                      "\"\n\
  Render error.\n\
  The data supplied does not match this template's interface.\n\
  ";
                    errors$0.contents += "Path:\n<input>";
                    arg$3(buffer_add_sep$0(errors$0)(" -> "));
                    errors$0.contents += "\nExpected type:\n";
                    errors$0.contents += arg$4;
                    errors$0.contents += arg$1;
                    errors$0.contents += arg$2;
                  }
                );
              }
            );
          }
        );
      };
    let decode_error$0 =
      (arg$1) => {
        return (error_aux$0("\nReceived value:\n")(String(arg$1)));
      };
    let key_error$0 =
      (arg$1) => {
        let buf$0 = {contents: ""};
        arg$1(buffer_add_sep$0(buf$0)(", "));
        return (error_aux$0("\nInput is missing keys:\n")(buf$0.contents));
      };
    let props$0 = new Map();
    let type$0 = "{}";
    if (typeof arg$0 === "object" && !(arg$0 === null)) {
      let missing_keys$0 = stack_empty$0;
      if (!(stack_is_empty$0(missing_keys$0))) {
        key_error$0(missing_keys$0)(stack_empty$0)(type$0);
      }
    } else {
      decode_error$0(arg$0)(stack_empty$0)(type$0);
    }
    if (errors$0.contents.length === 0) {
      let buf$0 = {contents: ""};
      let buf$1 = {contents: ""};
      buf$1.contents += " text ";
      buf$0.contents +=
        await
          ExternalFunction$0(
            new Map([["children", new String$0(buf$1.contents)]])
          );
      buf$0.contents += "\n";
      return (Promise.resolve(buf$0.contents));
    } else {
      return (Promise.reject(new Error(errors$0.contents)));
    }
  };

  $ acutis \
  >   --mode cjs \
  >   template.acutis \
  >   --fun ./jsfile.cjs externalFunction "children = string"
  /* THIS FILE WAS GENERATED BY ACUTIS. */
  let buffer_add_escape$0 =
    (arg$0) => {
      return (
        (arg$1) => {
          for (let item$0 of arg$1[Symbol.iterator]()) {
            switch (item$0) {
              case "&": arg$0.contents += "&amp;"; break;
              case "\"": arg$0.contents += "&quot;"; break;
              case "'": arg$0.contents += "&apos;"; break;
              case ">": arg$0.contents += "&gt;"; break;
              case "<": arg$0.contents += "&lt;"; break;
              case "/": arg$0.contents += "&sol;"; break;
              case "`": arg$0.contents += "&grave;"; break;
              case "=": arg$0.contents += "&equals;"; break;
              default: arg$0.contents += item$0;
            }
          }
        }
      );
    };
  let buffer_add_sep$0 =
    (arg$0) => {
      return (
        (arg$1) => {
          return (
            (arg$2) => {
              if (!(arg$0.contents.length === 0)) { arg$0.contents += arg$1; }
              arg$0.contents += arg$2;
            }
          );
        }
      );
    };
  let stack_empty$0 = (arg$0) => {  };
  let stack_is_empty$0 =
    (arg$0) => {
      let result$0 = true;
      arg$0((arg$1) => { result$0 = false; });
      return (result$0);
    };
  let stack_add$0 =
    (arg$0) => {
      return (
        (arg$1) => {
          return ((arg$2) => { arg$1(arg$2); return (arg$2(arg$0)); });
        }
      );
    };
  function Int$0(arg$0) { this.v = arg$0; }
  function String$0(arg$0) { this.v = arg$0; }
  function Float$0(arg$0) { this.v = arg$0; }
  function Array$0(arg$0) { this.v = arg$0; }
  function Hashtbl$0(arg$0) { this.v = arg$0; }
  function Unknown$0(arg$0) { this.v = arg$0; }
  let import$0 = require("./jsfile.cjs");
  let ExternalFunction$0 =
    (arg$0) => {
      let seq$0 =
        (function* () { yield (["children", arg$0.get("children").v]); })();
      return (import$0["externalFunction"](Object.fromEntries(seq$0)));
    };
  module.exports =
    async (arg$0) => {
      let errors$0 = {contents: ""};
      let error_aux$0 =
        (arg$1) => {
          return (
            (arg$2) => {
              return (
                (arg$3) => {
                  return (
                    (arg$4) => {
                      if (!(errors$0.contents.length === 0)) {
                        errors$0.contents += "\n\n";
                      }
                      errors$0.contents += "File \"";
                      errors$0.contents += "template.acutis";
                      errors$0.contents +=
                        "\"\n\
  Render error.\n\
  The data supplied does not match this template's interface.\n\
  ";
                      errors$0.contents += "Path:\n<input>";
                      arg$3(buffer_add_sep$0(errors$0)(" -> "));
                      errors$0.contents += "\nExpected type:\n";
                      errors$0.contents += arg$4;
                      errors$0.contents += arg$1;
                      errors$0.contents += arg$2;
                    }
                  );
                }
              );
            }
          );
        };
      let decode_error$0 =
        (arg$1) => {
          return (error_aux$0("\nReceived value:\n")(String(arg$1)));
        };
      let key_error$0 =
        (arg$1) => {
          let buf$0 = {contents: ""};
          arg$1(buffer_add_sep$0(buf$0)(", "));
          return (error_aux$0("\nInput is missing keys:\n")(buf$0.contents));
        };
      let props$0 = new Map();
      let type$0 = "{}";
      if (typeof arg$0 === "object" && !(arg$0 === null)) {
        let missing_keys$0 = stack_empty$0;
        if (!(stack_is_empty$0(missing_keys$0))) {
          key_error$0(missing_keys$0)(stack_empty$0)(type$0);
        }
      } else {
        decode_error$0(arg$0)(stack_empty$0)(type$0);
      }
      if (errors$0.contents.length === 0) {
        let buf$0 = {contents: ""};
        let buf$1 = {contents: ""};
        buf$1.contents += " text ";
        buf$0.contents +=
          await
            ExternalFunction$0(
              new Map([["children", new String$0(buf$1.contents)]])
            );
        buf$0.contents += "\n";
        return (Promise.resolve(buf$0.contents));
      } else {
        return (Promise.reject(new Error(errors$0.contents)));
      }
    };

  $ acutis \
  >   --mode js \
  >   template.acutis \
  >   --fun ./jsfile.cjs externalFunction "children = string"
  /* THIS FILE WAS GENERATED BY ACUTIS. */
  let buffer_add_string$0 =
    (arg$0) => {
      return ((arg$1) => { arg$0.contents = arg$0.contents + arg$1; });
    };
  let buffer_add_buffer$0 =
    (arg$0) => {
      return (
        (arg$1) => { arg$0.contents = arg$0.contents + arg$1.contents; }
      );
    };
  let buffer_add_escape$0 =
    (arg$0) => {
      return (
        (arg$1) => {
          for (let i$0 = 0; i$0 < arg$1.length; i$0++) {
            let c$0 = arg$1[i$0];
            switch (c$0) {
              case "&": arg$0.contents = arg$0.contents + "&amp;"; break;
              case "\"": arg$0.contents = arg$0.contents + "&quot;"; break;
              case "'": arg$0.contents = arg$0.contents + "&apos;"; break;
              case ">": arg$0.contents = arg$0.contents + "&gt;"; break;
              case "<": arg$0.contents = arg$0.contents + "&lt;"; break;
              case "/": arg$0.contents = arg$0.contents + "&#x2F;"; break;
              case "`": arg$0.contents = arg$0.contents + "&#x60;"; break;
              case "=": arg$0.contents = arg$0.contents + "&#x3D;"; break;
              default: arg$0.contents = arg$0.contents + c$0;
            }
          }
        }
      );
    };
  let components$0 = new Map();
  import {"externalFunction" as import$0} from "./jsfile.cjs";
  components$0.set(
    "ExternalFunction",
    (arg$0) => {
      let encoded$0 = new Map();
      let props$0 = arg$0.get("children");
      encoded$0.set("children", props$0);
      return (import$0(Object.fromEntries(encoded$0)));
    }
  );
  export default (arg$0) => {
    let errors$0 = {contents: ""};
    let decode_error$0 =
      (arg$1) => {
        return (
          (arg$2) => {
            return (
              (arg$3) => {
                if (!(errors$0.contents.length === 0)) {
                  buffer_add_string$0(errors$0)("\n\n");
                }
                buffer_add_string$0(errors$0)("File \"");
                buffer_add_string$0(errors$0)("template.acutis");
                buffer_add_string$0(errors$0)(
                  "\"\n\
  Render error.\n\
  The data supplied does not match this template's interface.\n\
  "
                );
                buffer_add_string$0(errors$0)("Path:\n");
                buffer_add_string$0(errors$0)(arg$1[0]);
                let stack$0 = arg$1[1];
                while (!(stack$0 === 0)) {
                  buffer_add_string$0(errors$0)(" <- ");
                  buffer_add_string$0(errors$0)(stack$0[0]);
                  stack$0 = stack$0[1];
                }
                buffer_add_string$0(errors$0)("\nExpected type:\n");
                buffer_add_string$0(errors$0)(arg$2);
                buffer_add_string$0(errors$0)("\nReceived value:\n");
                buffer_add_string$0(errors$0)(String(arg$3));
              }
            );
          }
        );
      };
    let key_error$0 =
      (arg$1) => {
        return (
          (arg$2) => {
            return (
              (arg$3) => {
                if (!(errors$0.contents.length === 0)) {
                  buffer_add_string$0(errors$0)("\n\n");
                }
                buffer_add_string$0(errors$0)("File: ");
                buffer_add_string$0(errors$0)("template.acutis");
                buffer_add_string$0(errors$0)(
                  "\n\
  Render error.\n\
  The data supplied does not match this template's interface.\n\
  "
                );
                buffer_add_string$0(errors$0)("Path:\n");
                buffer_add_string$0(errors$0)(arg$1[0]);
                let stack$0 = arg$1[1];
                while (!(stack$0 === 0)) {
                  buffer_add_string$0(errors$0)(" <- ");
                  buffer_add_string$0(errors$0)(stack$0[0]);
                  stack$0 = stack$0[1];
                }
                buffer_add_string$0(errors$0)("\nExpected type:\n");
                buffer_add_string$0(errors$0)(arg$2);
                buffer_add_string$0(errors$0)("\nInput is missing keys:\n");
                buffer_add_string$0(errors$0)(arg$3[0]);
                let stack$1 = arg$3[1];
                while (!(stack$1 === 0)) {
                  buffer_add_string$0(errors$0)(", ");
                  buffer_add_string$0(errors$0)(stack$1[0]);
                  stack$1 = stack$1[1];
                }
              }
            );
          }
        );
      };
    let props$0 = new Map();
    let stack$0 = ["<input>", 0];
    let type$0 = "{}";
    if (typeof arg$0 === "object" && !(arg$0 === null)) {
      let missing_keys$0 = 0;
      if (!(missing_keys$0 === 0)) {
        key_error$0(stack$0)(type$0)(missing_keys$0);
      }
    } else {
      decode_error$0(stack$0)(type$0)(arg$0);
    }
    if (errors$0.contents.length === 0) {
      let buf_sync$0 = {contents: ""};
      let buf_async$0 = Promise.resolve({contents: ""});
      let buf_sync$1 = {contents: ""};
      let buf_async$1 = Promise.resolve({contents: ""});
      buffer_add_string$0(buf_sync$1)(" text ");
      let sync_contents$0 = buf_sync$0.contents;
      buf_sync$0.contents = "";
      buf_async$0 =
        buf_async$0.then(
          (arg$1) => {
            return (
              buf_async$1.then(
                (arg$2) => {
                  buffer_add_buffer$0(arg$2)(buf_sync$1);
                  return (Promise.resolve(arg$2.contents));
                }
              ).then(
                (arg$2) => {
                  let buf_sync$2 = {contents: ""};
                  let buf_async$2 = Promise.resolve({contents: ""});
                  let sync_contents$1 = buf_sync$2.contents;
                  buf_sync$2.contents = "";
                  buf_async$2 =
                    buf_async$2.then(
                      (arg$3) => {
                        return (
                          components$0.get("ExternalFunction")(
                            new Map([["children", arg$2]])
                          ).then(
                            (arg$4) => {
                              buffer_add_string$0(arg$3)(sync_contents$1);
                              buffer_add_string$0(arg$3)(arg$4);
                              return (Promise.resolve(arg$3));
                            }
                          )
                        );
                      }
                    );
                  return (
                    buf_async$2.then(
                      (arg$3) => {
                        buffer_add_buffer$0(arg$3)(buf_sync$2);
                        return (Promise.resolve(arg$3.contents));
                      }
                    )
                  );
                }
              ).then(
                (arg$2) => {
                  buffer_add_string$0(arg$1)(sync_contents$0);
                  buffer_add_string$0(arg$1)(arg$2);
                  return (Promise.resolve(arg$1));
                }
              )
            );
          }
        );
      buffer_add_string$0(buf_sync$0)("\n");
      return (
        buf_async$0.then(
          (arg$1) => {
            buffer_add_buffer$0(arg$1)(buf_sync$0);
            return (Promise.resolve(arg$1.contents));
          }
        )
      );
    } else {
      return (Promise.reject(new Error(errors$0.contents)));
    }
  };

  $ acutis \
  >   --mode cjs \
  >   template.acutis \
  >   --fun ./jsfile.cjs externalFunction "children = string"
  /* THIS FILE WAS GENERATED BY ACUTIS. */
  let buffer_add_string$0 =
    (arg$0) => {
      return ((arg$1) => { arg$0.contents = arg$0.contents + arg$1; });
    };
  let buffer_add_buffer$0 =
    (arg$0) => {
      return (
        (arg$1) => { arg$0.contents = arg$0.contents + arg$1.contents; }
      );
    };
  let buffer_add_escape$0 =
    (arg$0) => {
      return (
        (arg$1) => {
          for (let i$0 = 0; i$0 < arg$1.length; i$0++) {
            let c$0 = arg$1[i$0];
            switch (c$0) {
              case "&": arg$0.contents = arg$0.contents + "&amp;"; break;
              case "\"": arg$0.contents = arg$0.contents + "&quot;"; break;
              case "'": arg$0.contents = arg$0.contents + "&apos;"; break;
              case ">": arg$0.contents = arg$0.contents + "&gt;"; break;
              case "<": arg$0.contents = arg$0.contents + "&lt;"; break;
              case "/": arg$0.contents = arg$0.contents + "&#x2F;"; break;
              case "`": arg$0.contents = arg$0.contents + "&#x60;"; break;
              case "=": arg$0.contents = arg$0.contents + "&#x3D;"; break;
              default: arg$0.contents = arg$0.contents + c$0;
            }
          }
        }
      );
    };
  let components$0 = new Map();
  let import$0 = require("./jsfile.cjs");
  components$0.set(
    "ExternalFunction",
    (arg$0) => {
      let encoded$0 = new Map();
      let props$0 = arg$0.get("children");
      encoded$0.set("children", props$0);
      return (import$0["externalFunction"](Object.fromEntries(encoded$0)));
    }
  );
  module.exports =
    (arg$0) => {
      let errors$0 = {contents: ""};
      let decode_error$0 =
        (arg$1) => {
          return (
            (arg$2) => {
              return (
                (arg$3) => {
                  if (!(errors$0.contents.length === 0)) {
                    buffer_add_string$0(errors$0)("\n\n");
                  }
                  buffer_add_string$0(errors$0)("File \"");
                  buffer_add_string$0(errors$0)("template.acutis");
                  buffer_add_string$0(errors$0)(
                    "\"\n\
  Render error.\n\
  The data supplied does not match this template's interface.\n\
  "
                  );
                  buffer_add_string$0(errors$0)("Path:\n");
                  buffer_add_string$0(errors$0)(arg$1[0]);
                  let stack$0 = arg$1[1];
                  while (!(stack$0 === 0)) {
                    buffer_add_string$0(errors$0)(" <- ");
                    buffer_add_string$0(errors$0)(stack$0[0]);
                    stack$0 = stack$0[1];
                  }
                  buffer_add_string$0(errors$0)("\nExpected type:\n");
                  buffer_add_string$0(errors$0)(arg$2);
                  buffer_add_string$0(errors$0)("\nReceived value:\n");
                  buffer_add_string$0(errors$0)(String(arg$3));
                }
              );
            }
          );
        };
      let key_error$0 =
        (arg$1) => {
          return (
            (arg$2) => {
              return (
                (arg$3) => {
                  if (!(errors$0.contents.length === 0)) {
                    buffer_add_string$0(errors$0)("\n\n");
                  }
                  buffer_add_string$0(errors$0)("File: ");
                  buffer_add_string$0(errors$0)("template.acutis");
                  buffer_add_string$0(errors$0)(
                    "\n\
  Render error.\n\
  The data supplied does not match this template's interface.\n\
  "
                  );
                  buffer_add_string$0(errors$0)("Path:\n");
                  buffer_add_string$0(errors$0)(arg$1[0]);
                  let stack$0 = arg$1[1];
                  while (!(stack$0 === 0)) {
                    buffer_add_string$0(errors$0)(" <- ");
                    buffer_add_string$0(errors$0)(stack$0[0]);
                    stack$0 = stack$0[1];
                  }
                  buffer_add_string$0(errors$0)("\nExpected type:\n");
                  buffer_add_string$0(errors$0)(arg$2);
                  buffer_add_string$0(errors$0)("\nInput is missing keys:\n");
                  buffer_add_string$0(errors$0)(arg$3[0]);
                  let stack$1 = arg$3[1];
                  while (!(stack$1 === 0)) {
                    buffer_add_string$0(errors$0)(", ");
                    buffer_add_string$0(errors$0)(stack$1[0]);
                    stack$1 = stack$1[1];
                  }
                }
              );
            }
          );
        };
      let props$0 = new Map();
      let stack$0 = ["<input>", 0];
      let type$0 = "{}";
      if (typeof arg$0 === "object" && !(arg$0 === null)) {
        let missing_keys$0 = 0;
        if (!(missing_keys$0 === 0)) {
          key_error$0(stack$0)(type$0)(missing_keys$0);
        }
      } else {
        decode_error$0(stack$0)(type$0)(arg$0);
      }
      if (errors$0.contents.length === 0) {
        let buf_sync$0 = {contents: ""};
        let buf_async$0 = Promise.resolve({contents: ""});
        let buf_sync$1 = {contents: ""};
        let buf_async$1 = Promise.resolve({contents: ""});
        buffer_add_string$0(buf_sync$1)(" text ");
        let sync_contents$0 = buf_sync$0.contents;
        buf_sync$0.contents = "";
        buf_async$0 =
          buf_async$0.then(
            (arg$1) => {
              return (
                buf_async$1.then(
                  (arg$2) => {
                    buffer_add_buffer$0(arg$2)(buf_sync$1);
                    return (Promise.resolve(arg$2.contents));
                  }
                ).then(
                  (arg$2) => {
                    let buf_sync$2 = {contents: ""};
                    let buf_async$2 = Promise.resolve({contents: ""});
                    let sync_contents$1 = buf_sync$2.contents;
                    buf_sync$2.contents = "";
                    buf_async$2 =
                      buf_async$2.then(
                        (arg$3) => {
                          return (
                            components$0.get("ExternalFunction")(
                              new Map([["children", arg$2]])
                            ).then(
                              (arg$4) => {
                                buffer_add_string$0(arg$3)(sync_contents$1);
                                buffer_add_string$0(arg$3)(arg$4);
                                return (Promise.resolve(arg$3));
                              }
                            )
                          );
                        }
                      );
                    return (
                      buf_async$2.then(
                        (arg$3) => {
                          buffer_add_buffer$0(arg$3)(buf_sync$2);
                          return (Promise.resolve(arg$3.contents));
                        }
                      )
                    );
                  }
                ).then(
                  (arg$2) => {
                    buffer_add_string$0(arg$1)(sync_contents$0);
                    buffer_add_string$0(arg$1)(arg$2);
                    return (Promise.resolve(arg$1));
                  }
                )
              );
            }
          );
        buffer_add_string$0(buf_sync$0)("\n");
        return (
          buf_async$0.then(
            (arg$1) => {
              buffer_add_buffer$0(arg$1)(buf_sync$0);
              return (Promise.resolve(arg$1.contents));
            }
          )
        );
      } else {
        return (Promise.reject(new Error(errors$0.contents)));
      }
    };

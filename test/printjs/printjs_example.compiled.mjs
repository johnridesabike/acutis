/* THIS FILE WAS GENERATED BY ACUTIS. */
let buffer_add_escape$0 =
  (arg$0) => {
    return (
      (arg$1) => {
        for (let item$0 of arg$1[Symbol.iterator]()) {
          switch (item$0) {
            case "&": arg$0.contents += "&amp;"; break;
            case "\"": arg$0.contents += "&quot;"; break;
            case "'": arg$0.contents += "&apos;"; break;
            case ">": arg$0.contents += "&gt;"; break;
            case "<": arg$0.contents += "&lt;"; break;
            case "/": arg$0.contents += "&sol;"; break;
            case "`": arg$0.contents += "&grave;"; break;
            case "=": arg$0.contents += "&equals;"; break;
            default: arg$0.contents += item$0;
          }
        }
      }
    );
  };
let buffer_add_sep$0 =
  (arg$0) => {
    return (
      (arg$1) => {
        return (
          (arg$2) => {
            if (!(arg$0.contents.length === 0)) { arg$0.contents += arg$1; }
            arg$0.contents += arg$2;
          }
        );
      }
    );
  };
let stack_empty$0 = (arg$0) => {  };
let stack_is_empty$0 =
  (arg$0) => {
    let result$0 = true;
    arg$0((arg$1) => { result$0 = false; });
    return (result$0);
  };
let stack_add$0 =
  (arg$0) => {
    return (
      (arg$1) => {
        return ((arg$2) => { arg$1(arg$2); return (arg$2(arg$0)); });
      }
    );
  };
let error_aux$0 =
  (arg$0) => {
    return (
      (arg$1) => {
        return (
          (arg$2) => {
            return (
              (arg$3) => {
                let buf$0 = {contents: ""};
                buf$0.contents += "Error while rendering \"";
                buf$0.contents += "printjs_example.acutis";
                buf$0.contents +=
                  "\".\n\
The data supplied does not match this template's interface.\n\
";
                buf$0.contents += "Path:\n<input>";
                arg$2(buffer_add_sep$0(buf$0)(" -> "));
                buf$0.contents += "\nExpected type:\n";
                buf$0.contents += arg$3;
                buf$0.contents += arg$0;
                buf$0.contents += arg$1;
                return (buf$0.contents);
              }
            );
          }
        );
      }
    );
  };
let decode_error$0 =
  (arg$0) => { return (error_aux$0("\nReceived value:\n")(String(arg$0))); };
let key_error$0 =
  (arg$0) => {
    let buf$0 = {contents: ""};
    arg$0(buffer_add_sep$0(buf$0)(", "));
    return (error_aux$0("\nInput is missing keys:\n")(buf$0.contents));
  };
function Int$0(arg$0) { this.v = arg$0; }
function String$0(arg$0) { this.v = arg$0; }
function Float$0(arg$0) { this.v = arg$0; }
function Array$0(arg$0) { this.v = arg$0; }
function Hashtbl$0(arg$0) { this.v = arg$0; }
function Unknown$0(arg$0) { this.v = arg$0; }
let zero$0 = new Int$0(0);
let one$0 = new Int$0(1);
export default async (arg$0) => {
  let props$0 = new Map();
  let type$0 =
    "blogPosts =\n\
  [\n\
    {\n\
      author: {name: ?string},\n\
      content: string,\n\
      date: string,\n\
      image: ?{alt: string, src: string},\n\
      title: string\n\
    }\n\
  ]\n\
siteTitle = string";
  let decode_or_errors$0 =
    (function* () {
      if (typeof arg$0 === "object" && !(arg$0 === null)) {
        let missing_keys$0 = stack_empty$0;
        if (Object.hasOwn(arg$0, "blogPosts")) {
          let input$0 = arg$0["blogPosts"];
          let stack$0 = stack_add$0("blogPosts")(stack_empty$0);
          let type$1 =
            "[\n\
  {\n\
    author: {name: ?string},\n\
    content: string,\n\
    date: string,\n\
    image: ?{alt: string, src: string},\n\
    title: string\n\
  }\n\
]";
          if (Array.isArray(input$0)) {
            let seq$0 = input$0.values();
            let index$0 = 0;
            let decoded$0 = [zero$0, zero$0];
            let decode_dst$0 = decoded$0;
            for (let item$0 of seq$0) {
              let decode_dst_new$0 = [zero$0, zero$0];
              let stack$1 = stack_add$0(String(index$0))(stack$0);
              let type$2 =
                "{\n\
  author: {name: ?string},\n\
  content: string,\n\
  date: string,\n\
  image: ?{alt: string, src: string},\n\
  title: string\n\
}";
              if (typeof item$0 === "object" && !(item$0 === null)) {
                let decoded$1 = new Map();
                let missing_keys$1 = stack_empty$0;
                if (Object.hasOwn(item$0, "author")) {
                  let input$1 = item$0["author"];
                  let stack$2 = stack_add$0("author")(stack$1);
                  let type$3 = "{name: ?string}";
                  if (typeof input$1 === "object" && !(input$1 === null)) {
                    let decoded$2 = new Map();
                    let missing_keys$2 = stack_empty$0;
                    if (Object.hasOwn(input$1, "name")) {
                      let input$2 = input$1["name"];
                      let stack$3 = stack_add$0("name")(stack$2);
                      let type$4 = "?string";
                      if (!(input$2 === null) && !(input$2 === undefined)) {
                        let decoded$3 = [zero$0];
                        let stack$4 = stack_add$0("<nullable>")(stack$3);
                        let type$5 = "string";
                        if (typeof input$2 === "string") {
                          decoded$3[0] = new String$0(input$2);
                        } else {
                          yield (decode_error$0(input$2)(stack$4)(type$5));
                        }
                        decoded$2.set("name", new Array$0(decoded$3));
                      } else {
                        decoded$2.set("name", zero$0);
                      }
                    } else {
                      decoded$2.set("name", zero$0);
                    }
                    if (!(stack_is_empty$0(missing_keys$2))) {
                      yield (key_error$0(missing_keys$2)(stack$2)(type$3));
                    }
                    decoded$1.set("author", new Hashtbl$0(decoded$2));
                  } else {
                    yield (decode_error$0(input$1)(stack$2)(type$3));
                  }
                } else {
                  missing_keys$1 = stack_add$0("author")(missing_keys$1);
                }
                if (Object.hasOwn(item$0, "content")) {
                  let input$1 = item$0["content"];
                  let stack$2 = stack_add$0("content")(stack$1);
                  let type$3 = "string";
                  if (typeof input$1 === "string") {
                    decoded$1.set("content", new String$0(input$1));
                  } else {
                    yield (decode_error$0(input$1)(stack$2)(type$3));
                  }
                } else {
                  missing_keys$1 = stack_add$0("content")(missing_keys$1);
                }
                if (Object.hasOwn(item$0, "date")) {
                  let input$1 = item$0["date"];
                  let stack$2 = stack_add$0("date")(stack$1);
                  let type$3 = "string";
                  if (typeof input$1 === "string") {
                    decoded$1.set("date", new String$0(input$1));
                  } else {
                    yield (decode_error$0(input$1)(stack$2)(type$3));
                  }
                } else {
                  missing_keys$1 = stack_add$0("date")(missing_keys$1);
                }
                if (Object.hasOwn(item$0, "image")) {
                  let input$1 = item$0["image"];
                  let stack$2 = stack_add$0("image")(stack$1);
                  let type$3 = "?{alt: string, src: string}";
                  if (!(input$1 === null) && !(input$1 === undefined)) {
                    let decoded$2 = [zero$0];
                    let stack$3 = stack_add$0("<nullable>")(stack$2);
                    let type$4 = "{alt: string, src: string}";
                    if (typeof input$1 === "object" && !(input$1 === null)) {
                      let decoded$3 = new Map();
                      let missing_keys$2 = stack_empty$0;
                      if (Object.hasOwn(input$1, "alt")) {
                        let input$2 = input$1["alt"];
                        let stack$4 = stack_add$0("alt")(stack$3);
                        let type$5 = "string";
                        if (typeof input$2 === "string") {
                          decoded$3.set("alt", new String$0(input$2));
                        } else {
                          yield (decode_error$0(input$2)(stack$4)(type$5));
                        }
                      } else {
                        missing_keys$2 = stack_add$0("alt")(missing_keys$2);
                      }
                      if (Object.hasOwn(input$1, "src")) {
                        let input$2 = input$1["src"];
                        let stack$4 = stack_add$0("src")(stack$3);
                        let type$5 = "string";
                        if (typeof input$2 === "string") {
                          decoded$3.set("src", new String$0(input$2));
                        } else {
                          yield (decode_error$0(input$2)(stack$4)(type$5));
                        }
                      } else {
                        missing_keys$2 = stack_add$0("src")(missing_keys$2);
                      }
                      if (!(stack_is_empty$0(missing_keys$2))) {
                        yield (key_error$0(missing_keys$2)(stack$3)(type$4));
                      }
                      decoded$2[0] = new Hashtbl$0(decoded$3);
                    } else {
                      yield (decode_error$0(input$1)(stack$3)(type$4));
                    }
                    decoded$1.set("image", new Array$0(decoded$2));
                  } else {
                    decoded$1.set("image", zero$0);
                  }
                } else {
                  decoded$1.set("image", zero$0);
                }
                if (Object.hasOwn(item$0, "title")) {
                  let input$1 = item$0["title"];
                  let stack$2 = stack_add$0("title")(stack$1);
                  let type$3 = "string";
                  if (typeof input$1 === "string") {
                    decoded$1.set("title", new String$0(input$1));
                  } else {
                    yield (decode_error$0(input$1)(stack$2)(type$3));
                  }
                } else {
                  missing_keys$1 = stack_add$0("title")(missing_keys$1);
                }
                if (!(stack_is_empty$0(missing_keys$1))) {
                  yield (key_error$0(missing_keys$1)(stack$1)(type$2));
                }
                decode_dst_new$0[0] = new Hashtbl$0(decoded$1);
              } else {
                yield (decode_error$0(item$0)(stack$1)(type$2));
              }
              decode_dst$0[1] = new Array$0(decode_dst_new$0);
              index$0++;
              decode_dst$0 = decode_dst_new$0;
            }
            props$0.set("blogPosts", decoded$0[1]);
          } else {
            yield (decode_error$0(input$0)(stack$0)(type$1));
          }
        } else {
          missing_keys$0 = stack_add$0("blogPosts")(missing_keys$0);
        }
        if (Object.hasOwn(arg$0, "siteTitle")) {
          let input$0 = arg$0["siteTitle"];
          let stack$0 = stack_add$0("siteTitle")(stack_empty$0);
          let type$1 = "string";
          if (typeof input$0 === "string") {
            props$0.set("siteTitle", new String$0(input$0));
          } else {
            yield (decode_error$0(input$0)(stack$0)(type$1));
          }
        } else {
          missing_keys$0 = stack_add$0("siteTitle")(missing_keys$0);
        }
        if (!(stack_is_empty$0(missing_keys$0))) {
          yield (key_error$0(missing_keys$0)(stack_empty$0)(type$0));
        }
      } else {
        yield (decode_error$0(arg$0)(stack_empty$0)(type$0));
      }
    })();
  let errors$0 = Array.from(decode_or_errors$0).join("\n\n");
  if (errors$0.length === 0) {
    let buf$0 = {contents: ""};
    buf$0.contents += "<h1> Blog posts for ";
    buffer_add_escape$0(buf$0)(props$0.get("siteTitle").v);
    buf$0.contents += " </h1>";
    let index$0 = 0;
    let cell$0 = props$0.get("blogPosts");
    while (!(cell$0 instanceof Int$0)) {
      let match_props$0 = new Map();
      let list$0 = cell$0.v;
      let head$0 = list$0[0];
      let exit$0 = -1;
      let match_arg$0 = head$0.v.get("author");
      let match_arg$1 = match_arg$0.v.get("name");
      let match_arg$2 = head$0.v.get("content");
      let match_arg$3 = head$0.v.get("date");
      let match_arg$4 = head$0.v.get("image");
      let match_arg$5 = head$0.v.get("title");
      match_props$0.set("content", match_arg$2);
      match_props$0.set("date", match_arg$3);
      match_props$0.set("image", match_arg$4);
      match_props$0.set("name", match_arg$1);
      match_props$0.set("title", match_arg$5);
      exit$0 = 0;
      buf$0.contents +=
        "\n  <article class=\"h-entry\">\n    <header>\n      ";
      let arg_match$0 = [match_props$0.get("image")];
      let match_props$1 = new Map();
      let exit$1 = -1;
      let match_arg$6 = arg_match$0[0];
      if (match_arg$6 instanceof Int$0) {
        exit$1 = 0;
      } else {
        let match_arg$7 = arg_match$0[0];
        let match_arg$8 = match_arg$7.v[0];
        let match_arg$9 = match_arg$8.v.get("alt");
        let match_arg$10 = match_arg$8.v.get("src");
        match_props$1.set("alt", match_arg$9);
        match_props$1.set("src", match_arg$10);
        exit$1 = 1;
      }
      if (!(exit$1 === 0)) {
        buf$0.contents += "<img src=\"";
        buffer_add_escape$0(buf$0)(match_props$1.get("src").v);
        buf$0.contents += "\" alt=\"";
        buffer_add_escape$0(buf$0)(match_props$1.get("alt").v);
        buf$0.contents += "\">\n      ";
      }
      buf$0.contents += "<h2 class=\"p-name\"> ";
      buffer_add_escape$0(buf$0)(match_props$0.get("title").v);
      buf$0.contents += " </h2>\n      <span class=\"p-author\"> By ";
      let nullable$0 = match_props$0.get("name");
      if (nullable$0 instanceof Int$0) {
        buffer_add_escape$0(buf$0)("Anonymous");
      } else {
        buffer_add_escape$0(buf$0)(nullable$0.v[0].v);
      }
      buf$0.contents +=
        " </span>\n      <span class=\"dt-published\"> Posted on ";
      buffer_add_escape$0(buf$0)(match_props$0.get("date").v);
      buf$0.contents +=
        " </span>\n    </header>\n    <div class=\"e-content\"> ";
      buf$0.contents += match_props$0.get("content").v;
      buf$0.contents += " </div>\n  </article>\n";
      index$0++;
      cell$0 = list$0[1];
    }
    buf$0.contents += "\n";
    return (Promise.resolve(buf$0.contents));
  } else {
    return (Promise.reject(new Error(errors$0)));
  }
};
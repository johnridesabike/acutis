/* THIS FILE WAS GENERATED BY ACUTIS. */
let buffer_add_escape$0 =
  (arg$0) => {
    return (
      (arg$1) => {
        for (let item$0 of arg$1[Symbol.iterator]()) {
          switch (item$0) {
            case "&": arg$0.contents += "&amp;"; break;
            case "\"": arg$0.contents += "&quot;"; break;
            case "'": arg$0.contents += "&apos;"; break;
            case ">": arg$0.contents += "&gt;"; break;
            case "<": arg$0.contents += "&lt;"; break;
            case "/": arg$0.contents += "&sol;"; break;
            case "`": arg$0.contents += "&grave;"; break;
            case "=": arg$0.contents += "&equals;"; break;
            default: arg$0.contents += item$0;
          }
        }
      }
    );
  };
let buffer_add_sep$0 =
  (arg$0) => {
    return (
      (arg$1) => {
        return (
          (arg$2) => {
            if (!(arg$0.contents.length === 0)) { arg$0.contents += arg$1; }
            arg$0.contents += arg$2;
          }
        );
      }
    );
  };
let stack_empty$0 = (arg$0) => {  };
let stack_is_empty$0 =
  (arg$0) => {
    let result$0 = true;
    arg$0((arg$1) => { result$0 = false; });
    return (result$0);
  };
let stack_add$0 =
  (arg$0) => {
    return (
      (arg$1) => {
        return ((arg$2) => { arg$1(arg$2); return (arg$2(arg$0)); });
      }
    );
  };
export default async (arg$0) => {
  let errors$0 = {contents: ""};
  let error_aux$0 =
    (arg$1) => {
      return (
        (arg$2) => {
          return (
            (arg$3) => {
              return (
                (arg$4) => {
                  if (!(errors$0.contents.length === 0)) {
                    errors$0.contents += "\n\n";
                  }
                  errors$0.contents += "File \"";
                  errors$0.contents += "printjs_example.acutis";
                  errors$0.contents +=
                    "\"\n\
Render error.\n\
The data supplied does not match this template's interface.\n\
";
                  errors$0.contents += "Path:\n<input>";
                  arg$3(buffer_add_sep$0(errors$0)(" -> "));
                  errors$0.contents += "\nExpected type:\n";
                  errors$0.contents += arg$4;
                  errors$0.contents += arg$1;
                  errors$0.contents += arg$2;
                }
              );
            }
          );
        }
      );
    };
  let decode_error$0 =
    (arg$1) => {
      return (error_aux$0("\nReceived value:\n")(String(arg$1)));
    };
  let key_error$0 =
    (arg$1) => {
      let buf$0 = {contents: ""};
      arg$1(buffer_add_sep$0(buf$0)(", "));
      return (error_aux$0("\nInput is missing keys:\n")(buf$0.contents));
    };
  let props$0 = new Map();
  let type$0 =
    "{\n\
  blogPosts:\n\
    [\n\
      {\n\
        author: {name: ?string},\n\
        content: string,\n\
        date: string,\n\
        image: ?{alt: string, src: string},\n\
        title: string\n\
      }\n\
    ],\n\
  siteTitle: string\n\
}";
  if (typeof arg$0 === "object" && !(arg$0 === null)) {
    let missing_keys$0 = stack_empty$0;
    if (Object.hasOwn(arg$0, "blogPosts")) {
      let input$0 = arg$0["blogPosts"];
      let stack$0 = stack_add$0("blogPosts")(stack_empty$0);
      let type$1 =
        "[\n\
  {\n\
    author: {name: ?string},\n\
    content: string,\n\
    date: string,\n\
    image: ?{alt: string, src: string},\n\
    title: string\n\
  }\n\
]";
      if (Array.isArray(input$0)) {
        let seq$0 = input$0.values();
        let index$0 = 0;
        let decoded$0 = [0, 0];
        let decode_dst$0 = decoded$0;
        for (let item$0 of seq$0) {
          let decode_dst_new$0 = [0, 0];
          let stack$1 = stack_add$0(String(index$0))(stack$0);
          let type$2 =
            "{\n\
  author: {name: ?string},\n\
  content: string,\n\
  date: string,\n\
  image: ?{alt: string, src: string},\n\
  title: string\n\
}";
          if (typeof item$0 === "object" && !(item$0 === null)) {
            let decoded$1 = new Map();
            let missing_keys$1 = stack_empty$0;
            if (Object.hasOwn(item$0, "author")) {
              let input$1 = item$0["author"];
              let stack$2 = stack_add$0("author")(stack$1);
              let type$3 = "{name: ?string}";
              if (typeof input$1 === "object" && !(input$1 === null)) {
                let decoded$2 = new Map();
                let missing_keys$2 = stack_empty$0;
                if (Object.hasOwn(input$1, "name")) {
                  let input$2 = input$1["name"];
                  let stack$3 = stack_add$0("name")(stack$2);
                  let type$4 = "?string";
                  if (!(input$2 === null) && !(input$2 === undefined)) {
                    let decoded$3 = [0];
                    let stack$4 = stack_add$0("<nullable>")(stack$3);
                    let type$5 = "string";
                    if (typeof input$2 === "string") {
                      decoded$3[0] = input$2;
                    } else {
                      decode_error$0(input$2)(stack$4)(type$5);
                    }
                    decoded$2.set("name", decoded$3);
                  } else {
                    decoded$2.set("name", 0);
                  }
                } else {
                  decoded$2.set("name", 0);
                }
                if (!(stack_is_empty$0(missing_keys$2))) {
                  key_error$0(missing_keys$2)(stack$2)(type$3);
                }
                decoded$1.set("author", decoded$2);
              } else {
                decode_error$0(input$1)(stack$2)(type$3);
              }
            } else {
              missing_keys$1 = stack_add$0("author")(missing_keys$1);
            }
            if (Object.hasOwn(item$0, "content")) {
              let input$1 = item$0["content"];
              let stack$2 = stack_add$0("content")(stack$1);
              let type$3 = "string";
              if (typeof input$1 === "string") {
                decoded$1.set("content", input$1);
              } else {
                decode_error$0(input$1)(stack$2)(type$3);
              }
            } else {
              missing_keys$1 = stack_add$0("content")(missing_keys$1);
            }
            if (Object.hasOwn(item$0, "date")) {
              let input$1 = item$0["date"];
              let stack$2 = stack_add$0("date")(stack$1);
              let type$3 = "string";
              if (typeof input$1 === "string") {
                decoded$1.set("date", input$1);
              } else {
                decode_error$0(input$1)(stack$2)(type$3);
              }
            } else {
              missing_keys$1 = stack_add$0("date")(missing_keys$1);
            }
            if (Object.hasOwn(item$0, "image")) {
              let input$1 = item$0["image"];
              let stack$2 = stack_add$0("image")(stack$1);
              let type$3 = "?{alt: string, src: string}";
              if (!(input$1 === null) && !(input$1 === undefined)) {
                let decoded$2 = [0];
                let stack$3 = stack_add$0("<nullable>")(stack$2);
                let type$4 = "{alt: string, src: string}";
                if (typeof input$1 === "object" && !(input$1 === null)) {
                  let decoded$3 = new Map();
                  let missing_keys$2 = stack_empty$0;
                  if (Object.hasOwn(input$1, "alt")) {
                    let input$2 = input$1["alt"];
                    let stack$4 = stack_add$0("alt")(stack$3);
                    let type$5 = "string";
                    if (typeof input$2 === "string") {
                      decoded$3.set("alt", input$2);
                    } else {
                      decode_error$0(input$2)(stack$4)(type$5);
                    }
                  } else {
                    missing_keys$2 = stack_add$0("alt")(missing_keys$2);
                  }
                  if (Object.hasOwn(input$1, "src")) {
                    let input$2 = input$1["src"];
                    let stack$4 = stack_add$0("src")(stack$3);
                    let type$5 = "string";
                    if (typeof input$2 === "string") {
                      decoded$3.set("src", input$2);
                    } else {
                      decode_error$0(input$2)(stack$4)(type$5);
                    }
                  } else {
                    missing_keys$2 = stack_add$0("src")(missing_keys$2);
                  }
                  if (!(stack_is_empty$0(missing_keys$2))) {
                    key_error$0(missing_keys$2)(stack$3)(type$4);
                  }
                  decoded$2[0] = decoded$3;
                } else {
                  decode_error$0(input$1)(stack$3)(type$4);
                }
                decoded$1.set("image", decoded$2);
              } else {
                decoded$1.set("image", 0);
              }
            } else {
              decoded$1.set("image", 0);
            }
            if (Object.hasOwn(item$0, "title")) {
              let input$1 = item$0["title"];
              let stack$2 = stack_add$0("title")(stack$1);
              let type$3 = "string";
              if (typeof input$1 === "string") {
                decoded$1.set("title", input$1);
              } else {
                decode_error$0(input$1)(stack$2)(type$3);
              }
            } else {
              missing_keys$1 = stack_add$0("title")(missing_keys$1);
            }
            if (!(stack_is_empty$0(missing_keys$1))) {
              key_error$0(missing_keys$1)(stack$1)(type$2);
            }
            decode_dst_new$0[0] = decoded$1;
          } else {
            decode_error$0(item$0)(stack$1)(type$2);
          }
          decode_dst$0[1] = decode_dst_new$0;
          index$0++;
          decode_dst$0 = decode_dst_new$0;
        }
        props$0.set("blogPosts", decoded$0[1]);
      } else {
        decode_error$0(input$0)(stack$0)(type$1);
      }
    } else {
      missing_keys$0 = stack_add$0("blogPosts")(missing_keys$0);
    }
    if (Object.hasOwn(arg$0, "siteTitle")) {
      let input$0 = arg$0["siteTitle"];
      let stack$0 = stack_add$0("siteTitle")(stack_empty$0);
      let type$1 = "string";
      if (typeof input$0 === "string") {
        props$0.set("siteTitle", input$0);
      } else {
        decode_error$0(input$0)(stack$0)(type$1);
      }
    } else {
      missing_keys$0 = stack_add$0("siteTitle")(missing_keys$0);
    }
    if (!(stack_is_empty$0(missing_keys$0))) {
      key_error$0(missing_keys$0)(stack_empty$0)(type$0);
    }
  } else {
    decode_error$0(arg$0)(stack_empty$0)(type$0);
  }
  if (errors$0.contents.length === 0) {
    let buf$0 = {contents: ""};
    buf$0.contents += "<h1> Blog posts for ";
    buffer_add_escape$0(buf$0)(props$0.get("siteTitle"));
    buf$0.contents += " </h1>";
    let index$0 = 0;
    let cell$0 = props$0.get("blogPosts");
    while (!(typeof cell$0 === "number")) {
      let match_props$0 = new Map();
      let head$0 = cell$0[0];
      let exit$0 = -1;
      let match_arg$0 = head$0.get("author");
      let match_arg$1 = match_arg$0.get("name");
      let match_arg$2 = head$0.get("content");
      let match_arg$3 = head$0.get("date");
      let match_arg$4 = head$0.get("image");
      let match_arg$5 = head$0.get("title");
      match_props$0.set("content", match_arg$2);
      match_props$0.set("date", match_arg$3);
      match_props$0.set("image", match_arg$4);
      match_props$0.set("name", match_arg$1);
      match_props$0.set("title", match_arg$5);
      exit$0 = 0;
      buf$0.contents +=
        "\n  <article class=\"h-entry\">\n    <header>\n      ";
      let arg_match$0 = [match_props$0.get("image")];
      let match_props$1 = new Map();
      let exit$1 = -1;
      let match_arg$6 = arg_match$0[0];
      if (typeof match_arg$6 === "number") {
        exit$1 = 0;
      } else {
        let match_arg$7 = arg_match$0[0];
        let match_arg$8 = match_arg$7[0];
        let match_arg$9 = match_arg$8.get("alt");
        let match_arg$10 = match_arg$8.get("src");
        match_props$1.set("alt", match_arg$9);
        match_props$1.set("src", match_arg$10);
        exit$1 = 1;
      }
      if (!(exit$1 === 0)) {
        buf$0.contents += "<img src=\"";
        buffer_add_escape$0(buf$0)(match_props$1.get("src"));
        buf$0.contents += "\" alt=\"";
        buffer_add_escape$0(buf$0)(match_props$1.get("alt"));
        buf$0.contents += "\">\n      ";
      }
      buf$0.contents += "<h2 class=\"p-name\"> ";
      buffer_add_escape$0(buf$0)(match_props$0.get("title"));
      buf$0.contents += " </h2>\n      <span class=\"p-author\"> By ";
      let nullable$0 = match_props$0.get("name");
      if (typeof nullable$0 === "number") {
        buffer_add_escape$0(buf$0)("Anonymous");
      } else {
        buffer_add_escape$0(buf$0)(nullable$0[0]);
      }
      buf$0.contents +=
        " </span>\n      <span class=\"dt-published\"> Posted on ";
      buffer_add_escape$0(buf$0)(match_props$0.get("date"));
      buf$0.contents +=
        " </span>\n    </header>\n    <div class=\"e-content\"> ";
      buf$0.contents += match_props$0.get("content");
      buf$0.contents += " </div>\n  </article>\n";
      index$0++;
      cell$0 = cell$0[1];
    }
    buf$0.contents += "\n";
    return (Promise.resolve(buf$0.contents));
  } else {
    return (Promise.reject(new Error(errors$0.contents)));
  }
};
/* THIS FILE WAS GENERATED BY ACUTIS. */
let buffer_add_string$0 =
  (arg$0) => {
    return ((arg$1) => { arg$0.contents = arg$0.contents + arg$1; });
  };
let buffer_add_buffer$0 =
  (arg$0) => {
    return (
      (arg$1) => { arg$0.contents = arg$0.contents + arg$1.contents; }
    );
  };
let buffer_add_escape$0 =
  (arg$0) => {
    return (
      (arg$1) => {
        for (let i$0 = 0; i$0 < arg$1.length; i$0++) {
          let c$0 = arg$1[i$0];
          switch (c$0) {
            case "&": arg$0.contents = arg$0.contents + "&amp;"; break;
            case "\"": arg$0.contents = arg$0.contents + "&quot;"; break;
            case "'": arg$0.contents = arg$0.contents + "&apos;"; break;
            case ">": arg$0.contents = arg$0.contents + "&gt;"; break;
            case "<": arg$0.contents = arg$0.contents + "&lt;"; break;
            case "/": arg$0.contents = arg$0.contents + "&#x2F;"; break;
            case "`": arg$0.contents = arg$0.contents + "&#x60;"; break;
            case "=": arg$0.contents = arg$0.contents + "&#x3D;"; break;
            default: arg$0.contents = arg$0.contents + c$0;
          }
        }
      }
    );
  };
let components$0 = new Map();
export default (arg$0) => {
  let errors$0 = {contents: ""};
  let decode_error$0 =
    (arg$1) => {
      return (
        (arg$2) => {
          return (
            (arg$3) => {
              if (!(errors$0.contents.length === 0)) {
                buffer_add_string$0(errors$0)("\n\n");
              }
              buffer_add_string$0(errors$0)("File \"");
              buffer_add_string$0(errors$0)("printjs_example.acutis");
              buffer_add_string$0(errors$0)(
                "\"\n\
Render error.\n\
The data supplied does not match this template's interface.\n\
"
              );
              buffer_add_string$0(errors$0)("Path:\n");
              buffer_add_string$0(errors$0)(arg$1[0]);
              let stack$0 = arg$1[1];
              while (!(stack$0 === 0)) {
                buffer_add_string$0(errors$0)(" <- ");
                buffer_add_string$0(errors$0)(stack$0[0]);
                stack$0 = stack$0[1];
              }
              buffer_add_string$0(errors$0)("\nExpected type:\n");
              buffer_add_string$0(errors$0)(arg$2);
              buffer_add_string$0(errors$0)("\nReceived value:\n");
              buffer_add_string$0(errors$0)(String(arg$3));
            }
          );
        }
      );
    };
  let key_error$0 =
    (arg$1) => {
      return (
        (arg$2) => {
          return (
            (arg$3) => {
              if (!(errors$0.contents.length === 0)) {
                buffer_add_string$0(errors$0)("\n\n");
              }
              buffer_add_string$0(errors$0)("File: ");
              buffer_add_string$0(errors$0)("printjs_example.acutis");
              buffer_add_string$0(errors$0)(
                "\n\
Render error.\n\
The data supplied does not match this template's interface.\n\
"
              );
              buffer_add_string$0(errors$0)("Path:\n");
              buffer_add_string$0(errors$0)(arg$1[0]);
              let stack$0 = arg$1[1];
              while (!(stack$0 === 0)) {
                buffer_add_string$0(errors$0)(" <- ");
                buffer_add_string$0(errors$0)(stack$0[0]);
                stack$0 = stack$0[1];
              }
              buffer_add_string$0(errors$0)("\nExpected type:\n");
              buffer_add_string$0(errors$0)(arg$2);
              buffer_add_string$0(errors$0)("\nInput is missing keys:\n");
              buffer_add_string$0(errors$0)(arg$3[0]);
              let stack$1 = arg$3[1];
              while (!(stack$1 === 0)) {
                buffer_add_string$0(errors$0)(", ");
                buffer_add_string$0(errors$0)(stack$1[0]);
                stack$1 = stack$1[1];
              }
            }
          );
        }
      );
    };
  let props$0 = new Map();
  let stack$0 = ["<input>", 0];
  let type$0 =
    "{\n\
  blogPosts:\n\
    [\n\
      {\n\
        author: {name: ?string},\n\
        content: string,\n\
        date: string,\n\
        image: ?{alt: string, src: string},\n\
        title: string\n\
      }\n\
    ],\n\
  siteTitle: string\n\
}";
  if (typeof arg$0 === "object" && !(arg$0 === null)) {
    let missing_keys$0 = 0;
    if (Object.hasOwn(arg$0, "blogPosts")) {
      let input$0 = arg$0["blogPosts"];
      let stack$1 = ["blogPosts", stack$0];
      let type$1 =
        "[\n\
  {\n\
    author: {name: ?string},\n\
    content: string,\n\
    date: string,\n\
    image: ?{alt: string, src: string},\n\
    title: string\n\
  }\n\
]";
      if (Array.isArray(input$0)) {
        let decoded$0 = [0, 0];
        let decode_dst$0 = decoded$0;
        for (let i$0 = 0; i$0 < input$0.length; i$0++) {
          let decode_dst_new$0 = [0, 0];
          let stack$2 = [String(i$0), stack$1];
          let type$2 =
            "{\n\
  author: {name: ?string},\n\
  content: string,\n\
  date: string,\n\
  image: ?{alt: string, src: string},\n\
  title: string\n\
}";
          if (typeof input$0[i$0] === "object" && !(input$0[i$0] === null)) {
            let decoded$1 = new Map();
            let missing_keys$1 = 0;
            if (Object.hasOwn(input$0[i$0], "author")) {
              let input$1 = input$0[i$0]["author"];
              let stack$3 = ["author", stack$2];
              let type$3 = "{name: ?string}";
              if (typeof input$1 === "object" && !(input$1 === null)) {
                let decoded$2 = new Map();
                let missing_keys$2 = 0;
                if (Object.hasOwn(input$1, "name")) {
                  let input$2 = input$1["name"];
                  let stack$4 = ["name", stack$3];
                  let type$4 = "?string";
                  if (!(input$2 === null) && !(input$2 === undefined)) {
                    let decoded$3 = [0];
                    let stack$5 = ["<nullable>", stack$4];
                    let type$5 = "string";
                    if (typeof input$2 === "string") {
                      decoded$3[0] = input$2;
                    } else {
                      decode_error$0(stack$5)(type$5)(input$2);
                    }
                    decoded$2.set("name", decoded$3);
                  } else {
                    decoded$2.set("name", 0);
                  }
                } else {
                  decoded$2.set("name", 0);
                }
                if (!(missing_keys$2 === 0)) {
                  key_error$0(stack$3)(type$3)(missing_keys$2);
                }
                decoded$1.set("author", decoded$2);
              } else {
                decode_error$0(stack$3)(type$3)(input$1);
              }
            } else {
              missing_keys$1 = ["author", missing_keys$1];
            }
            if (Object.hasOwn(input$0[i$0], "content")) {
              let input$1 = input$0[i$0]["content"];
              let stack$3 = ["content", stack$2];
              let type$3 = "string";
              if (typeof input$1 === "string") {
                decoded$1.set("content", input$1);
              } else {
                decode_error$0(stack$3)(type$3)(input$1);
              }
            } else {
              missing_keys$1 = ["content", missing_keys$1];
            }
            if (Object.hasOwn(input$0[i$0], "date")) {
              let input$1 = input$0[i$0]["date"];
              let stack$3 = ["date", stack$2];
              let type$3 = "string";
              if (typeof input$1 === "string") {
                decoded$1.set("date", input$1);
              } else {
                decode_error$0(stack$3)(type$3)(input$1);
              }
            } else {
              missing_keys$1 = ["date", missing_keys$1];
            }
            if (Object.hasOwn(input$0[i$0], "image")) {
              let input$1 = input$0[i$0]["image"];
              let stack$3 = ["image", stack$2];
              let type$3 = "?{alt: string, src: string}";
              if (!(input$1 === null) && !(input$1 === undefined)) {
                let decoded$2 = [0];
                let stack$4 = ["<nullable>", stack$3];
                let type$4 = "{alt: string, src: string}";
                if (typeof input$1 === "object" && !(input$1 === null)) {
                  let decoded$3 = new Map();
                  let missing_keys$2 = 0;
                  if (Object.hasOwn(input$1, "alt")) {
                    let input$2 = input$1["alt"];
                    let stack$5 = ["alt", stack$4];
                    let type$5 = "string";
                    if (typeof input$2 === "string") {
                      decoded$3.set("alt", input$2);
                    } else {
                      decode_error$0(stack$5)(type$5)(input$2);
                    }
                  } else {
                    missing_keys$2 = ["alt", missing_keys$2];
                  }
                  if (Object.hasOwn(input$1, "src")) {
                    let input$2 = input$1["src"];
                    let stack$5 = ["src", stack$4];
                    let type$5 = "string";
                    if (typeof input$2 === "string") {
                      decoded$3.set("src", input$2);
                    } else {
                      decode_error$0(stack$5)(type$5)(input$2);
                    }
                  } else {
                    missing_keys$2 = ["src", missing_keys$2];
                  }
                  if (!(missing_keys$2 === 0)) {
                    key_error$0(stack$4)(type$4)(missing_keys$2);
                  }
                  decoded$2[0] = decoded$3;
                } else {
                  decode_error$0(stack$4)(type$4)(input$1);
                }
                decoded$1.set("image", decoded$2);
              } else {
                decoded$1.set("image", 0);
              }
            } else {
              decoded$1.set("image", 0);
            }
            if (Object.hasOwn(input$0[i$0], "title")) {
              let input$1 = input$0[i$0]["title"];
              let stack$3 = ["title", stack$2];
              let type$3 = "string";
              if (typeof input$1 === "string") {
                decoded$1.set("title", input$1);
              } else {
                decode_error$0(stack$3)(type$3)(input$1);
              }
            } else {
              missing_keys$1 = ["title", missing_keys$1];
            }
            if (!(missing_keys$1 === 0)) {
              key_error$0(stack$2)(type$2)(missing_keys$1);
            }
            decode_dst_new$0[0] = decoded$1;
          } else {
            decode_error$0(stack$2)(type$2)(input$0[i$0]);
          }
          decode_dst$0[1] = decode_dst_new$0;
          decode_dst$0 = decode_dst_new$0;
        }
        props$0.set("blogPosts", decoded$0[1]);
      } else {
        decode_error$0(stack$1)(type$1)(input$0);
      }
    } else {
      missing_keys$0 = ["blogPosts", missing_keys$0];
    }
    if (Object.hasOwn(arg$0, "siteTitle")) {
      let input$0 = arg$0["siteTitle"];
      let stack$1 = ["siteTitle", stack$0];
      let type$1 = "string";
      if (typeof input$0 === "string") {
        props$0.set("siteTitle", input$0);
      } else {
        decode_error$0(stack$1)(type$1)(input$0);
      }
    } else {
      missing_keys$0 = ["siteTitle", missing_keys$0];
    }
    if (!(missing_keys$0 === 0)) {
      key_error$0(stack$0)(type$0)(missing_keys$0);
    }
  } else {
    decode_error$0(stack$0)(type$0)(arg$0);
  }
  if (errors$0.contents.length === 0) {
    let buf_sync$0 = {contents: ""};
    let buf_async$0 = Promise.resolve({contents: ""});
    buffer_add_string$0(buf_sync$0)("<h1> Blog posts for ");
    buffer_add_escape$0(buf_sync$0)(props$0.get("siteTitle"));
    buffer_add_string$0(buf_sync$0)(" </h1>");
    let index$0 = 0;
    let cell$0 = props$0.get("blogPosts");
    while (!(cell$0 === 0)) {
      let match_props$0 = new Map();
      let head$0 = cell$0[0];
      let exit$0 = -1;
      let match_arg$0 = head$0.get("author");
      let match_arg$1 = match_arg$0.get("name");
      let match_arg$2 = head$0.get("content");
      let match_arg$3 = head$0.get("date");
      let match_arg$4 = head$0.get("image");
      let match_arg$5 = head$0.get("title");
      match_props$0.set("content", match_arg$2);
      match_props$0.set("date", match_arg$3);
      match_props$0.set("image", match_arg$4);
      match_props$0.set("name", match_arg$1);
      match_props$0.set("title", match_arg$5);
      exit$0 = 0;
      buffer_add_string$0(buf_sync$0)(
        "\n  <article class=\"h-entry\">\n    <header>\n      "
      );
      let arg_match$0 = [match_props$0.get("image")];
      let match_props$1 = new Map();
      let exit$1 = -1;
      let match_arg$6 = arg_match$0[0];
      if (match_arg$6 === 0) {
        exit$1 = 0;
      } else {
        let match_arg$7 = arg_match$0[0];
        let match_arg$8 = match_arg$7[0];
        let match_arg$9 = match_arg$8.get("alt");
        let match_arg$10 = match_arg$8.get("src");
        match_props$1.set("alt", match_arg$9);
        match_props$1.set("src", match_arg$10);
        exit$1 = 1;
      }
      if (!(exit$1 === 0)) {
        buffer_add_string$0(buf_sync$0)("<img src=\"");
        buffer_add_escape$0(buf_sync$0)(match_props$1.get("src"));
        buffer_add_string$0(buf_sync$0)("\" alt=\"");
        buffer_add_escape$0(buf_sync$0)(match_props$1.get("alt"));
        buffer_add_string$0(buf_sync$0)("\">\n      ");
      }
      buffer_add_string$0(buf_sync$0)("<h2 class=\"p-name\"> ");
      buffer_add_escape$0(buf_sync$0)(match_props$0.get("title"));
      buffer_add_string$0(buf_sync$0)(
        " </h2>\n      <span class=\"p-author\"> By "
      );
      let nullable$0 = match_props$0.get("name");
      if (!(nullable$0 === 0)) {
        buffer_add_escape$0(buf_sync$0)(nullable$0[0]);
      } else {
        buffer_add_escape$0(buf_sync$0)("Anonymous");
      }
      buffer_add_string$0(buf_sync$0)(
        " </span>\n      <span class=\"dt-published\"> Posted on "
      );
      buffer_add_escape$0(buf_sync$0)(match_props$0.get("date"));
      buffer_add_string$0(buf_sync$0)(
        " </span>\n    </header>\n    <div class=\"e-content\"> "
      );
      buffer_add_string$0(buf_sync$0)(match_props$0.get("content"));
      buffer_add_string$0(buf_sync$0)(" </div>\n  </article>\n");
      index$0++;
      cell$0 = cell$0[1];
    }
    buffer_add_string$0(buf_sync$0)("\n");
    return (
      buf_async$0.then(
        (arg$1) => {
          buffer_add_buffer$0(arg$1)(buf_sync$0);
          return (Promise.resolve(arg$1.contents));
        }
      )
    );
  } else {
    return (Promise.reject(new Error(errors$0.contents)));
  }
};
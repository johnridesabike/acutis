  $ acutis \
  >   --mode js \
  >   template.acutis \
  >   component.acutis \
  >   unused.acutis \
  >   --fun ./jscomponents.mjs stringify "$(cat stringify_interface)" \
  >   --fun ./jscomponents.mjs another_function "" \
  >   --fun ./jscomponents.mjs an_unused_function "" \
  >   > compiled.mjs

  $ cat compiled.mjs
  /* THIS FILE WAS GENERATED BY ACUTIS. */
  
  import * as External_jscomponents from "./jscomponents.mjs";
  
  function decode_error(expected, recieved, debug_stack) {
    throw new Error([
      "Decode error in field: ",
      debug_stack.join(" -> "),
      "\nExpected type:\n",
      expected,
      "\nRecieved value:\n",
      recieved,
    ].join(""));
  }
  
  function decode_error_field(field, debug_stack) {
    throw new Error([
      "Decode error.\nAn object is missing the field: ",
      field,
      "\nIn field: ",
      debug_stack.join(" -> "),
    ].join(""));
  }
  
  function acutis_escape(str) {
    let result = "";
    for (let index = 0; index < str.length; index++) {
      let c = str[index];
      switch (c) {
        case "&": result += "&amp;"; break;
        case "\"": result += "&quot;"; break;
        case "'": result += "&apos;"; break;
        case ">": result += "&gt;"; break;
        case "<": result += "&lt;"; break;
        case "/": result += "&#x2F;"; break;
        case "`": result += "&#x60;"; break;
        case "=": result += "&#x3D;"; break;
        default: result += c;
      }
    }
    return result;
  }
  
  async function template_Stringify(input1) {
    let data = new Object();
    let input2 = input1.get("int_list");
    let array1 = new Array();
    data.int_list = array1;
    while (input2) {
      let input3 = input2[0];
      array1.push(input3);
      input2 = input2[1];
    }
    let input4 = input1.get("nested_list");
    let array2 = new Array();
    data.nested_list = array2;
    while (input4) {
      let input5 = input4[0];
      let array3 = new Array();
      array2.push(array3);
      while (input5) {
        let input6 = input5[0];
        let array4 = new Array();
        array3.push(array4);
        while (input6) {
          let input7 = input6[0];
          array4.push(input7);
          input6 = input6[1];
        }
        input5 = input5[1];
      }
      input4 = input4[1];
    }
    let input8 = input1.get("nested_nullable_list");
    let array5 = new Array();
    data.nested_nullable_list = array5;
    while (input8) {
      let input9 = input8[0];
      if (input9) {
        let input10 = input9[0];
        if (input10) {
          let input11 = input10[0];
          if (input11) { array5.push(true); } else { array5.push(false); }
        } else {
          array5.push(null);
        }
      } else {
        array5.push(null);
      }
      input8 = input8[1];
    }
    let input12 = input1.get("null_string_dict");
    let dict1 = new Object();
    data.null_string_dict = dict1;
    for (let entry of input12) {
      if (entry[1]) {
        let input13 = entry[1][0];
        dict1[entry[0]] = input13;
      } else {
        dict1[entry[0]] = null;
      }
    }
    let input14 = input1.get("record");
    let record1 = new Object();
    data.record = record1;
    let input15 = input14.get("int_enum");
    record1.int_enum = input15;
    let input16 = input14.get("string_enum");
    record1.string_enum = input16;
    let input17 = input1.get("tagged_record_bool");
    let union1 = new Object();
    data.tagged_record_bool = union1;
    let input18 = input17.get("tag");
    switch (input18) {
      case 0:
        union1.tag = false;
        let input26 = input17.get("a");
        union1.a = input26;
        break;
      case 1:
        union1.tag = true;
        let input27 = input17.get("b");
        union1.b = input27;
        break;
      default: union1.tag = input18;
    }
    let input19 = input1.get("tagged_record_int");
    let union2 = new Object();
    data.tagged_record_int = union2;
    let input20 = input19.get("tag");
    switch (input20) {
      case 0: union2.tag = 0; break;
      case 1:
        union2.tag = 1;
        let input28 = input19.get("tuple");
        let array6 = new Array(3);
        union2.tuple = array6;
        let input29 = input28[0];
        array6[0] = input29;
        let input30 = input28[1];
        array6[1] = input30;
        let input31 = input28[2];
        if (input31) { array6[2] = true; } else { array6[2] = false; }
        break;
      default: union2.tag = input20;
    }
    let input21 = input1.get("tagged_record_open");
    let union3 = new Object();
    data.tagged_record_open = union3;
    let input22 = input21.get("tag");
    switch (input22) {
      case 100:
        union3.tag = 100;
        let input32 = input21.get("a");
        union3.a = input32;
        break;
      case 200:
        union3.tag = 200;
        let input33 = input21.get("b");
        union3.b = input33;
        break;
      case 300:
        union3.tag = 300;
        let input34 = input21.get("c");
        union3.c = input34;
        break;
      default: union3.tag = input22;
    }
    let input23 = input1.get("tagged_record_string");
    let union4 = new Object();
    data.tagged_record_string = union4;
    let input24 = input23.get("tag");
    switch (input24) {
      case "a":
        union4.tag = "a";
        let input35 = input23.get("record_list");
        let array7 = new Array();
        union4.record_list = array7;
        while (input35) {
          let input36 = input35[0];
          let record2 = new Object();
          array7.push(record2);
          let input37 = input36.get("job");
          record2.job = input37;
          let input38 = input36.get("name");
          record2.name = input38;
          input35 = input35[1];
        }
        break;
      case "b":
        union4.tag = "b";
        let input39 = input23.get("open_enum");
        union4.open_enum = input39;
        break;
      default: union4.tag = input24;
    }
    let input25 = input1.get("unknown");
    data.unknown = input25;
    return External_jscomponents.stringify(data);
  }
  
  async function template_Another_function(input1) {
    let data = new Object();
    return External_jscomponents.another_function(data);
  }
  
  async function template_Component(data) {
    return (await Promise.all([
      acutis_escape(
        data.get("optional")
          ? data.get("optional")[0].toString()
          : data.get("children")
      ),
      "\n",
      (async function () {
        let result = new Array();
        let index = 0;
        let arg0 = data.get("list");
        while (arg0) {
          let data1 = new Map(data);
          let exit = -1;
          exit = 0;
          data1.set("i", arg0[0]);
          result.push(acutis_escape(data1.get("i").toString()));
          index++;
          arg0 = arg0[1];
        }
        return (await Promise.all(result)).join("");
      })(),
    ])).join("");
  }
  
  export default async function main(input1) {
    let data = new Map();
    let debug_stack = new Array();
    debug_stack.push("<input>");
    if ("big_float" in input1) {
      debug_stack.push("big_float");
      let input2 = input1.big_float;
      if (typeof input2 === "number") {
        data.set("big_float", input2);
      } else {
        return decode_error("float", input2, debug_stack);
      }
      debug_stack.pop();
    } else {
      return decode_error_field("big_float", debug_stack);
    }
    if ("big_int" in input1) {
      debug_stack.push("big_int");
      let input3 = input1.big_int;
      if (typeof input3 === "number") {
        data.set("big_int", input3 | 0);
      } else {
        return decode_error("int", input3, debug_stack);
      }
      debug_stack.pop();
    } else {
      return decode_error_field("big_int", debug_stack);
    }
    if ("bool1" in input1) {
      debug_stack.push("bool1");
      let input4 = input1.bool1;
      switch (input4) {
        case false: data.set("bool1", 0); break;
        case true: data.set("bool1", 1); break;
        default: return decode_error("false | true", input4, debug_stack);
      }
      debug_stack.pop();
    } else {
      return decode_error_field("bool1", debug_stack);
    }
    if ("bool2" in input1) {
      debug_stack.push("bool2");
      let input5 = input1.bool2;
      switch (input5) {
        case false: data.set("bool2", 0); break;
        case true: data.set("bool2", 1); break;
        default: return decode_error("false | true", input5, debug_stack);
      }
      debug_stack.pop();
    } else {
      return decode_error_field("bool2", debug_stack);
    }
    if ("dangerous" in input1) {
      debug_stack.push("dangerous");
      let input6 = input1.dangerous;
      if (typeof input6 === "string") {
        data.set("dangerous", input6);
      } else {
        return decode_error("string", input6, debug_stack);
      }
      debug_stack.pop();
    } else {
      return decode_error_field("dangerous", debug_stack);
    }
    if ("int_list" in input1) {
      debug_stack.push("int_list");
      let input7 = input1.int_list;
      if (input7 instanceof Array) {
        let dst_base1 = new Array(2);
        let dst1 = dst_base1;
        for (let index = 0; index < input7.length; index++) {
          let input_hd1 = input7[index];
          debug_stack.push(index);
          let dst_new1 = new Array(2);
          if (typeof input_hd1 === "number") {
            dst_new1[0] = input_hd1 | 0;
          } else {
            return decode_error("int", input_hd1, debug_stack);
          }
          dst1[1] = dst_new1;
          dst1 = dst_new1;
          debug_stack.pop();
        }
        dst1[1] = 0;
        data.set("int_list", dst_base1[1]);
      } else {
        return decode_error("[int]", input7, debug_stack);
      }
      debug_stack.pop();
    } else {
      return decode_error_field("int_list", debug_stack);
    }
    if ("nested_list" in input1) {
      debug_stack.push("nested_list");
      let input8 = input1.nested_list;
      if (input8 instanceof Array) {
        let dst_base2 = new Array(2);
        let dst2 = dst_base2;
        for (let index = 0; index < input8.length; index++) {
          let input_hd2 = input8[index];
          debug_stack.push(index);
          let dst_new2 = new Array(2);
          if (input_hd2 instanceof Array) {
            let dst_base3 = new Array(2);
            let dst3 = dst_base3;
            for (let index = 0; index < input_hd2.length; index++) {
              let input_hd3 = input_hd2[index];
              debug_stack.push(index);
              let dst_new3 = new Array(2);
              if (input_hd3 instanceof Array) {
                let dst_base4 = new Array(2);
                let dst4 = dst_base4;
                for (let index = 0; index < input_hd3.length; index++) {
                  let input_hd4 = input_hd3[index];
                  debug_stack.push(index);
                  let dst_new4 = new Array(2);
                  if (typeof input_hd4 === "number") {
                    dst_new4[0] = input_hd4 | 0;
                  } else {
                    return decode_error("int", input_hd4, debug_stack);
                  }
                  dst4[1] = dst_new4;
                  dst4 = dst_new4;
                  debug_stack.pop();
                }
                dst4[1] = 0;
                dst_new3[0] = dst_base4[1];
              } else {
                return decode_error("[int]", input_hd3, debug_stack);
              }
              dst3[1] = dst_new3;
              dst3 = dst_new3;
              debug_stack.pop();
            }
            dst3[1] = 0;
            dst_new2[0] = dst_base3[1];
          } else {
            return decode_error("[[int]]", input_hd2, debug_stack);
          }
          dst2[1] = dst_new2;
          dst2 = dst_new2;
          debug_stack.pop();
        }
        dst2[1] = 0;
        data.set("nested_list", dst_base2[1]);
      } else {
        return decode_error("[[[int]]]", input8, debug_stack);
      }
      debug_stack.pop();
    } else {
      return decode_error_field("nested_list", debug_stack);
    }
    if ("nested_nullable_list" in input1) {
      debug_stack.push("nested_nullable_list");
      let input9 = input1.nested_nullable_list;
      if (input9 instanceof Array) {
        let dst_base5 = new Array(2);
        let dst5 = dst_base5;
        for (let index = 0; index < input9.length; index++) {
          let input_hd5 = input9[index];
          debug_stack.push(index);
          let dst_new5 = new Array(2);
          if (input_hd5 === null || input_hd5 === undefined) {
            dst_new5[0] = 0;
          } else {
            let nullable1 = new Array(1);
            dst_new5[0] = nullable1;
            if (input_hd5 === null || input_hd5 === undefined) {
              nullable1[0] = 0;
            } else {
              let nullable2 = new Array(1);
              nullable1[0] = nullable2;
              switch (input_hd5) {
                case false: nullable2[0] = 0; break;
                case true: nullable2[0] = 1; break;
                default:
                  return decode_error("false | true", input_hd5, debug_stack);
              }
            }
          }
          dst5[1] = dst_new5;
          dst5 = dst_new5;
          debug_stack.pop();
        }
        dst5[1] = 0;
        data.set("nested_nullable_list", dst_base5[1]);
      } else {
        return decode_error("[??false | true]", input9, debug_stack);
      }
      debug_stack.pop();
    } else {
      return decode_error_field("nested_nullable_list", debug_stack);
    }
    if ("null_bool" in input1) {
      debug_stack.push("null_bool");
      let input10 = input1.null_bool;
      if (input10 === null || input10 === undefined) {
        data.set("null_bool", 0);
      } else {
        let nullable3 = new Array(1);
        data.set("null_bool", nullable3);
        switch (input10) {
          case false: nullable3[0] = 0; break;
          case true: nullable3[0] = 1; break;
          default: return decode_error("false | true", input10, debug_stack);
        }
      }
      debug_stack.pop();
    } else {
      data.set("null_bool", 0);
    }
    if ("null_float" in input1) {
      debug_stack.push("null_float");
      let input11 = input1.null_float;
      if (input11 === null || input11 === undefined) {
        data.set("null_float", 0);
      } else {
        let nullable4 = new Array(1);
        data.set("null_float", nullable4);
        if (typeof input11 === "number") {
          nullable4[0] = input11;
        } else {
          return decode_error("float", input11, debug_stack);
        }
      }
      debug_stack.pop();
    } else {
      data.set("null_float", 0);
    }
    if ("null_int" in input1) {
      debug_stack.push("null_int");
      let input12 = input1.null_int;
      if (input12 === null || input12 === undefined) {
        data.set("null_int", 0);
      } else {
        let nullable5 = new Array(1);
        data.set("null_int", nullable5);
        if (typeof input12 === "number") {
          nullable5[0] = input12 | 0;
        } else {
          return decode_error("int", input12, debug_stack);
        }
      }
      debug_stack.pop();
    } else {
      data.set("null_int", 0);
    }
    if ("null_string" in input1) {
      debug_stack.push("null_string");
      let input13 = input1.null_string;
      if (input13 === null || input13 === undefined) {
        data.set("null_string", 0);
      } else {
        let nullable6 = new Array(1);
        data.set("null_string", nullable6);
        if (typeof input13 === "string") {
          nullable6[0] = input13;
        } else {
          return decode_error("string", input13, debug_stack);
        }
      }
      debug_stack.pop();
    } else {
      data.set("null_string", 0);
    }
    if ("null_string_dict" in input1) {
      debug_stack.push("null_string_dict");
      let input14 = input1.null_string_dict;
      let dict1 = new Map();
      data.set("null_string_dict", dict1);
      for (let key1 in input14) {
        debug_stack.push(key1);
        let input15 = input14[key1];
        if (input15 === null || input15 === undefined) {
          dict1.set(key1, 0);
        } else {
          let nullable7 = new Array(1);
          dict1.set(key1, nullable7);
          if (typeof input15 === "string") {
            nullable7[0] = input15;
          } else {
            return decode_error("string", input15, debug_stack);
          }
        }
        debug_stack.pop();
      }
      debug_stack.pop();
    } else {
      return decode_error_field("null_string_dict", debug_stack);
    }
    if ("record" in input1) {
      debug_stack.push("record");
      let input16 = input1.record;
      let record1 = new Map();
      data.set("record", record1);
      if ("int_enum" in input16) {
        debug_stack.push("int_enum");
        let input17 = input16.int_enum;
        switch (input17) {
          case 8: record1.set("int_enum", 8); break;
          case 40: record1.set("int_enum", 40); break;
          default: return decode_error("@8 | @40", input17, debug_stack);
        }
        debug_stack.pop();
      } else {
        return decode_error_field("int_enum", debug_stack);
      }
      if ("string_enum" in input16) {
        debug_stack.push("string_enum");
        let input18 = input16.string_enum;
        switch (input18) {
          case "no": record1.set("string_enum", "no"); break;
          case "yes": record1.set("string_enum", "yes"); break;
          default:
            return decode_error("@\"no\" | @\"yes\"", input18, debug_stack);
        }
        debug_stack.pop();
      } else {
        return decode_error_field("string_enum", debug_stack);
      }
      debug_stack.pop();
    } else {
      return decode_error_field("record", debug_stack);
    }
    if ("tagged_record_bool" in input1) {
      debug_stack.push("tagged_record_bool");
      let input19 = input1.tagged_record_bool;
      let union1 = new Map();
      data.set("tagged_record_bool", union1);
      let input20 = input19.tag;
      switch (input20) {
        case false:
          union1.set("tag", 0);
          if ("a" in input19) {
            debug_stack.push("a");
            let input29 = input19.a;
            if (typeof input29 === "string") {
              union1.set("a", input29);
            } else {
              return decode_error("string", input29, debug_stack);
            }
            debug_stack.pop();
          } else {
            return decode_error_field("a", debug_stack);
          }
          break;
        case true:
          union1.set("tag", 1);
          if ("b" in input19) {
            debug_stack.push("b");
            let input30 = input19.b;
            if (typeof input30 === "number") {
              union1.set("b", input30 | 0);
            } else {
              return decode_error("int", input30, debug_stack);
            }
            debug_stack.pop();
          } else {
            return decode_error_field("b", debug_stack);
          }
          break;
        default:
          return decode_error(
            "{@tag: false, a: string} | {@tag: true, b: int}",
            input19,
            debug_stack
          );
      }
      debug_stack.pop();
    } else {
      return decode_error_field("tagged_record_bool", debug_stack);
    }
    if ("tagged_record_int" in input1) {
      debug_stack.push("tagged_record_int");
      let input21 = input1.tagged_record_int;
      let union2 = new Map();
      data.set("tagged_record_int", union2);
      let input22 = input21.tag;
      switch (input22) {
        case 0: union2.set("tag", 0); break;
        case 1:
          union2.set("tag", 1);
          if ("tuple" in input21) {
            debug_stack.push("tuple");
            let input31 = input21.tuple;
            if (input31 instanceof Array && input31.length === 3) {
              let tuple1 = new Array(3);
              union2.set("tuple", tuple1);
              debug_stack.push(0);
              let input32 = input31[0];
              if (typeof input32 === "number") {
                tuple1[0] = input32;
              } else {
                return decode_error("float", input32, debug_stack);
              }
              debug_stack.pop();
              debug_stack.push(1);
              let input33 = input31[1];
              if (typeof input33 === "string") {
                tuple1[1] = input33;
              } else {
                return decode_error("string", input33, debug_stack);
              }
              debug_stack.pop();
              debug_stack.push(2);
              let input34 = input31[2];
              switch (input34) {
                case false: tuple1[2] = 0; break;
                case true: tuple1[2] = 1; break;
                default:
                  return decode_error("false | true", input34, debug_stack);
              }
              debug_stack.pop();
            } else {
              return decode_error(
                "(float, string, false | true)",
                input31,
                debug_stack
              );
            }
            debug_stack.pop();
          } else {
            return decode_error_field("tuple", debug_stack);
          }
          break;
        default:
          return decode_error(
            "{@tag: 0} | {@tag: 1, tuple: (float, string, false | true)}",
            input21,
            debug_stack
          );
      }
      debug_stack.pop();
    } else {
      return decode_error_field("tagged_record_int", debug_stack);
    }
    if ("tagged_record_open" in input1) {
      debug_stack.push("tagged_record_open");
      let input23 = input1.tagged_record_open;
      let union3 = new Map();
      data.set("tagged_record_open", union3);
      let input24 = input23.tag;
      switch (input24) {
        case 100:
          union3.set("tag", 100);
          if ("a" in input23) {
            debug_stack.push("a");
            let input35 = input23.a;
            if (typeof input35 === "number") {
              union3.set("a", input35 | 0);
            } else {
              return decode_error("int", input35, debug_stack);
            }
            debug_stack.pop();
          } else {
            return decode_error_field("a", debug_stack);
          }
          break;
        case 200:
          union3.set("tag", 200);
          if ("b" in input23) {
            debug_stack.push("b");
            let input36 = input23.b;
            if (typeof input36 === "string") {
              union3.set("b", input36);
            } else {
              return decode_error("string", input36, debug_stack);
            }
            debug_stack.pop();
          } else {
            return decode_error_field("b", debug_stack);
          }
          break;
        case 300:
          union3.set("tag", 300);
          if ("c" in input23) {
            debug_stack.push("c");
            let input37 = input23.c;
            if (typeof input37 === "number") {
              union3.set("c", input37);
            } else {
              return decode_error("float", input37, debug_stack);
            }
            debug_stack.pop();
          } else {
            return decode_error_field("c", debug_stack);
          }
          break;
        default:
          if (typeof input24 === "number") {
            union3.set("tag", input24 | 0);
          } else {
            return decode_error("int", input24, debug_stack);
          }
      }
      debug_stack.pop();
    } else {
      return decode_error_field("tagged_record_open", debug_stack);
    }
    if ("tagged_record_string" in input1) {
      debug_stack.push("tagged_record_string");
      let input25 = input1.tagged_record_string;
      let union4 = new Map();
      data.set("tagged_record_string", union4);
      let input26 = input25.tag;
      switch (input26) {
        case "a":
          union4.set("tag", "a");
          if ("record_list" in input25) {
            debug_stack.push("record_list");
            let input38 = input25.record_list;
            if (input38 instanceof Array) {
              let dst_base6 = new Array(2);
              let dst6 = dst_base6;
              for (let index = 0; index < input38.length; index++) {
                let input_hd6 = input38[index];
                debug_stack.push(index);
                let dst_new6 = new Array(2);
                let record2 = new Map();
                dst_new6[0] = record2;
                if ("job" in input_hd6) {
                  debug_stack.push("job");
                  let input39 = input_hd6.job;
                  if (typeof input39 === "string") {
                    record2.set("job", input39);
                  } else {
                    return decode_error("string", input39, debug_stack);
                  }
                  debug_stack.pop();
                } else {
                  return decode_error_field("job", debug_stack);
                }
                if ("name" in input_hd6) {
                  debug_stack.push("name");
                  let input40 = input_hd6.name;
                  if (typeof input40 === "string") {
                    record2.set("name", input40);
                  } else {
                    return decode_error("string", input40, debug_stack);
                  }
                  debug_stack.pop();
                } else {
                  return decode_error_field("name", debug_stack);
                }
                dst6[1] = dst_new6;
                dst6 = dst_new6;
                debug_stack.pop();
              }
              dst6[1] = 0;
              union4.set("record_list", dst_base6[1]);
            } else {
              return decode_error(
                "[{job: string, name: string}]",
                input38,
                debug_stack
              );
            }
            debug_stack.pop();
          } else {
            return decode_error_field("record_list", debug_stack);
          }
          break;
        case "b":
          union4.set("tag", "b");
          if ("open_enum" in input25) {
            debug_stack.push("open_enum");
            let input41 = input25.open_enum;
            if (typeof input41 === "number") {
              union4.set("open_enum", input41 | 0);
            } else {
              return decode_error("@0 | @1 | ...", input41, debug_stack);
            }
            debug_stack.pop();
          } else {
            return decode_error_field("open_enum", debug_stack);
          }
          break;
        default:
          return decode_error(
            "{@tag: \"a\", record_list: [{job: string, name: string}]} |\n\
  {@tag: \"b\", open_enum: @0 | @1 | ...}",
            input25,
            debug_stack
          );
      }
      debug_stack.pop();
    } else {
      return decode_error_field("tagged_record_string", debug_stack);
    }
    if ("unicode_string" in input1) {
      debug_stack.push("unicode_string");
      let input27 = input1.unicode_string;
      if (typeof input27 === "string") {
        data.set("unicode_string", input27);
      } else {
        return decode_error("string", input27, debug_stack);
      }
      debug_stack.pop();
    } else {
      return decode_error_field("unicode_string", debug_stack);
    }
    if ("unknown" in input1) {
      debug_stack.push("unknown");
      let input28 = input1.unknown;
      data.set("unknown", input28);
      debug_stack.pop();
    } else {
      data.set("unknown", 0);
    }
    return (await Promise.all([
      "Formatters\n----------\n\n%i    ",
      acutis_escape(data.get("big_int").toString()),
      "\n%f    ",
      acutis_escape(data.get("big_float").toString()),
      "\n%b    ",
      acutis_escape(data.get("bool1") ? "true" : "false"),
      "\n%b    ",
      acutis_escape(data.get("bool2") ? "true" : "false"),
      "\n\nEscaping\n--------\n\nEscaped     ",
      acutis_escape(data.get("dangerous")),
      "\nNot escaped ",
      data.get("dangerous"),
      "\n\nNullable echo chaining\n----------------------\n\n",
      acutis_escape(
        data.get("null_int")
          ? data.get("null_int")[0].toString()
          : data.get("null_float")
              ? data.get("null_float")[0].toString()
              : data.get("null_bool")
                  ? data.get("null_bool")[0] ? "true" : "false"
                  : data.get("null_string")
                      ? data.get("null_string")[0]
                      : "pass"
      ),
      "\n\nMatching\n--------\n\n",
      (async function () {
        let data1 = new Map(data);
        let exit = -1;
        let arg0 = data.get("record").get("int_enum");
        switch (arg0) {
          case 8: exit = 0; break;
          case 40: exit = 1; break;
        }
        switch (exit) {
          case 0: return (await Promise.all(["8\n"])).join("");
          case 1: return (await Promise.all(["40\n"])).join("");
        }
      })(),
      (async function () {
        let data1 = new Map(data);
        let exit = -1;
        let arg0 = data.get("record");
        switch (arg0.get("string_enum")) {
          case "no": exit = 1; break;
          case "yes": exit = 0; break;
        }
        switch (exit) {
          case 0: return (await Promise.all(["yes\n"])).join("");
          case 1: return (await Promise.all(["no\n"])).join("");
        }
      })(),
      (async function () {
        let data1 = new Map(data);
        let exit = -1;
        let arg0 = data.get("tagged_record_bool");
        switch (arg0.get("tag")) {
          case 0: exit = 0; data1.set("a", arg0.get("a")); break;
          case 1: exit = 1; data1.set("b", arg0.get("b")); break;
        }
        switch (exit) {
          case 0:
            return (await Promise.all([
              acutis_escape(data1.get("a")),
              "\n",
            ])).join("");
          case 1:
            return (await Promise.all([
              acutis_escape(data1.get("b").toString()),
              "\n",
            ])).join("");
        }
      })(),
      (async function () {
        let data1 = new Map(data);
        let exit = -1;
        let arg0 = data.get("tagged_record_int");
        switch (arg0.get("tag")) {
          case 0: exit = 0; break;
          case 1:
            exit = 1;
            data1.set("a", arg0.get("tuple")[0]);
            data1.set("b", arg0.get("tuple")[1]);
            data1.set("c", arg0.get("tuple")[2]);
            break;
        }
        switch (exit) {
          case 0: return (await Promise.all(["Fail\n"])).join("");
          case 1:
            return (await Promise.all([
              acutis_escape(data1.get("a").toString()),
              " ",
              acutis_escape(data1.get("b")),
              " ",
              acutis_escape(data1.get("c") ? "true" : "false"),
              "\n",
            ])).join("");
        }
      })(),
      (async function () {
        let data1 = new Map(data);
        let exit = -1;
        let arg0 = data.get("tagged_record_open");
        switch (arg0.get("tag")) {
          case 200: exit = 0; data1.set("b", arg0.get("b")); break;
        }
        if (exit === -1) { exit = 1; }
        switch (exit) {
          case 0:
            return (await Promise.all([
              " ",
              acutis_escape(data1.get("b")),
              "\n",
            ])).join("");
          case 1: return (await Promise.all(["Another tag!\n"])).join("");
        }
      })(),
      "\n\nMapping\n-------\n\n",
      (async function () {
        let result = new Array();
        let arg0 = data.get("null_string_dict");
        for (let entry of arg0) {
          let data1 = new Map(data);
          let exit = -1;
          if (entry[1]) {
            exit = 1;
            data1.set("key", entry[0]);
            data1.set("str", entry[1][0]);
          } else {
            exit = 0;
            data1.set("key", entry[0]);
          }
          switch (exit) {
            case 0:
              result.push(acutis_escape(data1.get("key")), " is null.\n");
              break;
            case 1:
              result.push(
                acutis_escape(data1.get("key")),
                " is ",
                acutis_escape(data1.get("str")),
                "\n"
              );
              break;
          }
        }
        return (await Promise.all(result)).join("");
      })(),
      (async function () {
        let result = new Array();
        let index = 0;
        let arg0 = data.get("int_list");
        while (arg0) {
          let data1 = new Map(data);
          let exit = -1;
          exit = 0;
          data1.set("i", arg0[0]);
          result.push(acutis_escape(data1.get("i").toString()), "\n");
          index++;
          arg0 = arg0[1];
        }
        return (await Promise.all(result)).join("");
      })(),
      (async function () {
        let result = new Array();
        let index = 0;
        let arg0 = data.get("int_list");
        while (arg0) {
          let data1 = new Map(data);
          let exit = -1;
          exit = 0;
          data1.set("i", arg0[0]);
          data1.set("key", index);
          result.push(
            acutis_escape(data1.get("key").toString()),
            " : ",
            acutis_escape(data1.get("i").toString()),
            "\n"
          );
          index++;
          arg0 = arg0[1];
        }
        return (await Promise.all(result)).join("");
      })(),
      (async function () {
        let result = new Array();
        let index = 0;
        let arg0 = data.get("nested_list");
        while (arg0) {
          let data1 = new Map(data);
          let exit = -1;
          exit = 0;
          data1.set("l", arg0[0]);
          result.push(
            (async function () {
              let result = new Array();
              let index = 0;
              let arg0 = data1.get("l");
              while (arg0) {
                let data2 = new Map(data1);
                let exit = -1;
                exit = 0;
                data2.set("l2", arg0[0]);
                result.push(
                  (async function () {
                    let result = new Array();
                    let index = 0;
                    let arg0 = data2.get("l2");
                    while (arg0) {
                      let data3 = new Map(data2);
                      let exit = -1;
                      exit = 0;
                      data3.set("i", arg0[0]);
                      result.push(
                        acutis_escape(data3.get("i").toString()),
                        " "
                      );
                      index++;
                      arg0 = arg0[1];
                    }
                    return (await Promise.all(result)).join("");
                  })()
                );
                index++;
                arg0 = arg0[1];
              }
              return (await Promise.all(result)).join("");
            })()
          );
          index++;
          arg0 = arg0[1];
        }
        return (await Promise.all(result)).join("");
      })(),
      "\n\n",
      (async function () {
        let result = new Array();
        let index = 0;
        let arg0 = data.get("nested_nullable_list");
        while (arg0) {
          let data1 = new Map(data);
          let exit = -1;
          if (arg0[0]) {
            if (arg0[0][0]) {
              exit = 2;
              data1.set("b", arg0[0][0][0]);
            } else {
              exit = 1;
            }
          } else {
            exit = 0;
          }
          switch (exit) {
            case 0: result.push("Level 1 null\n"); break;
            case 1:
              result.push("Level 2 null (This shouldn't render.)\n");
              break;
            case 2:
              result.push(
                "Level 3 ",
                acutis_escape(data1.get("b") ? "true" : "false"),
                "\n"
              );
              break;
          }
          index++;
          arg0 = arg0[1];
        }
        return (await Promise.all(result)).join("");
      })(),
      "\n\
  \n\
  Dictionaries match correctly\n\
  ----------------------------\n\
  \n\
  ",
      (async function () {
        let data1 = new Map(data);
        let exit = -1;
        let arg0 = data.get("null_string_dict");
        if (arg0.has("a")) {
          if (arg0.get("a")) {
            switch (arg0.get("a")[0]) {
              case "a":
                if (arg0.has("does_not_exist")) {
                  if (arg0.get("does_not_exist")) {
                    exit = 0;
                    data1.set("a", arg0.get("a")[0]);
                    data1.set("b", arg0.get("does_not_exist")[0]);
                  }
                }
                if (exit === -1) { exit = 2; }
                break;
              default:
                if (arg0.has("does_not_exist")) {
                  if (arg0.get("does_not_exist")) {
                    exit = 0;
                    data1.set("a", arg0.get("a")[0]);
                    data1.set("b", arg0.get("does_not_exist")[0]);
                  }
                }
            }
          } else {
            if (exit === -1) { exit = 1; }
          }
        }
        if (exit === -1) { exit = 3; }
        switch (exit) {
          case 0:
            return (await Promise.all([
              " ",
              acutis_escape(data1.get("a")),
              " ",
              acutis_escape(data1.get("b")),
              "\n",
            ])).join("");
          case 1: return (await Promise.all([" Fail.\n"])).join("");
          case 2: return (await Promise.all([" Pass.\n"])).join("");
          case 3: return (await Promise.all([" Fail.\n"])).join("");
        }
      })(),
      (async function () {
        let data1 = new Map(data);
        let exit = -1;
        let arg0 = new Map([["a", "a"]]);
        if (arg0.has("a")) {
          switch (arg0.get("a")) {
            case "":
              if (arg0.has("does_not_exist")) {
                exit = 0;
                data1.set("a", arg0.get("a"));
                data1.set("b", arg0.get("does_not_exist"));
              }
              if (exit === -1) { exit = 1; }
              break;
            case "a":
              if (arg0.has("does_not_exist")) {
                exit = 0;
                data1.set("a", arg0.get("a"));
                data1.set("b", arg0.get("does_not_exist"));
              }
              if (exit === -1) { exit = 2; }
              break;
            default:
              if (arg0.has("does_not_exist")) {
                exit = 0;
                data1.set("a", arg0.get("a"));
                data1.set("b", arg0.get("does_not_exist"));
              }
          }
        }
        if (exit === -1) { exit = 3; }
        switch (exit) {
          case 0:
            return (await Promise.all([
              " Fail. ",
              acutis_escape(data1.get("a")),
              " ",
              acutis_escape(data1.get("b")),
              "\n",
            ])).join("");
          case 1: return (await Promise.all([" Fail.\n"])).join("");
          case 2: return (await Promise.all([" Pass.\n"])).join("");
          case 3: return (await Promise.all([" Fail.\n"])).join("");
        }
      })(),
      "\n\nConstructing async blocks\n-------------------------\n\n",
      (async function () {
        let data1 = new Map(data);
        let exit = -1;
        let resolved1 = (await Promise.all([
          " Another nested block",
        ])).join("");
        let resolved0 = (await Promise.all([" Nested block"])).join("");
        let arg0 = new Map([["a", resolved0], ["b", resolved1]]);
        exit = 0;
        data1.set("a", arg0.get("a"));
        data1.set("b", arg0.get("b"));
        return (await Promise.all([
          acutis_escape(data1.get("a")),
          " ",
          acutis_escape(data1.get("b")),
          "\n",
        ])).join("");
      })(),
      "Component\n---------\n\n",
      (async function () {
        let resolved0 = (await Promise.all(["Children prop"])).join("");
        let arg0 = new Map([
          ["children", resolved0],
          ["list", [1, [2, [3, 0]]]],
          ["optional", 0],
        ]);
        return template_Component(arg0);
      })(),
      "\n\n",
      (async function () {
        let arg0 = new Map([]);
        return template_Another_function(arg0);
      })(),
      "\n\
  \n\
  Complicated pattern matching\n\
  ----------------------------\n\
  \n\
  ",
      (async function () {
        let data1 = new Map(data);
        let exit = -1;
        let arg0 = 1;
        let arg1 = 0;
        let arg2 = 3;
        switch (arg0) {
          case 1:
            if (arg1) {
              switch (arg1[0]) {
                case 1:
                  switch (arg2) {
                    case 0: exit = 0; break;
                    case 1: exit = 3; break;
                    default: exit = 4;
                  }
                  break;
              }
              if (exit === -1) {
                switch (arg2) {
                  case 0: exit = 0; break;
                  default: exit = 4;
                }
              }
            } else {
              switch (arg2) {
                case 0: exit = 0; break;
                default: exit = 2; data1.set("y", arg2);
              }
            }
            break;
          default:
            if (arg1) {
              switch (arg1[0]) {
                case 1:
                  switch (arg2) {
                    case 0: exit = 1; data1.set("x", arg0); break;
                    default: exit = 4;
                  }
                  break;
              }
              if (exit === -1) { exit = 4; }
            } else {
              exit = 2;
              data1.set("y", arg2);
            }
        }
        switch (exit) {
          case 0: return (await Promise.all([" 0\n"])).join("");
          case 1:
            return (await Promise.all([
              " 1 ",
              acutis_escape(data1.get("x").toString()),
              "\n",
            ])).join("");
          case 2:
            return (await Promise.all([
              " 2 ",
              acutis_escape(data1.get("y").toString()),
              "\n",
            ])).join("");
          case 3: return (await Promise.all([" 3\n"])).join("");
          case 4: return (await Promise.all([" 4\n"])).join("");
        }
      })(),
      (async function () {
        let data1 = new Map(data);
        let exit = -1;
        let arg0 = [[10, 20], 30];
        let arg1 = 40;
        switch (arg0[0][0]) {
          case 10:
            switch (arg0[0][1]) {
              case 20:
                switch (arg0[1]) {
                  case 30:
                    switch (arg1) {
                      case 40: exit = 1; break;
                      case 41: exit = 0; data1.set("_x", arg0); break;
                      default:
                        exit = 2;
                        data1.set("_y", arg0);
                        data1.set("z", arg1);
                    }
                    break;
                }
                break;
            }
            break;
        }
        if (exit === -1) {
          switch (arg1) {
            case 41: exit = 0; data1.set("_x", arg0); break;
            default: exit = 2; data1.set("_y", arg0); data1.set("z", arg1);
          }
        }
        switch (exit) {
          case 0: return (await Promise.all(["\n"])).join("");
          case 1: return (await Promise.all([" Pass\n"])).join("");
          case 2:
            return (await Promise.all([
              " ",
              acutis_escape(data1.get("z").toString()),
              "\n",
            ])).join("");
        }
      })(),
      (async function () {
        let data1 = new Map(data);
        let exit = -1;
        let arg0 = [[10, 20], 99];
        let arg1 = 40;
        switch (arg0[0][0]) {
          case 10:
            switch (arg0[0][1]) {
              case 20:
                switch (arg0[1]) {
                  case 30:
                    switch (arg1) {
                      case 40: exit = 1; break;
                      case 41: exit = 0; data1.set("_x", arg0); break;
                      default:
                        exit = 2;
                        data1.set("_y", arg0);
                        data1.set("z", arg1);
                    }
                    break;
                }
                break;
            }
            break;
        }
        if (exit === -1) {
          switch (arg1) {
            case 41: exit = 0; data1.set("_x", arg0); break;
            default: exit = 2; data1.set("_y", arg0); data1.set("z", arg1);
          }
        }
        switch (exit) {
          case 0: return (await Promise.all(["\n"])).join("");
          case 1: return (await Promise.all([" Fail\n"])).join("");
          case 2:
            return (await Promise.all([
              " ",
              acutis_escape(data1.get("z").toString()),
              "\n",
            ])).join("");
        }
      })(),
      "String encoding\n\
  ---------------\n\
  \n\
  ğŸ˜‡ğŸ‘¨â€ğŸ’»ğŸ˜‡\n\
  \\\" \\ \\ \\\"\n\
  \n\
  ",
      acutis_escape(data.get("unicode_string")),
      "\n\
  \n\
  External JavaScript template component: stringify arbitrary data\n\
  \n\
  ",
      (async function () {
        let arg0 = new Map([
          ["int_list", data.get("int_list")],
          ["nested_list", data.get("nested_list")],
          ["nested_nullable_list", data.get("nested_nullable_list")],
          ["null_string_dict", data.get("null_string_dict")],
          ["record", data.get("record")],
          ["tagged_record_bool", data.get("tagged_record_bool")],
          ["tagged_record_int", data.get("tagged_record_int")],
          ["tagged_record_open", data.get("tagged_record_open")],
          ["tagged_record_string", data.get("tagged_record_string")],
          ["unknown", data.get("unknown")],
        ]);
        return template_Stringify(arg0);
      })(),
      "\n",
    ])).join("");
  }
  

  $ cat > run.mjs << EOF
  >   import main from "./compiled.mjs";
  >   let result = await main({
  >     big_int: 100_000_000,
  >     big_float: 1234.56789,
  >     bool1: true,
  >     bool2: false,
  >     dangerous: "&\"'></\`=",
  >     record: { int_enum: 8, string_enum: "yes" },
  >     tagged_record_bool: { tag: false, a: "a" },
  >     null_string_dict: { a: "a", b: null },
  >     int_list: [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5],
  >     tagged_record_int: { tag: 1, tuple: [1.5, "snd", true] },
  >     tagged_record_string: {
  >       tag: "a",
  >       record_list: [{ name: "John", job: "librarian" }],
  >     },
  >     tagged_record_open: {
  >       tag: 999,
  >       b: "200",
  >     },
  >     unknown: new Date("2023-04-09T00:00:00.000Z"),
  >     nested_list: [
  >       [
  >         [1, 1, 1],
  >         [2, 2, 2],
  >       ],
  >       [[3, 3, 3]],
  >     ],
  >     nested_nullable_list: [null, true, false, null],
  >     null_int: null,
  >     null_float: null,
  >     null_bool: null,
  >     null_string: null,
  >     unicode_string: "ğŸ‘©â€ğŸŒ¾",
  >   });
  >   process.stdout.write(result);
  > EOF

  $ node run.mjs
  Formatters
  ----------
  
  %i    100000000
  %f    1234.56789
  %b    true
  %b    false
  
  Escaping
  --------
  
  Escaped     &amp;&quot;&apos;&gt;&lt;&#x2F;&#x60;&#x3D;
  Not escaped &"'></`=
  
  Nullable echo chaining
  ----------------------
  
  pass
  
  Matching
  --------
  
  8
  yes
  a
  1.5 snd true
  Another tag!
  
  
  Mapping
  -------
  
  a is a
  b is null.
  -5
  -4
  -3
  -2
  -1
  0
  1
  2
  3
  4
  5
  0 : -5
  1 : -4
  2 : -3
  3 : -2
  4 : -1
  5 : 0
  6 : 1
  7 : 2
  8 : 3
  9 : 4
  10 : 5
  1 1 1 2 2 2 3 3 3 
  
  Level 1 null
  Level 3 true
  Level 3 false
  Level 1 null
  
  
  Dictionaries match correctly
  ----------------------------
  
   Pass.
   Pass.
  
  
  Constructing async blocks
  -------------------------
  
   Nested block  Another nested block
  Component
  ---------
  
  Children prop
  123
  
  success
  
  Complicated pattern matching
  ----------------------------
  
   2 3
   Pass
   40
  String encoding
  ---------------
  
  ğŸ˜‡ğŸ‘¨â€ğŸ’»ğŸ˜‡
  \" \ \ \"
  
  ğŸ‘©â€ğŸŒ¾
  
  External JavaScript template component: stringify arbitrary data
  
  {
    "int_list": [
      -5,
      -4,
      -3,
      -2,
      -1,
      0,
      1,
      2,
      3,
      4,
      5
    ],
    "nested_list": [
      [
        [
          1,
          1,
          1
        ],
        [
          2,
          2,
          2
        ]
      ],
      [
        [
          3,
          3,
          3
        ]
      ]
    ],
    "nested_nullable_list": [
      null,
      true,
      false,
      null
    ],
    "null_string_dict": {
      "a": "a",
      "b": null
    },
    "record": {
      "int_enum": 8,
      "string_enum": "yes"
    },
    "tagged_record_bool": {
      "tag": false,
      "a": "a"
    },
    "tagged_record_int": {
      "tag": 1,
      "tuple": [
        1.5,
        "snd",
        true
      ]
    },
    "tagged_record_open": {
      "tag": 999
    },
    "tagged_record_string": {
      "tag": "a",
      "record_list": [
        {
          "job": "librarian",
          "name": "John"
        }
      ]
    },
    "unknown": "2023-04-09T00:00:00.000Z"
  }

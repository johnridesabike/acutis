  $ acutis \
  >   --mode js \
  >   template.acutis \
  >   component.acutis \
  >   unused.acutis \
  >   --fun ./jscomponents.mjs stringify "$(cat stringify_interface)" \
  >   --fun ./jscomponents.mjs another_function "" \
  >   --fun ./jscomponents.mjs an_unused_function "" \
  >   > compiled.mjs

  $ cat compiled.mjs
  /* THIS FILE WAS GENERATED BY ACUTIS. */
  let acutis_escape$0 =
    (arg$0) => {
      let result$0 = "";
      for (let i$0 = 0; i$0 < arg$0.length; i$0++) {
        let c$0 = arg$0[i$0];
        switch (c$0) {
          case "&": result$0 += "&amp;"; break;
          case "\"": result$0 += "&quot;"; break;
          case "'": result$0 += "&apos;"; break;
          case ">": result$0 += "&gt;"; break;
          case "<": result$0 += "&lt;"; break;
          case "/": result$0 += "&#x2F;"; break;
          case "`": result$0 += "&#x60;"; break;
          case "=": result$0 += "&#x3D;"; break;
          default: result$0 += c$0;
        }
      }
      return (result$0);
    };
  let buffer_to_promise$0 =
    (arg$0) => {
      return (
        Promise.all(arg$0).then((arg$1) => { return (arg$1.join("")); })
      );
    };
  let components$0 = new Map();
  import {"stringify" as import$0} from "./jscomponents.mjs";
  components$0.set(
    "Stringify",
    (arg$0) => {
      let encoded$0 = new Map();
      let props$0 = arg$0.get("int_list");
      let index$0 = 0;
      let cell$0 = props$0;
      while (!(cell$0 === 0)) { index$0++; cell$0 = cell$0[1]; }
      let encoded$1 =
        Array.from({length: index$0}, (arg$1) => { return (null); });
      cell$0 = props$0;
      index$0 = 0;
      while (!(cell$0 === 0)) {
        let props$1 = cell$0[0];
        encoded$1[index$0] = props$1;
        index$0++;
        cell$0 = cell$0[1];
      }
      encoded$0.set("int_list", encoded$1);
      let props$1 = arg$0.get("nested_list");
      let index$1 = 0;
      let cell$1 = props$1;
      while (!(cell$1 === 0)) { index$1++; cell$1 = cell$1[1]; }
      let encoded$2 =
        Array.from({length: index$1}, (arg$1) => { return (null); });
      cell$1 = props$1;
      index$1 = 0;
      while (!(cell$1 === 0)) {
        let props$2 = cell$1[0];
        let index$2 = 0;
        let cell$2 = props$2;
        while (!(cell$2 === 0)) { index$2++; cell$2 = cell$2[1]; }
        let encoded$3 =
          Array.from({length: index$2}, (arg$1) => { return (null); });
        cell$2 = props$2;
        index$2 = 0;
        while (!(cell$2 === 0)) {
          let props$3 = cell$2[0];
          let index$3 = 0;
          let cell$3 = props$3;
          while (!(cell$3 === 0)) { index$3++; cell$3 = cell$3[1]; }
          let encoded$4 =
            Array.from({length: index$3}, (arg$1) => { return (null); });
          cell$3 = props$3;
          index$3 = 0;
          while (!(cell$3 === 0)) {
            let props$4 = cell$3[0];
            encoded$4[index$3] = props$4;
            index$3++;
            cell$3 = cell$3[1];
          }
          encoded$3[index$2] = encoded$4;
          index$2++;
          cell$2 = cell$2[1];
        }
        encoded$2[index$1] = encoded$3;
        index$1++;
        cell$1 = cell$1[1];
      }
      encoded$0.set("nested_list", encoded$2);
      let props$2 = arg$0.get("nested_nullable_list");
      let index$2 = 0;
      let cell$2 = props$2;
      while (!(cell$2 === 0)) { index$2++; cell$2 = cell$2[1]; }
      let encoded$3 =
        Array.from({length: index$2}, (arg$1) => { return (null); });
      cell$2 = props$2;
      index$2 = 0;
      while (!(cell$2 === 0)) {
        let props$3 = cell$2[0];
        if (props$3 === 0) {
          encoded$3[index$2] = null;
        } else {
          let props$4 = props$3[0];
          if (props$4 === 0) {
            encoded$3[index$2] = null;
          } else {
            let props$5 = props$4[0];
            encoded$3[index$2] = props$5 ? true : false;
          }
        }
        index$2++;
        cell$2 = cell$2[1];
      }
      encoded$0.set("nested_nullable_list", encoded$3);
      let props$3 = arg$0.get("null_string_dict");
      let encoded$4 = new Map();
      for (let x$0 of props$3) {
        if (x$0[1] === 0) {
          encoded$4.set(x$0[0], null);
        } else {
          let props$4 = x$0[1][0];
          encoded$4.set(x$0[0], props$4);
        }
      }
      encoded$0.set("null_string_dict", Object.fromEntries(encoded$4));
      let props$4 = arg$0.get("record");
      let encoded$5 = new Map();
      let props$5 = props$4.get("int_enum");
      encoded$5.set("int_enum", props$5);
      let props$6 = props$4.get("string_enum");
      encoded$5.set("string_enum", props$6);
      encoded$0.set("record", Object.fromEntries(encoded$5));
      let props$7 = arg$0.get("tagged_record_bool");
      let tag$0 = props$7.get("tag");
      if (tag$0 === 0) {
        let encoded$6 = new Map();
        encoded$6.set("tag", tag$0 ? true : false);
        let props$8 = props$7.get("a");
        encoded$6.set("a", props$8);
        encoded$0.set("tagged_record_bool", Object.fromEntries(encoded$6));
      } else {
        if (tag$0 === 1) {
          let encoded$6 = new Map();
          encoded$6.set("tag", tag$0 ? true : false);
          let props$8 = props$7.get("b");
          encoded$6.set("b", props$8);
          encoded$0.set("tagged_record_bool", Object.fromEntries(encoded$6));
        }
      }
      let props$8 = arg$0.get("tagged_record_int");
      let tag$1 = props$8.get("tag");
      if (tag$1 === 0) {
        let encoded$6 = new Map();
        encoded$6.set("tag", tag$1);
        encoded$0.set("tagged_record_int", Object.fromEntries(encoded$6));
      } else {
        if (tag$1 === 1) {
          let encoded$6 = new Map();
          encoded$6.set("tag", tag$1);
          let props$9 = props$8.get("tuple");
          let encoded$7 =
            Array.from({length: 3}, (arg$1) => { return (null); });
          let props$10 = props$9[0];
          encoded$7[0] = props$10;
          let props$11 = props$9[1];
          encoded$7[1] = props$11;
          let props$12 = props$9[2];
          encoded$7[2] = props$12 ? true : false;
          encoded$6.set("tuple", encoded$7);
          encoded$0.set("tagged_record_int", Object.fromEntries(encoded$6));
        }
      }
      let props$9 = arg$0.get("tagged_record_open");
      let tag$2 = props$9.get("tag");
      if (tag$2 === 100) {
        let encoded$6 = new Map();
        encoded$6.set("tag", tag$2);
        let props$10 = props$9.get("a");
        encoded$6.set("a", props$10);
        encoded$0.set("tagged_record_open", Object.fromEntries(encoded$6));
      } else {
        if (tag$2 === 200) {
          let encoded$6 = new Map();
          encoded$6.set("tag", tag$2);
          let props$10 = props$9.get("b");
          encoded$6.set("b", props$10);
          encoded$0.set("tagged_record_open", Object.fromEntries(encoded$6));
        } else {
          if (tag$2 === 300) {
            let encoded$6 = new Map();
            encoded$6.set("tag", tag$2);
            let props$10 = props$9.get("c");
            encoded$6.set("c", props$10);
            encoded$0.set("tagged_record_open", Object.fromEntries(encoded$6));
          } else {
            let encoded$6 = new Map();
            encoded$6.set("tag", tag$2);
            encoded$0.set("tagged_record_open", Object.fromEntries(encoded$6));
          }
        }
      }
      let props$10 = arg$0.get("tagged_record_string");
      let tag$3 = props$10.get("tag");
      if (tag$3 === "a") {
        let encoded$6 = new Map();
        encoded$6.set("tag", tag$3);
        let props$11 = props$10.get("record_list");
        let index$3 = 0;
        let cell$3 = props$11;
        while (!(cell$3 === 0)) { index$3++; cell$3 = cell$3[1]; }
        let encoded$7 =
          Array.from({length: index$3}, (arg$1) => { return (null); });
        cell$3 = props$11;
        index$3 = 0;
        while (!(cell$3 === 0)) {
          let props$12 = cell$3[0];
          let encoded$8 = new Map();
          let props$13 = props$12.get("job");
          encoded$8.set("job", props$13);
          let props$14 = props$12.get("name");
          encoded$8.set("name", props$14);
          encoded$7[index$3] = Object.fromEntries(encoded$8);
          index$3++;
          cell$3 = cell$3[1];
        }
        encoded$6.set("record_list", encoded$7);
        encoded$0.set("tagged_record_string", Object.fromEntries(encoded$6));
      } else {
        if (tag$3 === "b") {
          let encoded$6 = new Map();
          encoded$6.set("tag", tag$3);
          let props$11 = props$10.get("open_enum");
          encoded$6.set("open_enum", props$11);
          encoded$0.set("tagged_record_string", Object.fromEntries(encoded$6));
        }
      }
      let props$11 = arg$0.get("unknown");
      encoded$0.set("unknown", props$11);
      return (import$0(Object.fromEntries(encoded$0)));
    }
  );
  import {"another_function" as import$1} from "./jscomponents.mjs";
  components$0.set(
    "Another_function",
    (arg$0) => {
      let encoded$0 = new Map();
      return (import$1(Object.fromEntries(encoded$0)));
    }
  );
  components$0.set(
    "Component",
    (arg$0) => {
      let buffer$0 = [];
      let nullable$0 = arg$0.get("optional");
      if (!(nullable$0 === 0)) {
        buffer$0.push(acutis_escape$0(nullable$0[0].toString()));
      } else {
        buffer$0.push(acutis_escape$0(arg$0.get("children")));
      }
      buffer$0.push("\n");
      let index$0 = 0;
      let cell$0 = arg$0.get("list");
      while (!(cell$0 === 0)) {
        let props$0 = new Map(arg$0);
        let head$0 = cell$0[0];
        let exit$0 = -1;
        props$0.set("i", head$0);
        exit$0 = 0;
        buffer$0.push(acutis_escape$0(props$0.get("i").toString()));
        index$0++;
        cell$0 = cell$0[1];
      }
      return (buffer_to_promise$0(buffer$0));
    }
  );
  export default (arg$0) => {
    let stack$0 = [];
    let is_error$0 = false;
    let missing_keys$0 = [];
    let decode_error$0 =
      (arg$1) => {
        return (
          (arg$2) => {
            return (
              Promise.reject(
                new Error(
                  [
                    "File \"",
                    "template.acutis",
                    "\"\n\
  Render error.\n\
  The data supplied does not match this template's interface.\n\
  ",
                    "Path:\n",
                    stack$0.join(" <- "),
                    "\nExpected type:\n",
                    arg$1,
                    "\nReceived value:\n",
                    String(arg$2),
                  ].join(
                    ""
                  )
                )
              )
            );
          }
        );
      };
    let key_error$0 =
      (arg$1) => {
        return (
          Promise.reject(
            new Error(
              [
                "File: ",
                "template.acutis",
                "\n\
  Render error.\n\
  The data supplied does not match this template's interface.\n\
  ",
                "Path:\n",
                stack$0.join(" <- "),
                "\nExpected type:\n",
                arg$1,
                "\nInput is missing keys:\n",
                missing_keys$0.join(", "),
              ].join(
                ""
              )
            )
          )
        );
      };
    let props$0 = new Map();
    stack$0.unshift("<input>");
    if (typeof arg$0 === "object" && !(arg$0 === null)) {
      if (Object.hasOwn(arg$0, "big_float")) {
        let input$0 = arg$0["big_float"];
        stack$0.unshift("big_float");
        if (typeof input$0 === "number") {
          props$0.set("big_float", input$0);
        } else {
          if (typeof input$0 === "number" && Number.isInteger(input$0)) {
            props$0.set("big_float", input$0);
          } else {
            is_error$0 = true;
          }
        }
        if (is_error$0) { return (decode_error$0("float")(input$0)); }
        stack$0.shift();
      } else {
        missing_keys$0.unshift("big_float");
      }
      if (Object.hasOwn(arg$0, "big_int")) {
        let input$0 = arg$0["big_int"];
        stack$0.unshift("big_int");
        if (typeof input$0 === "number" && Number.isInteger(input$0)) {
          props$0.set("big_int", input$0);
        } else {
          is_error$0 = true;
        }
        if (is_error$0) { return (decode_error$0("int")(input$0)); }
        stack$0.shift();
      } else {
        missing_keys$0.unshift("big_int");
      }
      if (Object.hasOwn(arg$0, "bool1")) {
        let input$0 = arg$0["bool1"];
        stack$0.unshift("bool1");
        if (typeof input$0 === "boolean") {
          if (input$0) {
            props$0.set("bool1", 1);
          } else {
            props$0.set("bool1", 0);
          }
        } else {
          is_error$0 = true;
        }
        if (is_error$0) { return (decode_error$0("false | true")(input$0)); }
        stack$0.shift();
      } else {
        missing_keys$0.unshift("bool1");
      }
      if (Object.hasOwn(arg$0, "bool2")) {
        let input$0 = arg$0["bool2"];
        stack$0.unshift("bool2");
        if (typeof input$0 === "boolean") {
          if (input$0) {
            props$0.set("bool2", 1);
          } else {
            props$0.set("bool2", 0);
          }
        } else {
          is_error$0 = true;
        }
        if (is_error$0) { return (decode_error$0("false | true")(input$0)); }
        stack$0.shift();
      } else {
        missing_keys$0.unshift("bool2");
      }
      if (Object.hasOwn(arg$0, "dangerous")) {
        let input$0 = arg$0["dangerous"];
        stack$0.unshift("dangerous");
        if (typeof input$0 === "string") {
          props$0.set("dangerous", input$0);
        } else {
          is_error$0 = true;
        }
        if (is_error$0) { return (decode_error$0("string")(input$0)); }
        stack$0.shift();
      } else {
        missing_keys$0.unshift("dangerous");
      }
      if (Object.hasOwn(arg$0, "int_list")) {
        let input$0 = arg$0["int_list"];
        stack$0.unshift("int_list");
        if (Array.isArray(input$0)) {
          let decoded$0 = [0, 0];
          let decode_dst$0 = decoded$0;
          for (let i$0 = 0; i$0 < input$0.length; i$0++) {
            let decode_dst_new$0 = [0, 0];
            stack$0.unshift(i$0.toString());
            if (
              typeof input$0[i$0] === "number" &&
              Number.isInteger(input$0[i$0])
            ) {
              decode_dst_new$0[0] = input$0[i$0];
            } else {
              is_error$0 = true;
            }
            if (is_error$0) { return (decode_error$0("int")(input$0[i$0])); }
            decode_dst$0[1] = decode_dst_new$0;
            decode_dst$0 = decode_dst_new$0;
            stack$0.shift();
          }
          props$0.set("int_list", decoded$0[1]);
        } else {
          is_error$0 = true;
        }
        if (is_error$0) { return (decode_error$0("[int]")(input$0)); }
        stack$0.shift();
      } else {
        missing_keys$0.unshift("int_list");
      }
      if (Object.hasOwn(arg$0, "nested_list")) {
        let input$0 = arg$0["nested_list"];
        stack$0.unshift("nested_list");
        if (Array.isArray(input$0)) {
          let decoded$0 = [0, 0];
          let decode_dst$0 = decoded$0;
          for (let i$0 = 0; i$0 < input$0.length; i$0++) {
            let decode_dst_new$0 = [0, 0];
            stack$0.unshift(i$0.toString());
            if (Array.isArray(input$0[i$0])) {
              let decoded$1 = [0, 0];
              let decode_dst$1 = decoded$1;
              for (let i$1 = 0; i$1 < input$0[i$0].length; i$1++) {
                let decode_dst_new$1 = [0, 0];
                stack$0.unshift(i$1.toString());
                if (Array.isArray(input$0[i$0][i$1])) {
                  let decoded$2 = [0, 0];
                  let decode_dst$2 = decoded$2;
                  for (let i$2 = 0; i$2 < input$0[i$0][i$1].length; i$2++) {
                    let decode_dst_new$2 = [0, 0];
                    stack$0.unshift(i$2.toString());
                    if (
                      typeof input$0[i$0][i$1][i$2] === "number" &&
                      Number.isInteger(input$0[i$0][i$1][i$2])
                    ) {
                      decode_dst_new$2[0] = input$0[i$0][i$1][i$2];
                    } else {
                      is_error$0 = true;
                    }
                    if (is_error$0) {
                      return (decode_error$0("int")(input$0[i$0][i$1][i$2]));
                    }
                    decode_dst$2[1] = decode_dst_new$2;
                    decode_dst$2 = decode_dst_new$2;
                    stack$0.shift();
                  }
                  decode_dst_new$1[0] = decoded$2[1];
                } else {
                  is_error$0 = true;
                }
                if (is_error$0) {
                  return (decode_error$0("[int]")(input$0[i$0][i$1]));
                }
                decode_dst$1[1] = decode_dst_new$1;
                decode_dst$1 = decode_dst_new$1;
                stack$0.shift();
              }
              decode_dst_new$0[0] = decoded$1[1];
            } else {
              is_error$0 = true;
            }
            if (is_error$0) {
              return (decode_error$0("[[int]]")(input$0[i$0]));
            }
            decode_dst$0[1] = decode_dst_new$0;
            decode_dst$0 = decode_dst_new$0;
            stack$0.shift();
          }
          props$0.set("nested_list", decoded$0[1]);
        } else {
          is_error$0 = true;
        }
        if (is_error$0) { return (decode_error$0("[[[int]]]")(input$0)); }
        stack$0.shift();
      } else {
        missing_keys$0.unshift("nested_list");
      }
      if (Object.hasOwn(arg$0, "nested_nullable_list")) {
        let input$0 = arg$0["nested_nullable_list"];
        stack$0.unshift("nested_nullable_list");
        if (Array.isArray(input$0)) {
          let decoded$0 = [0, 0];
          let decode_dst$0 = decoded$0;
          for (let i$0 = 0; i$0 < input$0.length; i$0++) {
            let decode_dst_new$0 = [0, 0];
            stack$0.unshift(i$0.toString());
            if (input$0[i$0] === null || input$0[i$0] === undefined) {
              decode_dst_new$0[0] = 0;
            } else {
              let decoded$1 = [0];
              stack$0.unshift("<nullable>");
              if (input$0[i$0] === null || input$0[i$0] === undefined) {
                decoded$1[0] = 0;
              } else {
                let decoded$2 = [0];
                stack$0.unshift("<nullable>");
                if (typeof input$0[i$0] === "boolean") {
                  if (input$0[i$0]) {
                    decoded$2[0] = 1;
                  } else {
                    decoded$2[0] = 0;
                  }
                } else {
                  is_error$0 = true;
                }
                if (is_error$0) {
                  return (decode_error$0("false | true")(input$0[i$0]));
                }
                decoded$1[0] = decoded$2;
                stack$0.shift();
              }
              if (is_error$0) {
                return (decode_error$0("?false | true")(input$0[i$0]));
              }
              decode_dst_new$0[0] = decoded$1;
              stack$0.shift();
            }
            if (is_error$0) {
              return (decode_error$0("??false | true")(input$0[i$0]));
            }
            decode_dst$0[1] = decode_dst_new$0;
            decode_dst$0 = decode_dst_new$0;
            stack$0.shift();
          }
          props$0.set("nested_nullable_list", decoded$0[1]);
        } else {
          is_error$0 = true;
        }
        if (is_error$0) {
          return (decode_error$0("[??false | true]")(input$0));
        }
        stack$0.shift();
      } else {
        missing_keys$0.unshift("nested_nullable_list");
      }
      if (Object.hasOwn(arg$0, "null_bool")) {
        let input$0 = arg$0["null_bool"];
        stack$0.unshift("null_bool");
        if (input$0 === null || input$0 === undefined) {
          props$0.set("null_bool", 0);
        } else {
          let decoded$0 = [0];
          stack$0.unshift("<nullable>");
          if (typeof input$0 === "boolean") {
            if (input$0) { decoded$0[0] = 1; } else { decoded$0[0] = 0; }
          } else {
            is_error$0 = true;
          }
          if (is_error$0) { return (decode_error$0("false | true")(input$0)); }
          props$0.set("null_bool", decoded$0);
          stack$0.shift();
        }
        if (is_error$0) { return (decode_error$0("?false | true")(input$0)); }
        stack$0.shift();
      } else {
        props$0.set("null_bool", 0);
      }
      if (Object.hasOwn(arg$0, "null_float")) {
        let input$0 = arg$0["null_float"];
        stack$0.unshift("null_float");
        if (input$0 === null || input$0 === undefined) {
          props$0.set("null_float", 0);
        } else {
          let decoded$0 = [0];
          stack$0.unshift("<nullable>");
          if (typeof input$0 === "number") {
            decoded$0[0] = input$0;
          } else {
            if (typeof input$0 === "number" && Number.isInteger(input$0)) {
              decoded$0[0] = input$0;
            } else {
              is_error$0 = true;
            }
          }
          if (is_error$0) { return (decode_error$0("float")(input$0)); }
          props$0.set("null_float", decoded$0);
          stack$0.shift();
        }
        if (is_error$0) { return (decode_error$0("?float")(input$0)); }
        stack$0.shift();
      } else {
        props$0.set("null_float", 0);
      }
      if (Object.hasOwn(arg$0, "null_int")) {
        let input$0 = arg$0["null_int"];
        stack$0.unshift("null_int");
        if (input$0 === null || input$0 === undefined) {
          props$0.set("null_int", 0);
        } else {
          let decoded$0 = [0];
          stack$0.unshift("<nullable>");
          if (typeof input$0 === "number" && Number.isInteger(input$0)) {
            decoded$0[0] = input$0;
          } else {
            is_error$0 = true;
          }
          if (is_error$0) { return (decode_error$0("int")(input$0)); }
          props$0.set("null_int", decoded$0);
          stack$0.shift();
        }
        if (is_error$0) { return (decode_error$0("?int")(input$0)); }
        stack$0.shift();
      } else {
        props$0.set("null_int", 0);
      }
      if (Object.hasOwn(arg$0, "null_string")) {
        let input$0 = arg$0["null_string"];
        stack$0.unshift("null_string");
        if (input$0 === null || input$0 === undefined) {
          props$0.set("null_string", 0);
        } else {
          let decoded$0 = [0];
          stack$0.unshift("<nullable>");
          if (typeof input$0 === "string") {
            decoded$0[0] = input$0;
          } else {
            is_error$0 = true;
          }
          if (is_error$0) { return (decode_error$0("string")(input$0)); }
          props$0.set("null_string", decoded$0);
          stack$0.shift();
        }
        if (is_error$0) { return (decode_error$0("?string")(input$0)); }
        stack$0.shift();
      } else {
        props$0.set("null_string", 0);
      }
      if (Object.hasOwn(arg$0, "null_string_dict")) {
        let input$0 = arg$0["null_string_dict"];
        stack$0.unshift("null_string_dict");
        if (typeof input$0 === "object" && !(input$0 === null)) {
          let decoded$0 = new Map();
          for (let x$0 of Object.keys(input$0)) {
            stack$0.unshift(x$0);
            if (input$0[x$0] === null || input$0[x$0] === undefined) {
              decoded$0.set(x$0, 0);
            } else {
              let decoded$1 = [0];
              stack$0.unshift("<nullable>");
              if (typeof input$0[x$0] === "string") {
                decoded$1[0] = input$0[x$0];
              } else {
                is_error$0 = true;
              }
              if (is_error$0) {
                return (decode_error$0("string")(input$0[x$0]));
              }
              decoded$0.set(x$0, decoded$1);
              stack$0.shift();
            }
            if (is_error$0) {
              return (decode_error$0("?string")(input$0[x$0]));
            }
            props$0.set("null_string_dict", decoded$0);
            stack$0.shift();
          }
        } else {
          is_error$0 = true;
        }
        if (is_error$0) { return (decode_error$0("<?string>")(input$0)); }
        stack$0.shift();
      } else {
        missing_keys$0.unshift("null_string_dict");
      }
      if (Object.hasOwn(arg$0, "record")) {
        let input$0 = arg$0["record"];
        stack$0.unshift("record");
        if (typeof input$0 === "object" && !(input$0 === null)) {
          let decoded$0 = new Map();
          if (Object.hasOwn(input$0, "int_enum")) {
            let input$1 = input$0["int_enum"];
            stack$0.unshift("int_enum");
            if (typeof input$1 === "number" && Number.isInteger(input$1)) {
              if (input$1 === 8) {
                decoded$0.set("int_enum", input$1);
              } else {
                if (input$1 === 40) {
                  decoded$0.set("int_enum", input$1);
                } else {
                  is_error$0 = true;
                }
              }
            } else {
              is_error$0 = true;
            }
            if (is_error$0) { return (decode_error$0("@8 | @40")(input$1)); }
            stack$0.shift();
          } else {
            missing_keys$0.unshift("int_enum");
          }
          if (Object.hasOwn(input$0, "string_enum")) {
            let input$1 = input$0["string_enum"];
            stack$0.unshift("string_enum");
            if (typeof input$1 === "string") {
              if (input$1 === "no") {
                decoded$0.set("string_enum", input$1);
              } else {
                if (input$1 === "yes") {
                  decoded$0.set("string_enum", input$1);
                } else {
                  is_error$0 = true;
                }
              }
            } else {
              is_error$0 = true;
            }
            if (is_error$0) {
              return (decode_error$0("@\"no\" | @\"yes\"")(input$1));
            }
            stack$0.shift();
          } else {
            missing_keys$0.unshift("string_enum");
          }
          if (!(missing_keys$0.length === 0)) {
            return (
              key_error$0(
                "{int_enum: @8 | @40, string_enum: @\"no\" | @\"yes\"}"
              )
            );
          }
          props$0.set("record", decoded$0);
        } else {
          is_error$0 = true;
        }
        if (is_error$0) {
          return (
            decode_error$0(
              "{int_enum: @8 | @40, string_enum: @\"no\" | @\"yes\"}"
            )(
              input$0
            )
          );
        }
        stack$0.shift();
      } else {
        missing_keys$0.unshift("record");
      }
      if (Object.hasOwn(arg$0, "tagged_record_bool")) {
        let input$0 = arg$0["tagged_record_bool"];
        stack$0.unshift("tagged_record_bool");
        if (typeof input$0 === "object" && !(input$0 === null)) {
          if (Object.hasOwn(input$0, "tag")) {
            if (typeof input$0["tag"] === "boolean") {
              if (input$0["tag"]) {
                let decoded$0 = new Map();
                decoded$0.set("tag", 1);
                if (Object.hasOwn(input$0, "b")) {
                  let input$1 = input$0["b"];
                  stack$0.unshift("b");
                  if (typeof input$1 === "number" && Number.isInteger(input$1)) {
                    decoded$0.set("b", input$1);
                  } else {
                    is_error$0 = true;
                  }
                  if (is_error$0) { return (decode_error$0("int")(input$1)); }
                  stack$0.shift();
                } else {
                  missing_keys$0.unshift("b");
                }
                if (!(missing_keys$0.length === 0)) {
                  return (key_error$0("{b: int}"));
                }
                props$0.set("tagged_record_bool", decoded$0);
              } else {
                let decoded$0 = new Map();
                decoded$0.set("tag", 0);
                if (Object.hasOwn(input$0, "a")) {
                  let input$1 = input$0["a"];
                  stack$0.unshift("a");
                  if (typeof input$1 === "string") {
                    decoded$0.set("a", input$1);
                  } else {
                    is_error$0 = true;
                  }
                  if (is_error$0) {
                    return (decode_error$0("string")(input$1));
                  }
                  stack$0.shift();
                } else {
                  missing_keys$0.unshift("a");
                }
                if (!(missing_keys$0.length === 0)) {
                  return (key_error$0("{a: string}"));
                }
                props$0.set("tagged_record_bool", decoded$0);
              }
            } else {
              is_error$0 = true;
            }
          } else {
            is_error$0 = true;
          }
        } else {
          is_error$0 = true;
        }
        if (is_error$0) {
          return (
            decode_error$0("{@tag: false, a: string} | {@tag: true, b: int}")(
              input$0
            )
          );
        }
        stack$0.shift();
      } else {
        missing_keys$0.unshift("tagged_record_bool");
      }
      if (Object.hasOwn(arg$0, "tagged_record_int")) {
        let input$0 = arg$0["tagged_record_int"];
        stack$0.unshift("tagged_record_int");
        if (typeof input$0 === "object" && !(input$0 === null)) {
          if (Object.hasOwn(input$0, "tag")) {
            if (
              typeof input$0["tag"] === "number" &&
              Number.isInteger(input$0["tag"])
            ) {
              if (input$0["tag"] === 0) {
                let decoded$0 = new Map();
                decoded$0.set("tag", input$0["tag"]);
                if (!(missing_keys$0.length === 0)) {
                  return (key_error$0("{}"));
                }
                props$0.set("tagged_record_int", decoded$0);
              } else {
                if (input$0["tag"] === 1) {
                  let decoded$0 = new Map();
                  decoded$0.set("tag", input$0["tag"]);
                  if (Object.hasOwn(input$0, "tuple")) {
                    let input$1 = input$0["tuple"];
                    stack$0.unshift("tuple");
                    if (Array.isArray(input$1)) {
                      if (input$1.length === 3) {
                        let decoded$1 =
                          Array.from({length: 3}, (arg$1) => { return (0); });
                        for (let i$0 = 0; i$0 < input$1.length; i$0++) {
                          stack$0.unshift(i$0.toString());
                          if (i$0 === 0) {
                            if (typeof input$1[i$0] === "number") {
                              decoded$1[i$0] = input$1[i$0];
                            } else {
                              if (
                                typeof input$1[i$0] === "number" &&
                                Number.isInteger(input$1[i$0])
                              ) {
                                decoded$1[i$0] = input$1[i$0];
                              } else {
                                is_error$0 = true;
                              }
                            }
                            if (is_error$0) {
                              return (decode_error$0("float")(input$1[i$0]));
                            }
                          } else {
                            if (i$0 === 1) {
                              if (typeof input$1[i$0] === "string") {
                                decoded$1[i$0] = input$1[i$0];
                              } else {
                                is_error$0 = true;
                              }
                              if (is_error$0) {
                                return (
                                  decode_error$0("string")(input$1[i$0])
                                );
                              }
                            } else {
                              if (i$0 === 2) {
                                if (typeof input$1[i$0] === "boolean") {
                                  if (input$1[i$0]) {
                                    decoded$1[i$0] = 1;
                                  } else {
                                    decoded$1[i$0] = 0;
                                  }
                                } else {
                                  is_error$0 = true;
                                }
                                if (is_error$0) {
                                  return (
                                    decode_error$0("false | true")(
                                      input$1[i$0]
                                    )
                                  );
                                }
                              } else {
                                is_error$0 = true;
                              }
                            }
                          }
                          decoded$0.set("tuple", decoded$1);
                          stack$0.shift();
                        }
                      } else {
                        is_error$0 = true;
                      }
                    } else {
                      is_error$0 = true;
                    }
                    if (is_error$0) {
                      return (
                        decode_error$0("(float, string, false | true)")(
                          input$1
                        )
                      );
                    }
                    stack$0.shift();
                  } else {
                    missing_keys$0.unshift("tuple");
                  }
                  if (!(missing_keys$0.length === 0)) {
                    return (
                      key_error$0("{tuple: (float, string, false | true)}")
                    );
                  }
                  props$0.set("tagged_record_int", decoded$0);
                } else {
                  is_error$0 = true;
                }
              }
            } else {
              is_error$0 = true;
            }
          } else {
            is_error$0 = true;
          }
        } else {
          is_error$0 = true;
        }
        if (is_error$0) {
          return (
            decode_error$0(
              "{@tag: 0} | {@tag: 1, tuple: (float, string, false | true)}"
            )(
              input$0
            )
          );
        }
        stack$0.shift();
      } else {
        missing_keys$0.unshift("tagged_record_int");
      }
      if (Object.hasOwn(arg$0, "tagged_record_open")) {
        let input$0 = arg$0["tagged_record_open"];
        stack$0.unshift("tagged_record_open");
        if (typeof input$0 === "object" && !(input$0 === null)) {
          if (Object.hasOwn(input$0, "tag")) {
            if (
              typeof input$0["tag"] === "number" &&
              Number.isInteger(input$0["tag"])
            ) {
              if (input$0["tag"] === 100) {
                let decoded$0 = new Map();
                decoded$0.set("tag", input$0["tag"]);
                if (Object.hasOwn(input$0, "a")) {
                  let input$1 = input$0["a"];
                  stack$0.unshift("a");
                  if (typeof input$1 === "number" && Number.isInteger(input$1)) {
                    decoded$0.set("a", input$1);
                  } else {
                    is_error$0 = true;
                  }
                  if (is_error$0) { return (decode_error$0("int")(input$1)); }
                  stack$0.shift();
                } else {
                  missing_keys$0.unshift("a");
                }
                if (!(missing_keys$0.length === 0)) {
                  return (key_error$0("{a: int}"));
                }
                props$0.set("tagged_record_open", decoded$0);
              } else {
                if (input$0["tag"] === 200) {
                  let decoded$0 = new Map();
                  decoded$0.set("tag", input$0["tag"]);
                  if (Object.hasOwn(input$0, "b")) {
                    let input$1 = input$0["b"];
                    stack$0.unshift("b");
                    if (typeof input$1 === "string") {
                      decoded$0.set("b", input$1);
                    } else {
                      is_error$0 = true;
                    }
                    if (is_error$0) {
                      return (decode_error$0("string")(input$1));
                    }
                    stack$0.shift();
                  } else {
                    missing_keys$0.unshift("b");
                  }
                  if (!(missing_keys$0.length === 0)) {
                    return (key_error$0("{b: string}"));
                  }
                  props$0.set("tagged_record_open", decoded$0);
                } else {
                  if (input$0["tag"] === 300) {
                    let decoded$0 = new Map();
                    decoded$0.set("tag", input$0["tag"]);
                    if (Object.hasOwn(input$0, "c")) {
                      let input$1 = input$0["c"];
                      stack$0.unshift("c");
                      if (typeof input$1 === "number") {
                        decoded$0.set("c", input$1);
                      } else {
                        if (
                          typeof input$1 === "number" &&
                          Number.isInteger(input$1)
                        ) {
                          decoded$0.set("c", input$1);
                        } else {
                          is_error$0 = true;
                        }
                      }
                      if (is_error$0) {
                        return (decode_error$0("float")(input$1));
                      }
                      stack$0.shift();
                    } else {
                      missing_keys$0.unshift("c");
                    }
                    if (!(missing_keys$0.length === 0)) {
                      return (key_error$0("{c: float}"));
                    }
                    props$0.set("tagged_record_open", decoded$0);
                  } else {
                    let decoded$0 = new Map();
                    decoded$0.set("tag", input$0["tag"]);
                    props$0.set("tagged_record_open", decoded$0);
                  }
                }
              }
            } else {
              is_error$0 = true;
            }
          } else {
            is_error$0 = true;
          }
        } else {
          is_error$0 = true;
        }
        if (is_error$0) {
          return (
            decode_error$0(
              "{@tag: 100, a: int} | {@tag: 200, b: string} | {@tag: 300, c: float} | ..."
            )(
              input$0
            )
          );
        }
        stack$0.shift();
      } else {
        missing_keys$0.unshift("tagged_record_open");
      }
      if (Object.hasOwn(arg$0, "tagged_record_string")) {
        let input$0 = arg$0["tagged_record_string"];
        stack$0.unshift("tagged_record_string");
        if (typeof input$0 === "object" && !(input$0 === null)) {
          if (Object.hasOwn(input$0, "tag")) {
            if (typeof input$0["tag"] === "string") {
              if (input$0["tag"] === "a") {
                let decoded$0 = new Map();
                decoded$0.set("tag", input$0["tag"]);
                if (Object.hasOwn(input$0, "record_list")) {
                  let input$1 = input$0["record_list"];
                  stack$0.unshift("record_list");
                  if (Array.isArray(input$1)) {
                    let decoded$1 = [0, 0];
                    let decode_dst$0 = decoded$1;
                    for (let i$0 = 0; i$0 < input$1.length; i$0++) {
                      let decode_dst_new$0 = [0, 0];
                      stack$0.unshift(i$0.toString());
                      if (
                        typeof input$1[i$0] === "object" &&
                        !(input$1[i$0] === null)
                      ) {
                        let decoded$2 = new Map();
                        if (Object.hasOwn(input$1[i$0], "job")) {
                          let input$2 = input$1[i$0]["job"];
                          stack$0.unshift("job");
                          if (typeof input$2 === "string") {
                            decoded$2.set("job", input$2);
                          } else {
                            is_error$0 = true;
                          }
                          if (is_error$0) {
                            return (decode_error$0("string")(input$2));
                          }
                          stack$0.shift();
                        } else {
                          missing_keys$0.unshift("job");
                        }
                        if (Object.hasOwn(input$1[i$0], "name")) {
                          let input$2 = input$1[i$0]["name"];
                          stack$0.unshift("name");
                          if (typeof input$2 === "string") {
                            decoded$2.set("name", input$2);
                          } else {
                            is_error$0 = true;
                          }
                          if (is_error$0) {
                            return (decode_error$0("string")(input$2));
                          }
                          stack$0.shift();
                        } else {
                          missing_keys$0.unshift("name");
                        }
                        if (!(missing_keys$0.length === 0)) {
                          return (key_error$0("{job: string, name: string}"));
                        }
                        decode_dst_new$0[0] = decoded$2;
                      } else {
                        is_error$0 = true;
                      }
                      if (is_error$0) {
                        return (
                          decode_error$0("{job: string, name: string}")(
                            input$1[i$0]
                          )
                        );
                      }
                      decode_dst$0[1] = decode_dst_new$0;
                      decode_dst$0 = decode_dst_new$0;
                      stack$0.shift();
                    }
                    decoded$0.set("record_list", decoded$1[1]);
                  } else {
                    is_error$0 = true;
                  }
                  if (is_error$0) {
                    return (
                      decode_error$0("[{job: string, name: string}]")(input$1)
                    );
                  }
                  stack$0.shift();
                } else {
                  missing_keys$0.unshift("record_list");
                }
                if (!(missing_keys$0.length === 0)) {
                  return (
                    key_error$0("{record_list: [{job: string, name: string}]}")
                  );
                }
                props$0.set("tagged_record_string", decoded$0);
              } else {
                if (input$0["tag"] === "b") {
                  let decoded$0 = new Map();
                  decoded$0.set("tag", input$0["tag"]);
                  if (Object.hasOwn(input$0, "open_enum")) {
                    let input$1 = input$0["open_enum"];
                    stack$0.unshift("open_enum");
                    if (
                      typeof input$1 === "number" &&
                      Number.isInteger(input$1)
                    ) {
                      decoded$0.set("open_enum", input$1);
                    } else {
                      is_error$0 = true;
                    }
                    if (is_error$0) {
                      return (decode_error$0("@0 | @1 | ...")(input$1));
                    }
                    stack$0.shift();
                  } else {
                    missing_keys$0.unshift("open_enum");
                  }
                  if (!(missing_keys$0.length === 0)) {
                    return (key_error$0("{open_enum: @0 | @1 | ...}"));
                  }
                  props$0.set("tagged_record_string", decoded$0);
                } else {
                  is_error$0 = true;
                }
              }
            } else {
              is_error$0 = true;
            }
          } else {
            is_error$0 = true;
          }
        } else {
          is_error$0 = true;
        }
        if (is_error$0) {
          return (
            decode_error$0(
              "{@tag: \"a\", record_list: [{job: string, name: string}]} |\n\
  {@tag: \"b\", open_enum: @0 | @1 | ...}"
            )(
              input$0
            )
          );
        }
        stack$0.shift();
      } else {
        missing_keys$0.unshift("tagged_record_string");
      }
      if (Object.hasOwn(arg$0, "unicode_string")) {
        let input$0 = arg$0["unicode_string"];
        stack$0.unshift("unicode_string");
        if (typeof input$0 === "string") {
          props$0.set("unicode_string", input$0);
        } else {
          is_error$0 = true;
        }
        if (is_error$0) { return (decode_error$0("string")(input$0)); }
        stack$0.shift();
      } else {
        missing_keys$0.unshift("unicode_string");
      }
      if (Object.hasOwn(arg$0, "unknown")) {
        let input$0 = arg$0["unknown"];
        stack$0.unshift("unknown");
        props$0.set("unknown", input$0);
        if (is_error$0) { return (decode_error$0("_")(input$0)); }
        stack$0.shift();
      } else {
        props$0.set("unknown", 0);
      }
      if (!(missing_keys$0.length === 0)) {
        return (
          key_error$0(
            "{\n\
    big_float: float,\n\
    big_int: int,\n\
    bool1: false | true,\n\
    bool2: false | true,\n\
    dangerous: string,\n\
    int_list: [int],\n\
    nested_list: [[[int]]],\n\
    nested_nullable_list: [??false | true],\n\
    null_bool: ?false | true,\n\
    null_float: ?float,\n\
    null_int: ?int,\n\
    null_string: ?string,\n\
    null_string_dict: <?string>,\n\
    record: {int_enum: @8 | @40, string_enum: @\"no\" | @\"yes\"},\n\
    tagged_record_bool: {@tag: false, a: string} | {@tag: true, b: int},\n\
    tagged_record_int:\n\
      {@tag: 0} | {@tag: 1, tuple: (float, string, false | true)},\n\
    tagged_record_open:\n\
      {@tag: 100, a: int} |\n\
      {@tag: 200, b: string} |\n\
      {@tag: 300, c: float} |\n\
      ...,\n\
    tagged_record_string:\n\
      {@tag: \"a\", record_list: [{job: string, name: string}]} |\n\
      {@tag: \"b\", open_enum: @0 | @1 | ...},\n\
    unicode_string: string,\n\
    unknown: _\n\
  }"
          )
        );
      }
    } else {
      return (
        decode_error$0(
          "{\n\
    big_float: float,\n\
    big_int: int,\n\
    bool1: false | true,\n\
    bool2: false | true,\n\
    dangerous: string,\n\
    int_list: [int],\n\
    nested_list: [[[int]]],\n\
    nested_nullable_list: [??false | true],\n\
    null_bool: ?false | true,\n\
    null_float: ?float,\n\
    null_int: ?int,\n\
    null_string: ?string,\n\
    null_string_dict: <?string>,\n\
    record: {int_enum: @8 | @40, string_enum: @\"no\" | @\"yes\"},\n\
    tagged_record_bool: {@tag: false, a: string} | {@tag: true, b: int},\n\
    tagged_record_int:\n\
      {@tag: 0} | {@tag: 1, tuple: (float, string, false | true)},\n\
    tagged_record_open:\n\
      {@tag: 100, a: int} |\n\
      {@tag: 200, b: string} |\n\
      {@tag: 300, c: float} |\n\
      ...,\n\
    tagged_record_string:\n\
      {@tag: \"a\", record_list: [{job: string, name: string}]} |\n\
      {@tag: \"b\", open_enum: @0 | @1 | ...},\n\
    unicode_string: string,\n\
    unknown: _\n\
  }"
        )(
          arg$0
        )
      );
    }
    let buffer$0 = [];
    buffer$0.push("Formatters\n----------\n\n%i    ");
    buffer$0.push(acutis_escape$0(props$0.get("big_int").toString()));
    buffer$0.push("\n%f    ");
    buffer$0.push(acutis_escape$0(props$0.get("big_float").toString()));
    buffer$0.push("\n%b    ");
    buffer$0.push(acutis_escape$0(props$0.get("bool1") ? "true" : "false"));
    buffer$0.push("\n%b    ");
    buffer$0.push(acutis_escape$0(props$0.get("bool2") ? "true" : "false"));
    buffer$0.push("\n\nEscaping\n--------\n\nEscaped     ");
    buffer$0.push(acutis_escape$0(props$0.get("dangerous")));
    buffer$0.push("\nNot escaped ");
    buffer$0.push(props$0.get("dangerous"));
    buffer$0.push("\n\nNullable echo chaining\n----------------------\n\n");
    let nullable$0 = props$0.get("null_int");
    if (!(nullable$0 === 0)) {
      buffer$0.push(acutis_escape$0(nullable$0[0].toString()));
    } else {
      let nullable$1 = props$0.get("null_float");
      if (!(nullable$1 === 0)) {
        buffer$0.push(acutis_escape$0(nullable$1[0].toString()));
      } else {
        let nullable$2 = props$0.get("null_bool");
        if (!(nullable$2 === 0)) {
          buffer$0.push(acutis_escape$0(nullable$2[0] ? "true" : "false"));
        } else {
          let nullable$3 = props$0.get("null_string");
          if (!(nullable$3 === 0)) {
            buffer$0.push(acutis_escape$0(nullable$3[0]));
          } else {
            buffer$0.push(acutis_escape$0("pass"));
          }
        }
      }
    }
    buffer$0.push("\n\nMatching\n--------\n\n");
    let arg_match$0 = [props$0.get("record").get("int_enum")];
    let props$1 = new Map(props$0);
    let exit$0 = -1;
    let match_arg$0 = arg_match$0[0];
    if (match_arg$0 === 8) {
      exit$0 = 0;
    } else {
      if (match_arg$0 === 40) { exit$0 = 1; }
    }
    if (exit$0 === 0) { buffer$0.push("8\n"); } else { buffer$0.push("40\n"); }
    let arg_match$1 = [props$0.get("record")];
    let props$2 = new Map(props$0);
    let exit$1 = -1;
    let match_arg$1 = arg_match$1[0];
    let match_arg$2 = match_arg$1.get("string_enum");
    if (match_arg$2 === "no") {
      exit$1 = 1;
    } else {
      if (match_arg$2 === "yes") { exit$1 = 0; }
    }
    if (exit$1 === 0) {
      buffer$0.push("yes\n");
    } else {
      buffer$0.push("no\n");
    }
    let arg_match$2 = [props$0.get("tagged_record_bool")];
    let props$3 = new Map(props$0);
    let exit$2 = -1;
    let match_arg$3 = arg_match$2[0];
    let match_arg$4 = match_arg$3.get("tag");
    if (match_arg$4 === 0) {
      let match_arg$5 = match_arg$3.get("a");
      props$3.set("a", match_arg$5);
      exit$2 = 0;
    } else {
      if (match_arg$4 === 1) {
        let match_arg$5 = match_arg$3.get("b");
        props$3.set("b", match_arg$5);
        exit$2 = 1;
      }
    }
    if (exit$2 === 0) {
      buffer$0.push(acutis_escape$0(props$3.get("a")));
      buffer$0.push("\n");
    } else {
      buffer$0.push(acutis_escape$0(props$3.get("b").toString()));
      buffer$0.push("\n");
    }
    let arg_match$3 = [props$0.get("tagged_record_int")];
    let props$4 = new Map(props$0);
    let exit$3 = -1;
    let match_arg$5 = arg_match$3[0];
    let match_arg$6 = match_arg$5.get("tag");
    if (match_arg$6 === 0) {
      exit$3 = 0;
    } else {
      if (match_arg$6 === 1) {
        let match_arg$7 = match_arg$5.get("tuple");
        let match_arg$8 = match_arg$7[0];
        let match_arg$9 = match_arg$7[1];
        let match_arg$10 = match_arg$7[2];
        props$4.set("a", match_arg$8);
        props$4.set("b", match_arg$9);
        props$4.set("c", match_arg$10);
        exit$3 = 1;
      }
    }
    if (exit$3 === 0) {
      buffer$0.push("Fail\n");
    } else {
      buffer$0.push(acutis_escape$0(props$4.get("a").toString()));
      buffer$0.push(" ");
      buffer$0.push(acutis_escape$0(props$4.get("b")));
      buffer$0.push(" ");
      buffer$0.push(acutis_escape$0(props$4.get("c") ? "true" : "false"));
      buffer$0.push("\n");
    }
    let arg_match$4 = [props$0.get("tagged_record_open")];
    let props$5 = new Map(props$0);
    let exit$4 = -1;
    let match_arg$7 = arg_match$4[0];
    let match_arg$8 = match_arg$7.get("tag");
    if (match_arg$8 === 200) {
      let match_arg$9 = match_arg$7.get("b");
      props$5.set("b", match_arg$9);
      exit$4 = 0;
    }
    if (exit$4 === -1) { exit$4 = 1; }
    if (exit$4 === 0) {
      buffer$0.push(" ");
      buffer$0.push(acutis_escape$0(props$5.get("b")));
      buffer$0.push("\n");
    } else {
      buffer$0.push("Another tag!\n");
    }
    buffer$0.push("\n\nMapping\n-------\n\n");
    let match_arg$9 = props$0.get("null_string_dict");
    for (let x$0 of match_arg$9) {
      let props$6 = new Map(props$0);
      let exit$5 = -1;
      if (x$0[1] === 0) {
        props$6.set("key", x$0[0]);
        exit$5 = 0;
      } else {
        let match_arg$10 = x$0[1][0];
        props$6.set("key", x$0[0]);
        props$6.set("str", match_arg$10);
        exit$5 = 1;
      }
      if (exit$5 === 0) {
        buffer$0.push(acutis_escape$0(props$6.get("key")));
        buffer$0.push(" is null.\n");
      } else {
        buffer$0.push(acutis_escape$0(props$6.get("key")));
        buffer$0.push(" is ");
        buffer$0.push(acutis_escape$0(props$6.get("str")));
        buffer$0.push("\n");
      }
    }
    let index$0 = 0;
    let cell$0 = props$0.get("int_list");
    while (!(cell$0 === 0)) {
      let props$6 = new Map(props$0);
      let head$0 = cell$0[0];
      let exit$5 = -1;
      props$6.set("i", head$0);
      exit$5 = 0;
      buffer$0.push(acutis_escape$0(props$6.get("i").toString()));
      buffer$0.push("\n");
      index$0++;
      cell$0 = cell$0[1];
    }
    let index$1 = 0;
    let cell$1 = props$0.get("int_list");
    while (!(cell$1 === 0)) {
      let props$6 = new Map(props$0);
      let head$0 = cell$1[0];
      let exit$5 = -1;
      props$6.set("i", head$0);
      props$6.set("key", index$1);
      exit$5 = 0;
      buffer$0.push(acutis_escape$0(props$6.get("key").toString()));
      buffer$0.push(" : ");
      buffer$0.push(acutis_escape$0(props$6.get("i").toString()));
      buffer$0.push("\n");
      index$1++;
      cell$1 = cell$1[1];
    }
    let index$2 = 0;
    let cell$2 = props$0.get("nested_list");
    while (!(cell$2 === 0)) {
      let props$6 = new Map(props$0);
      let head$0 = cell$2[0];
      let exit$5 = -1;
      props$6.set("l", head$0);
      exit$5 = 0;
      let index$3 = 0;
      let cell$3 = props$6.get("l");
      while (!(cell$3 === 0)) {
        let props$7 = new Map(props$6);
        let head$1 = cell$3[0];
        let exit$6 = -1;
        props$7.set("l2", head$1);
        exit$6 = 0;
        let index$4 = 0;
        let cell$4 = props$7.get("l2");
        while (!(cell$4 === 0)) {
          let props$8 = new Map(props$7);
          let head$2 = cell$4[0];
          let exit$7 = -1;
          props$8.set("i", head$2);
          exit$7 = 0;
          buffer$0.push(acutis_escape$0(props$8.get("i").toString()));
          buffer$0.push(" ");
          index$4++;
          cell$4 = cell$4[1];
        }
        index$3++;
        cell$3 = cell$3[1];
      }
      index$2++;
      cell$2 = cell$2[1];
    }
    buffer$0.push("\n\n");
    let index$3 = 0;
    let cell$3 = props$0.get("nested_nullable_list");
    while (!(cell$3 === 0)) {
      let props$6 = new Map(props$0);
      let head$0 = cell$3[0];
      let exit$5 = -1;
      if (head$0 === 0) {
        exit$5 = 0;
      } else {
        let match_arg$10 = head$0[0];
        if (match_arg$10 === 0) {
          exit$5 = 1;
        } else {
          let match_arg$11 = head$0[0];
          let match_arg$12 = match_arg$11[0];
          props$6.set("b", match_arg$12);
          exit$5 = 2;
        }
      }
      if (exit$5 === 0) {
        buffer$0.push("Level 1 null\n");
      } else {
        if (exit$5 === 1) {
          buffer$0.push("Level 2 null (This shouldn't render.)\n");
        } else {
          buffer$0.push("Level 3 ");
          buffer$0.push(acutis_escape$0(props$6.get("b") ? "true" : "false"));
          buffer$0.push("\n");
        }
      }
      index$3++;
      cell$3 = cell$3[1];
    }
    buffer$0.push(
      "\n\
  \n\
  Dictionaries match correctly\n\
  ----------------------------\n\
  \n\
  "
    );
    let arg_match$5 = [props$0.get("null_string_dict")];
    let props$6 = new Map(props$0);
    let exit$5 = -1;
    let match_arg$10 = arg_match$5[0];
    if (match_arg$10.has("a")) {
      let match_arg$11 = match_arg$10.get("a");
      if (match_arg$11 === 0) {
        if (match_arg$10.has("does_not_exist")) {
          let match_arg$12 = match_arg$10.get("does_not_exist");
          exit$5 = 1;
        }
        if (exit$5 === -1) { exit$5 = 1; }
      } else {
        let match_arg$12 = match_arg$10.get("a");
        let match_arg$13 = match_arg$12[0];
        if (match_arg$13 === "a") {
          if (match_arg$10.has("does_not_exist")) {
            let match_arg$14 = match_arg$10.get("does_not_exist");
            if (match_arg$14 === 0) {
              exit$5 = 2;
            } else {
              let match_arg$15 = match_arg$10.get("does_not_exist");
              let match_arg$16 = match_arg$15[0];
              props$6.set("a", match_arg$13);
              props$6.set("b", match_arg$16);
              exit$5 = 0;
              if (exit$5 === -1) { exit$5 = 2; }
            }
          }
          if (exit$5 === -1) { exit$5 = 2; }
        } else {
          if (match_arg$10.has("does_not_exist")) {
            let match_arg$14 = match_arg$10.get("does_not_exist");
            if (!(match_arg$14 === 0)) {
              let match_arg$15 = match_arg$10.get("does_not_exist");
              let match_arg$16 = match_arg$15[0];
              props$6.set("a", match_arg$13);
              props$6.set("b", match_arg$16);
              exit$5 = 0;
            }
          }
        }
      }
    }
    if (exit$5 === -1) { exit$5 = 3; }
    if (exit$5 === 0) {
      buffer$0.push(" ");
      buffer$0.push(acutis_escape$0(props$6.get("a")));
      buffer$0.push(" ");
      buffer$0.push(acutis_escape$0(props$6.get("b")));
      buffer$0.push("\n");
    } else {
      if (exit$5 === 1) {
        buffer$0.push(" Fail.\n");
      } else {
        if (exit$5 === 2) {
          buffer$0.push(" Pass.\n");
        } else {
          buffer$0.push(" Fail.\n");
        }
      }
    }
    let arg_match$6 = [new Map([["a", "a"]])];
    let props$7 = new Map(props$0);
    let exit$6 = -1;
    let match_arg$11 = arg_match$6[0];
    if (match_arg$11.has("a")) {
      let match_arg$12 = match_arg$11.get("a");
      if (match_arg$12 === "") {
        if (match_arg$11.has("does_not_exist")) {
          let match_arg$13 = match_arg$11.get("does_not_exist");
          props$7.set("a", match_arg$12);
          props$7.set("b", match_arg$13);
          exit$6 = 0;
        }
        if (exit$6 === -1) { exit$6 = 1; }
      } else {
        if (match_arg$12 === "a") {
          if (match_arg$11.has("does_not_exist")) {
            let match_arg$13 = match_arg$11.get("does_not_exist");
            props$7.set("a", match_arg$12);
            props$7.set("b", match_arg$13);
            exit$6 = 0;
          }
          if (exit$6 === -1) { exit$6 = 2; }
        } else {
          if (match_arg$11.has("does_not_exist")) {
            let match_arg$13 = match_arg$11.get("does_not_exist");
            props$7.set("a", match_arg$12);
            props$7.set("b", match_arg$13);
            exit$6 = 0;
          }
        }
      }
    }
    if (exit$6 === -1) { exit$6 = 3; }
    if (exit$6 === 0) {
      buffer$0.push(" Fail. ");
      buffer$0.push(acutis_escape$0(props$7.get("a")));
      buffer$0.push(" ");
      buffer$0.push(acutis_escape$0(props$7.get("b")));
      buffer$0.push("\n");
    } else {
      if (exit$6 === 1) {
        buffer$0.push(" Fail.\n");
      } else {
        if (exit$6 === 2) {
          buffer$0.push(" Pass.\n");
        } else {
          buffer$0.push(" Fail.\n");
        }
      }
    }
    buffer$0.push(
      "\n\nConstructing async blocks\n-------------------------\n\n"
    );
    let blocks$0 =
      Array.from({length: 2}, (arg$1) => { return (Promise.resolve("")); });
    let buffer$1 = [];
    buffer$1.push(" Nested block ");
    let nullable$1 = props$0.get("null_string");
    if (!(nullable$1 === 0)) {
      buffer$1.push(acutis_escape$0(nullable$1[0]));
    } else {
      buffer$1.push(acutis_escape$0("pass"));
    }
    blocks$0[0] = buffer_to_promise$0(buffer$1);
    let buffer$2 = [];
    buffer$2.push(" Another nested block");
    blocks$0[1] = buffer_to_promise$0(buffer$2);
    buffer$0.push(
      Promise.all(blocks$0).then(
        (arg$1) => {
          let buffer$3 = [];
          let arg_match$7 = [new Map([["a", arg$1[0]], ["b", arg$1[1]]])];
          let props$8 = new Map(props$0);
          let exit$7 = -1;
          let match_arg$12 = arg_match$7[0];
          let match_arg$13 = match_arg$12.get("a");
          let match_arg$14 = match_arg$12.get("b");
          props$8.set("a", match_arg$13);
          props$8.set("b", match_arg$14);
          exit$7 = 0;
          buffer$3.push(acutis_escape$0(props$8.get("a")));
          buffer$3.push(" ");
          buffer$3.push(acutis_escape$0(props$8.get("b")));
          buffer$3.push("\n");
          return (buffer_to_promise$0(buffer$3));
        }
      )
    );
    buffer$0.push("Component\n---------\n\n");
    let blocks$1 =
      Array.from({length: 1}, (arg$1) => { return (Promise.resolve("")); });
    let buffer$3 = [];
    buffer$3.push("Children prop");
    blocks$1[0] = buffer_to_promise$0(buffer$3);
    buffer$0.push(
      Promise.all(blocks$1).then(
        (arg$1) => {
          let buffer$4 = [];
          buffer$4.push(
            components$0.get("Component")(
              new Map(
                [
                  ["children", arg$1[0]],
                  ["list", [1, [2, [3, 0]]]],
                  ["optional", 0],
                ]
              )
            )
          );
          return (buffer_to_promise$0(buffer$4));
        }
      )
    );
    buffer$0.push("\n\n");
    buffer$0.push(components$0.get("Another_function")(new Map([])));
    buffer$0.push(
      "\n\
  \n\
  Complicated pattern matching\n\
  ----------------------------\n\
  \n\
  "
    );
    let arg_match$7 = [1, 0, 3];
    let props$8 = new Map(props$0);
    let exit$7 = -1;
    let match_arg$12 = arg_match$7[0];
    if (match_arg$12 === 1) {
      let match_arg$13 = arg_match$7[1];
      if (match_arg$13 === 0) {
        let match_arg$14 = arg_match$7[2];
        if (match_arg$14 === 0) {
          exit$7 = 0;
        } else {
          props$8.set("y", match_arg$14);
          exit$7 = 2;
        }
      } else {
        let match_arg$14 = arg_match$7[1];
        let match_arg$15 = match_arg$14[0];
        if (match_arg$15 === 1) {
          let match_arg$16 = arg_match$7[2];
          if (match_arg$16 === 0) {
            exit$7 = 0;
          } else {
            if (match_arg$16 === 1) { exit$7 = 3; } else { exit$7 = 4; }
          }
        }
        if (exit$7 === -1) {
          let match_arg$16 = arg_match$7[2];
          if (match_arg$16 === 0) { exit$7 = 0; } else { exit$7 = 4; }
        }
      }
    } else {
      let match_arg$13 = arg_match$7[1];
      if (match_arg$13 === 0) {
        let match_arg$14 = arg_match$7[2];
        props$8.set("y", match_arg$14);
        exit$7 = 2;
      } else {
        let match_arg$14 = arg_match$7[1];
        let match_arg$15 = match_arg$14[0];
        if (match_arg$15 === 1) {
          let match_arg$16 = arg_match$7[2];
          if (match_arg$16 === 0) {
            props$8.set("x", match_arg$12);
            exit$7 = 1;
          } else {
            exit$7 = 4;
          }
        }
        if (exit$7 === -1) { let match_arg$16 = arg_match$7[2]; exit$7 = 4; }
      }
    }
    if (exit$7 === 0) {
      buffer$0.push(" 0\n");
    } else {
      if (exit$7 === 1) {
        buffer$0.push(" 1 ");
        buffer$0.push(acutis_escape$0(props$8.get("x").toString()));
        buffer$0.push("\n");
      } else {
        if (exit$7 === 2) {
          buffer$0.push(" 2 ");
          buffer$0.push(acutis_escape$0(props$8.get("y").toString()));
          buffer$0.push("\n");
        } else {
          if (exit$7 === 3) {
            buffer$0.push(" 3\n");
          } else {
            buffer$0.push(" 4\n");
          }
        }
      }
    }
    let arg_match$8 = [[[10, 20], 30], 40];
    let props$9 = new Map(props$0);
    let exit$8 = -1;
    let match_arg$13 = arg_match$8[0];
    let match_arg$14 = match_arg$13[0];
    let match_arg$15 = match_arg$14[0];
    if (match_arg$15 === 10) {
      let match_arg$16 = match_arg$14[1];
      if (match_arg$16 === 20) {
        let match_arg$17 = match_arg$13[1];
        if (match_arg$17 === 30) {
          let match_arg$18 = arg_match$8[1];
          if (match_arg$18 === 40) {
            exit$8 = 1;
          } else {
            if (match_arg$18 === 41) {
              props$9.set("_x", match_arg$13);
              exit$8 = 0;
            } else {
              props$9.set("_y", match_arg$13);
              props$9.set("z", match_arg$18);
              exit$8 = 2;
            }
          }
        }
      }
    }
    if (exit$8 === -1) {
      let match_arg$16 = arg_match$8[1];
      if (match_arg$16 === 41) {
        props$9.set("_x", match_arg$13);
        exit$8 = 0;
      } else {
        props$9.set("_y", match_arg$13);
        props$9.set("z", match_arg$16);
        exit$8 = 2;
      }
    }
    if (exit$8 === 0) {
      buffer$0.push("\n");
    } else {
      if (exit$8 === 1) {
        buffer$0.push(" Pass\n");
      } else {
        buffer$0.push(" ");
        buffer$0.push(acutis_escape$0(props$9.get("z").toString()));
        buffer$0.push("\n");
      }
    }
    let arg_match$9 = [[[10, 20], 99], 40];
    let props$10 = new Map(props$0);
    let exit$9 = -1;
    let match_arg$16 = arg_match$9[0];
    let match_arg$17 = match_arg$16[0];
    let match_arg$18 = match_arg$17[0];
    if (match_arg$18 === 10) {
      let match_arg$19 = match_arg$17[1];
      if (match_arg$19 === 20) {
        let match_arg$20 = match_arg$16[1];
        if (match_arg$20 === 30) {
          let match_arg$21 = arg_match$9[1];
          if (match_arg$21 === 40) {
            exit$9 = 1;
          } else {
            if (match_arg$21 === 41) {
              props$10.set("_x", match_arg$16);
              exit$9 = 0;
            } else {
              props$10.set("_y", match_arg$16);
              props$10.set("z", match_arg$21);
              exit$9 = 2;
            }
          }
        }
      }
    }
    if (exit$9 === -1) {
      let match_arg$19 = arg_match$9[1];
      if (match_arg$19 === 41) {
        props$10.set("_x", match_arg$16);
        exit$9 = 0;
      } else {
        props$10.set("_y", match_arg$16);
        props$10.set("z", match_arg$19);
        exit$9 = 2;
      }
    }
    if (exit$9 === 0) {
      buffer$0.push("\n");
    } else {
      if (exit$9 === 1) {
        buffer$0.push(" Fail\n");
      } else {
        buffer$0.push(" ");
        buffer$0.push(acutis_escape$0(props$10.get("z").toString()));
        buffer$0.push("\n");
      }
    }
    buffer$0.push(
      "String encoding\n\
  ---------------\n\
  \n\
  😇👨‍💻😇\n\
  \\\" \\ \\ \\\"\n\
  \n\
  "
    );
    buffer$0.push(acutis_escape$0(props$0.get("unicode_string")));
    buffer$0.push(
      "\n\
  \n\
  External JavaScript template component: stringify arbitrary data\n\
  \n\
  "
    );
    buffer$0.push(
      components$0.get("Stringify")(
        new Map(
          [
            ["int_list", props$0.get("int_list")],
            ["nested_list", props$0.get("nested_list")],
            ["nested_nullable_list", props$0.get("nested_nullable_list")],
            ["null_string_dict", props$0.get("null_string_dict")],
            ["record", props$0.get("record")],
            ["tagged_record_bool", props$0.get("tagged_record_bool")],
            ["tagged_record_int", props$0.get("tagged_record_int")],
            ["tagged_record_open", props$0.get("tagged_record_open")],
            ["tagged_record_string", props$0.get("tagged_record_string")],
            ["unknown", props$0.get("unknown")],
          ]
        )
      )
    );
    buffer$0.push("\n");
    return (buffer_to_promise$0(buffer$0));
  };

  $ cat > run.mjs << EOF
  >   import main from "./compiled.mjs";
  >   let result = await main({
  >     big_int: 100_000_000,
  >     big_float: 1234.56789,
  >     bool1: true,
  >     bool2: false,
  >     dangerous: "&\"'></\`=",
  >     record: { int_enum: 8, string_enum: "yes" },
  >     tagged_record_bool: { tag: false, a: "a" },
  >     null_string_dict: { a: "a", b: null },
  >     int_list: [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5],
  >     tagged_record_int: { tag: 1, tuple: [1.5, "snd", true] },
  >     tagged_record_string: {
  >       tag: "a",
  >       record_list: [{ name: "John", job: "librarian" }],
  >     },
  >     tagged_record_open: {
  >       tag: 999,
  >       b: "200",
  >     },
  >     unknown: new Date("2023-04-09T00:00:00.000Z"),
  >     nested_list: [
  >       [
  >         [1, 1, 1],
  >         [2, 2, 2],
  >       ],
  >       [[3, 3, 3]],
  >     ],
  >     nested_nullable_list: [null, true, false, null],
  >     null_int: null,
  >     null_float: null,
  >     null_bool: null,
  >     null_string: null,
  >     unicode_string: "👩‍🌾",
  >   });
  >   process.stdout.write(result);
  > EOF

  $ node run.mjs
  Formatters
  ----------
  
  %i    100000000
  %f    1234.56789
  %b    true
  %b    false
  
  Escaping
  --------
  
  Escaped     &amp;&quot;&apos;&gt;&lt;&#x2F;&#x60;&#x3D;
  Not escaped &"'></`=
  
  Nullable echo chaining
  ----------------------
  
  pass
  
  Matching
  --------
  
  8
  yes
  a
  1.5 snd true
  Another tag!
  
  
  Mapping
  -------
  
  a is a
  b is null.
  -5
  -4
  -3
  -2
  -1
  0
  1
  2
  3
  4
  5
  0 : -5
  1 : -4
  2 : -3
  3 : -2
  4 : -1
  5 : 0
  6 : 1
  7 : 2
  8 : 3
  9 : 4
  10 : 5
  1 1 1 2 2 2 3 3 3 
  
  Level 1 null
  Level 3 true
  Level 3 false
  Level 1 null
  
  
  Dictionaries match correctly
  ----------------------------
  
   Pass.
   Pass.
  
  
  Constructing async blocks
  -------------------------
  
   Nested block pass  Another nested block
  Component
  ---------
  
  Children prop
  123
  
  success
  
  Complicated pattern matching
  ----------------------------
  
   2 3
   Pass
   40
  String encoding
  ---------------
  
  😇👨‍💻😇
  \" \ \ \"
  
  👩‍🌾
  
  External JavaScript template component: stringify arbitrary data
  
  {
    "int_list": [
      -5,
      -4,
      -3,
      -2,
      -1,
      0,
      1,
      2,
      3,
      4,
      5
    ],
    "nested_list": [
      [
        [
          1,
          1,
          1
        ],
        [
          2,
          2,
          2
        ]
      ],
      [
        [
          3,
          3,
          3
        ]
      ]
    ],
    "nested_nullable_list": [
      null,
      true,
      false,
      null
    ],
    "null_string_dict": {
      "a": "a",
      "b": null
    },
    "record": {
      "int_enum": 8,
      "string_enum": "yes"
    },
    "tagged_record_bool": {
      "tag": false,
      "a": "a"
    },
    "tagged_record_int": {
      "tag": 1,
      "tuple": [
        1.5,
        "snd",
        true
      ]
    },
    "tagged_record_open": {
      "tag": 999
    },
    "tagged_record_string": {
      "tag": "a",
      "record_list": [
        {
          "job": "librarian",
          "name": "John"
        }
      ]
    },
    "unknown": "2023-04-09T00:00:00.000Z"
  }

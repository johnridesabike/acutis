  $ acutis \
  >   --mode js \
  >   template.acutis \
  >   component.acutis \
  >   nestedComponent.acutis \
  >   unused.acutis \
  >   --fun ./jscomponents.mjs stringify "$(cat stringify_interface)" \
  >   --fun ./jscomponents.mjs another_function "" \
  >   --fun ./jscomponents.mjs an_unused_function "" \
  >   > compiled.mjs

  $ cat compiled.mjs
  /* THIS FILE WAS GENERATED BY ACUTIS. */
  let buffer_add_escape$0 =
    (arg$0) => {
      return (
        (arg$1) => {
          for (let item$0 of arg$1[Symbol.iterator]()) {
            switch (item$0) {
              case "&": arg$0.contents += "&amp;"; break;
              case "\"": arg$0.contents += "&quot;"; break;
              case "'": arg$0.contents += "&apos;"; break;
              case ">": arg$0.contents += "&gt;"; break;
              case "<": arg$0.contents += "&lt;"; break;
              case "/": arg$0.contents += "&sol;"; break;
              case "`": arg$0.contents += "&grave;"; break;
              case "=": arg$0.contents += "&equals;"; break;
              default: arg$0.contents += item$0;
            }
          }
        }
      );
    };
  let buffer_add_sep$0 =
    (arg$0) => {
      return (
        (arg$1) => {
          return (
            (arg$2) => {
              if (!(arg$0.contents.length === 0)) { arg$0.contents += arg$1; }
              arg$0.contents += arg$2;
            }
          );
        }
      );
    };
  let stack_empty$0 = (arg$0) => {  };
  let stack_is_empty$0 =
    (arg$0) => {
      let result$0 = true;
      arg$0((arg$1) => { result$0 = false; });
      return (result$0);
    };
  let stack_add$0 =
    (arg$0) => {
      return (
        (arg$1) => {
          return ((arg$2) => { arg$1(arg$2); return (arg$2(arg$0)); });
        }
      );
    };
  import {"stringify" as import$0} from "./jscomponents.mjs";
  let Stringify$0 =
    (arg$0) => {
      let seq$0 =
        (function* () {
          let seq$1 =
            (function* () {
              let cell$0 = arg$0.get("int_list");
              while (!(cell$0 === 0)) {
                let props$0 = cell$0[0];
                cell$0 = cell$0[1];
                yield (props$0);
              }
            })();
          yield (["int_list", Array.from(seq$1)]);
          let seq$2 =
            (function* () {
              let cell$0 = arg$0.get("nested_list");
              while (!(cell$0 === 0)) {
                let props$0 = cell$0[0];
                cell$0 = cell$0[1];
                let seq$3 =
                  (function* () {
                    let cell$1 = props$0;
                    while (!(cell$1 === 0)) {
                      let props$1 = cell$1[0];
                      cell$1 = cell$1[1];
                      let seq$4 =
                        (function* () {
                          let cell$2 = props$1;
                          while (!(cell$2 === 0)) {
                            let props$2 = cell$2[0];
                            cell$2 = cell$2[1];
                            yield (props$2);
                          }
                        })();
                      yield (Array.from(seq$4));
                    }
                  })();
                yield (Array.from(seq$3));
              }
            })();
          yield (["nested_list", Array.from(seq$2)]);
          let seq$3 =
            (function* () {
              let cell$0 = arg$0.get("nested_nullable_list");
              while (!(cell$0 === 0)) {
                let props$0 = cell$0[0];
                cell$0 = cell$0[1];
                if (props$0 === 0) {
                  yield (null);
                } else {
                  let props$1 = props$0[0];
                  if (props$1 === 0) {
                    yield (null);
                  } else {
                    let props$2 = props$1[0];
                    yield (!(props$2 === 0));
                  }
                }
              }
            })();
          yield (["nested_nullable_list", Array.from(seq$3)]);
          let seq$4 =
            (function* () {
              for (let item$0 of arg$0.get("null_string_dict").entries()) {
                if (item$0[1] === 0) {
                  yield ([item$0[0], null]);
                } else {
                  let props$0 = item$0[1][0];
                  yield ([item$0[0], props$0]);
                }
              }
            })();
          yield (["null_string_dict", Object.fromEntries(seq$4)]);
          let seq$5 =
            (function* () {
              yield (["int_enum", arg$0.get("record").get("int_enum")]);
              yield (["string_enum", arg$0.get("record").get("string_enum")]);
            })();
          yield (["record", Object.fromEntries(seq$5)]);
          let props$0 = arg$0.get("tagged_record_bool");
          let tag$0 = props$0.get("tag");
          if (tag$0 === 0) {
            let seq$6 =
              (function* () {
                yield (["tag", !(tag$0 === 0)]);
                yield (["a", props$0.get("a")]);
              })();
            yield (["tagged_record_bool", Object.fromEntries(seq$6)]);
          } else {
            if (tag$0 === 1) {
              let seq$6 =
                (function* () {
                  yield (["tag", !(tag$0 === 0)]);
                  yield (["b", props$0.get("b")]);
                })();
              yield (["tagged_record_bool", Object.fromEntries(seq$6)]);
            } else {
              let seq$6 = (function* () {  })();
              yield (["tagged_record_bool", Object.fromEntries(seq$6)]);
            }
          }
          let props$1 = arg$0.get("tagged_record_int");
          let tag$1 = props$1.get("tag");
          if (tag$1 === 0) {
            let seq$6 = (function* () { yield (["tag", tag$1]); })();
            yield (["tagged_record_int", Object.fromEntries(seq$6)]);
          } else {
            if (tag$1 === 1) {
              let seq$6 =
                (function* () {
                  yield (["tag", tag$1]);
                  let props$2 = props$1.get("tuple");
                  let seq$7 =
                    (function* () {
                      yield (props$2[0]);
                      yield (props$2[1]);
                      yield (!(props$2[2] === 0));
                    })();
                  yield (["tuple", Array.from(seq$7)]);
                })();
              yield (["tagged_record_int", Object.fromEntries(seq$6)]);
            } else {
              let seq$6 = (function* () {  })();
              yield (["tagged_record_int", Object.fromEntries(seq$6)]);
            }
          }
          let props$2 = arg$0.get("tagged_record_open");
          let tag$2 = props$2.get("tag");
          if (tag$2 === 100) {
            let seq$6 =
              (function* () {
                yield (["tag", tag$2]);
                yield (["a", props$2.get("a")]);
              })();
            yield (["tagged_record_open", Object.fromEntries(seq$6)]);
          } else {
            if (tag$2 === 200) {
              let seq$6 =
                (function* () {
                  yield (["tag", tag$2]);
                  yield (["b", props$2.get("b")]);
                })();
              yield (["tagged_record_open", Object.fromEntries(seq$6)]);
            } else {
              if (tag$2 === 300) {
                let seq$6 =
                  (function* () {
                    yield (["tag", tag$2]);
                    yield (["c", props$2.get("c")]);
                  })();
                yield (["tagged_record_open", Object.fromEntries(seq$6)]);
              } else {
                let seq$6 = (function* () { yield (["tag", tag$2]); })();
                yield (["tagged_record_open", Object.fromEntries(seq$6)]);
              }
            }
          }
          let props$3 = arg$0.get("tagged_record_string");
          let tag$3 = props$3.get("tag");
          if (tag$3 === "a") {
            let seq$6 =
              (function* () {
                yield (["tag", tag$3]);
                let seq$7 =
                  (function* () {
                    let cell$0 = props$3.get("record_list");
                    while (!(cell$0 === 0)) {
                      let props$4 = cell$0[0];
                      cell$0 = cell$0[1];
                      let seq$8 =
                        (function* () {
                          yield (["job", props$4.get("job")]);
                          yield (["name", props$4.get("name")]);
                        })();
                      yield (Object.fromEntries(seq$8));
                    }
                  })();
                yield (["record_list", Array.from(seq$7)]);
              })();
            yield (["tagged_record_string", Object.fromEntries(seq$6)]);
          } else {
            if (tag$3 === "b") {
              let seq$6 =
                (function* () {
                  yield (["tag", tag$3]);
                  yield (["open_enum", props$3.get("open_enum")]);
                })();
              yield (["tagged_record_string", Object.fromEntries(seq$6)]);
            } else {
              let seq$6 = (function* () {  })();
              yield (["tagged_record_string", Object.fromEntries(seq$6)]);
            }
          }
          yield (["unknown", arg$0.get("unknown")]);
        })();
      return (import$0(Object.fromEntries(seq$0)));
    };
  import {"another_function" as import$1} from "./jscomponents.mjs";
  let Another_function$0 =
    (arg$0) => {
      let seq$0 = (function* () {  })();
      return (import$1(Object.fromEntries(seq$0)));
    };
  let NestedComponent$0 =
    async (arg$0) => {
      let buf$0 = {contents: ""};
      buf$0.contents += "Nested component\n";
      return (Promise.resolve(buf$0.contents));
    };
  let Component$0 =
    async (arg$0) => {
      let buf$0 = {contents: ""};
      let nullable$0 = arg$0.get("optional");
      if (!(nullable$0 === 0)) {
        buffer_add_escape$0(buf$0)(String(nullable$0[0]));
      } else {
        buffer_add_escape$0(buf$0)(arg$0.get("children"));
      }
      buf$0.contents += "\n";
      let index$0 = 0;
      let cell$0 = arg$0.get("list");
      while (!(cell$0 === 0)) {
        let match_props$0 = new Map();
        let head$0 = cell$0[0];
        let exit$0 = -1;
        match_props$0.set("i", head$0);
        exit$0 = 0;
        buffer_add_escape$0(buf$0)(String(match_props$0.get("i")));
        index$0++;
        cell$0 = cell$0[1];
      }
      buf$0.contents += "\n";
      buf$0.contents += await NestedComponent$0(new Map([]));
      return (Promise.resolve(buf$0.contents));
    };
  export default async (arg$0) => {
    let errors$0 = {contents: ""};
    let error_aux$0 =
      (arg$1) => {
        return (
          (arg$2) => {
            return (
              (arg$3) => {
                return (
                  (arg$4) => {
                    if (!(errors$0.contents.length === 0)) {
                      errors$0.contents += "\n\n";
                    }
                    errors$0.contents += "File \"";
                    errors$0.contents += "template.acutis";
                    errors$0.contents +=
                      "\"\n\
  Render error.\n\
  The data supplied does not match this template's interface.\n\
  ";
                    errors$0.contents += "Path:\n<input>";
                    arg$3(buffer_add_sep$0(errors$0)(" -> "));
                    errors$0.contents += "\nExpected type:\n";
                    errors$0.contents += arg$4;
                    errors$0.contents += arg$1;
                    errors$0.contents += arg$2;
                  }
                );
              }
            );
          }
        );
      };
    let decode_error$0 =
      (arg$1) => {
        return (error_aux$0("\nReceived value:\n")(String(arg$1)));
      };
    let key_error$0 =
      (arg$1) => {
        let buf$0 = {contents: ""};
        arg$1(buffer_add_sep$0(buf$0)(", "));
        return (error_aux$0("\nInput is missing keys:\n")(buf$0.contents));
      };
    let props$0 = new Map();
    let type$0 =
      "{\n\
    big_float: float,\n\
    big_int: int,\n\
    bool1: false | true,\n\
    bool2: false | true,\n\
    dangerous: string,\n\
    int_list: [int],\n\
    nested_list: [[[int]]],\n\
    nested_nullable_list: [??false | true],\n\
    null_bool: ?false | true,\n\
    null_float: ?float,\n\
    null_int: ?int,\n\
    null_string: ?string,\n\
    null_string_dict: <?string>,\n\
    record: {int_enum: @8 | @40, string_enum: @\"no\" | @\"yes\"},\n\
    tagged_record_bool: {@tag: false, a: string} | {@tag: true, b: int},\n\
    tagged_record_int:\n\
      {@tag: 0} | {@tag: 1, tuple: (float, string, false | true)},\n\
    tagged_record_open:\n\
      {@tag: 100, a: int} |\n\
      {@tag: 200, b: string} |\n\
      {@tag: 300, c: float} |\n\
      ...,\n\
    tagged_record_string:\n\
      {@tag: \"a\", record_list: [{job: string, name: string}]} |\n\
      {@tag: \"b\", open_enum: @0 | @1 | ...},\n\
    unicode_string: string,\n\
    unknown: _\n\
  }";
    if (typeof arg$0 === "object" && !(arg$0 === null)) {
      let missing_keys$0 = stack_empty$0;
      if (Object.hasOwn(arg$0, "big_float")) {
        let input$0 = arg$0["big_float"];
        let stack$0 = stack_add$0("big_float")(stack_empty$0);
        let type$1 = "float";
        if (typeof input$0 === "number") {
          props$0.set("big_float", input$0);
        } else {
          decode_error$0(input$0)(stack$0)(type$1);
        }
      } else {
        missing_keys$0 = stack_add$0("big_float")(missing_keys$0);
      }
      if (Object.hasOwn(arg$0, "big_int")) {
        let input$0 = arg$0["big_int"];
        let stack$0 = stack_add$0("big_int")(stack_empty$0);
        let type$1 = "int";
        if (Number.isInteger(input$0)) {
          props$0.set("big_int", input$0);
        } else {
          decode_error$0(input$0)(stack$0)(type$1);
        }
      } else {
        missing_keys$0 = stack_add$0("big_int")(missing_keys$0);
      }
      if (Object.hasOwn(arg$0, "bool1")) {
        let input$0 = arg$0["bool1"];
        let stack$0 = stack_add$0("bool1")(stack_empty$0);
        let type$1 = "false | true";
        if (typeof input$0 === "boolean") {
          if (input$0) {
            props$0.set("bool1", 1);
          } else {
            props$0.set("bool1", 0);
          }
        } else {
          decode_error$0(input$0)(stack$0)(type$1);
        }
      } else {
        missing_keys$0 = stack_add$0("bool1")(missing_keys$0);
      }
      if (Object.hasOwn(arg$0, "bool2")) {
        let input$0 = arg$0["bool2"];
        let stack$0 = stack_add$0("bool2")(stack_empty$0);
        let type$1 = "false | true";
        if (typeof input$0 === "boolean") {
          if (input$0) {
            props$0.set("bool2", 1);
          } else {
            props$0.set("bool2", 0);
          }
        } else {
          decode_error$0(input$0)(stack$0)(type$1);
        }
      } else {
        missing_keys$0 = stack_add$0("bool2")(missing_keys$0);
      }
      if (Object.hasOwn(arg$0, "dangerous")) {
        let input$0 = arg$0["dangerous"];
        let stack$0 = stack_add$0("dangerous")(stack_empty$0);
        let type$1 = "string";
        if (typeof input$0 === "string") {
          props$0.set("dangerous", input$0);
        } else {
          decode_error$0(input$0)(stack$0)(type$1);
        }
      } else {
        missing_keys$0 = stack_add$0("dangerous")(missing_keys$0);
      }
      if (Object.hasOwn(arg$0, "int_list")) {
        let input$0 = arg$0["int_list"];
        let stack$0 = stack_add$0("int_list")(stack_empty$0);
        let type$1 = "[int]";
        if (Array.isArray(input$0)) {
          let seq$0 = input$0.values();
          let index$0 = 0;
          let decoded$0 = [0, 0];
          let decode_dst$0 = decoded$0;
          for (let item$0 of seq$0) {
            let decode_dst_new$0 = [0, 0];
            let stack$1 = stack_add$0(String(index$0))(stack$0);
            let type$2 = "int";
            if (Number.isInteger(item$0)) {
              decode_dst_new$0[0] = item$0;
            } else {
              decode_error$0(item$0)(stack$1)(type$2);
            }
            decode_dst$0[1] = decode_dst_new$0;
            index$0++;
            decode_dst$0 = decode_dst_new$0;
          }
          props$0.set("int_list", decoded$0[1]);
        } else {
          decode_error$0(input$0)(stack$0)(type$1);
        }
      } else {
        missing_keys$0 = stack_add$0("int_list")(missing_keys$0);
      }
      if (Object.hasOwn(arg$0, "nested_list")) {
        let input$0 = arg$0["nested_list"];
        let stack$0 = stack_add$0("nested_list")(stack_empty$0);
        let type$1 = "[[[int]]]";
        if (Array.isArray(input$0)) {
          let seq$0 = input$0.values();
          let index$0 = 0;
          let decoded$0 = [0, 0];
          let decode_dst$0 = decoded$0;
          for (let item$0 of seq$0) {
            let decode_dst_new$0 = [0, 0];
            let stack$1 = stack_add$0(String(index$0))(stack$0);
            let type$2 = "[[int]]";
            if (Array.isArray(item$0)) {
              let seq$1 = item$0.values();
              let index$1 = 0;
              let decoded$1 = [0, 0];
              let decode_dst$1 = decoded$1;
              for (let item$1 of seq$1) {
                let decode_dst_new$1 = [0, 0];
                let stack$2 = stack_add$0(String(index$1))(stack$1);
                let type$3 = "[int]";
                if (Array.isArray(item$1)) {
                  let seq$2 = item$1.values();
                  let index$2 = 0;
                  let decoded$2 = [0, 0];
                  let decode_dst$2 = decoded$2;
                  for (let item$2 of seq$2) {
                    let decode_dst_new$2 = [0, 0];
                    let stack$3 = stack_add$0(String(index$2))(stack$2);
                    let type$4 = "int";
                    if (Number.isInteger(item$2)) {
                      decode_dst_new$2[0] = item$2;
                    } else {
                      decode_error$0(item$2)(stack$3)(type$4);
                    }
                    decode_dst$2[1] = decode_dst_new$2;
                    index$2++;
                    decode_dst$2 = decode_dst_new$2;
                  }
                  decode_dst_new$1[0] = decoded$2[1];
                } else {
                  decode_error$0(item$1)(stack$2)(type$3);
                }
                decode_dst$1[1] = decode_dst_new$1;
                index$1++;
                decode_dst$1 = decode_dst_new$1;
              }
              decode_dst_new$0[0] = decoded$1[1];
            } else {
              decode_error$0(item$0)(stack$1)(type$2);
            }
            decode_dst$0[1] = decode_dst_new$0;
            index$0++;
            decode_dst$0 = decode_dst_new$0;
          }
          props$0.set("nested_list", decoded$0[1]);
        } else {
          decode_error$0(input$0)(stack$0)(type$1);
        }
      } else {
        missing_keys$0 = stack_add$0("nested_list")(missing_keys$0);
      }
      if (Object.hasOwn(arg$0, "nested_nullable_list")) {
        let input$0 = arg$0["nested_nullable_list"];
        let stack$0 = stack_add$0("nested_nullable_list")(stack_empty$0);
        let type$1 = "[??false | true]";
        if (Array.isArray(input$0)) {
          let seq$0 = input$0.values();
          let index$0 = 0;
          let decoded$0 = [0, 0];
          let decode_dst$0 = decoded$0;
          for (let item$0 of seq$0) {
            let decode_dst_new$0 = [0, 0];
            let stack$1 = stack_add$0(String(index$0))(stack$0);
            let type$2 = "??false | true";
            if (!(item$0 === null) && !(item$0 === undefined)) {
              let decoded$1 = [0];
              let stack$2 = stack_add$0("<nullable>")(stack$1);
              let type$3 = "?false | true";
              if (!(item$0 === null) && !(item$0 === undefined)) {
                let decoded$2 = [0];
                let stack$3 = stack_add$0("<nullable>")(stack$2);
                let type$4 = "false | true";
                if (typeof item$0 === "boolean") {
                  if (item$0) { decoded$2[0] = 1; } else { decoded$2[0] = 0; }
                } else {
                  decode_error$0(item$0)(stack$3)(type$4);
                }
                decoded$1[0] = decoded$2;
              } else {
                decoded$1[0] = 0;
              }
              decode_dst_new$0[0] = decoded$1;
            } else {
              decode_dst_new$0[0] = 0;
            }
            decode_dst$0[1] = decode_dst_new$0;
            index$0++;
            decode_dst$0 = decode_dst_new$0;
          }
          props$0.set("nested_nullable_list", decoded$0[1]);
        } else {
          decode_error$0(input$0)(stack$0)(type$1);
        }
      } else {
        missing_keys$0 = stack_add$0("nested_nullable_list")(missing_keys$0);
      }
      if (Object.hasOwn(arg$0, "null_bool")) {
        let input$0 = arg$0["null_bool"];
        let stack$0 = stack_add$0("null_bool")(stack_empty$0);
        let type$1 = "?false | true";
        if (!(input$0 === null) && !(input$0 === undefined)) {
          let decoded$0 = [0];
          let stack$1 = stack_add$0("<nullable>")(stack$0);
          let type$2 = "false | true";
          if (typeof input$0 === "boolean") {
            if (input$0) { decoded$0[0] = 1; } else { decoded$0[0] = 0; }
          } else {
            decode_error$0(input$0)(stack$1)(type$2);
          }
          props$0.set("null_bool", decoded$0);
        } else {
          props$0.set("null_bool", 0);
        }
      } else {
        props$0.set("null_bool", 0);
      }
      if (Object.hasOwn(arg$0, "null_float")) {
        let input$0 = arg$0["null_float"];
        let stack$0 = stack_add$0("null_float")(stack_empty$0);
        let type$1 = "?float";
        if (!(input$0 === null) && !(input$0 === undefined)) {
          let decoded$0 = [0];
          let stack$1 = stack_add$0("<nullable>")(stack$0);
          let type$2 = "float";
          if (typeof input$0 === "number") {
            decoded$0[0] = input$0;
          } else {
            decode_error$0(input$0)(stack$1)(type$2);
          }
          props$0.set("null_float", decoded$0);
        } else {
          props$0.set("null_float", 0);
        }
      } else {
        props$0.set("null_float", 0);
      }
      if (Object.hasOwn(arg$0, "null_int")) {
        let input$0 = arg$0["null_int"];
        let stack$0 = stack_add$0("null_int")(stack_empty$0);
        let type$1 = "?int";
        if (!(input$0 === null) && !(input$0 === undefined)) {
          let decoded$0 = [0];
          let stack$1 = stack_add$0("<nullable>")(stack$0);
          let type$2 = "int";
          if (Number.isInteger(input$0)) {
            decoded$0[0] = input$0;
          } else {
            decode_error$0(input$0)(stack$1)(type$2);
          }
          props$0.set("null_int", decoded$0);
        } else {
          props$0.set("null_int", 0);
        }
      } else {
        props$0.set("null_int", 0);
      }
      if (Object.hasOwn(arg$0, "null_string")) {
        let input$0 = arg$0["null_string"];
        let stack$0 = stack_add$0("null_string")(stack_empty$0);
        let type$1 = "?string";
        if (!(input$0 === null) && !(input$0 === undefined)) {
          let decoded$0 = [0];
          let stack$1 = stack_add$0("<nullable>")(stack$0);
          let type$2 = "string";
          if (typeof input$0 === "string") {
            decoded$0[0] = input$0;
          } else {
            decode_error$0(input$0)(stack$1)(type$2);
          }
          props$0.set("null_string", decoded$0);
        } else {
          props$0.set("null_string", 0);
        }
      } else {
        props$0.set("null_string", 0);
      }
      if (Object.hasOwn(arg$0, "null_string_dict")) {
        let input$0 = arg$0["null_string_dict"];
        let stack$0 = stack_add$0("null_string_dict")(stack_empty$0);
        let type$1 = "<?string>";
        if (typeof input$0 === "object" && !(input$0 === null)) {
          let decoded$0 = new Map();
          for (let item$0 of Object.entries(input$0).values()) {
            let stack$1 = stack_add$0(item$0[0])(stack$0);
            let type$2 = "?string";
            if (!(item$0[1] === null) && !(item$0[1] === undefined)) {
              let decoded$1 = [0];
              let stack$2 = stack_add$0("<nullable>")(stack$1);
              let type$3 = "string";
              if (typeof item$0[1] === "string") {
                decoded$1[0] = item$0[1];
              } else {
                decode_error$0(item$0[1])(stack$2)(type$3);
              }
              decoded$0.set(item$0[0], decoded$1);
            } else {
              decoded$0.set(item$0[0], 0);
            }
            props$0.set("null_string_dict", decoded$0);
          }
        } else {
          decode_error$0(input$0)(stack$0)(type$1);
        }
      } else {
        missing_keys$0 = stack_add$0("null_string_dict")(missing_keys$0);
      }
      if (Object.hasOwn(arg$0, "record")) {
        let input$0 = arg$0["record"];
        let stack$0 = stack_add$0("record")(stack_empty$0);
        let type$1 = "{int_enum: @8 | @40, string_enum: @\"no\" | @\"yes\"}";
        if (typeof input$0 === "object" && !(input$0 === null)) {
          let decoded$0 = new Map();
          let missing_keys$1 = stack_empty$0;
          if (Object.hasOwn(input$0, "int_enum")) {
            let input$1 = input$0["int_enum"];
            let stack$1 = stack_add$0("int_enum")(stack$0);
            let type$2 = "@8 | @40";
            if (Number.isInteger(input$1)) {
              if (input$1 === 8) {
                decoded$0.set("int_enum", input$1);
              } else {
                if (input$1 === 40) {
                  decoded$0.set("int_enum", input$1);
                } else {
                  decode_error$0(input$1)(stack$1)(type$2);
                }
              }
            } else {
              decode_error$0(input$1)(stack$1)(type$2);
            }
          } else {
            missing_keys$1 = stack_add$0("int_enum")(missing_keys$1);
          }
          if (Object.hasOwn(input$0, "string_enum")) {
            let input$1 = input$0["string_enum"];
            let stack$1 = stack_add$0("string_enum")(stack$0);
            let type$2 = "@\"no\" | @\"yes\"";
            if (typeof input$1 === "string") {
              if (input$1 === "no") {
                decoded$0.set("string_enum", input$1);
              } else {
                if (input$1 === "yes") {
                  decoded$0.set("string_enum", input$1);
                } else {
                  decode_error$0(input$1)(stack$1)(type$2);
                }
              }
            } else {
              decode_error$0(input$1)(stack$1)(type$2);
            }
          } else {
            missing_keys$1 = stack_add$0("string_enum")(missing_keys$1);
          }
          if (!(stack_is_empty$0(missing_keys$1))) {
            key_error$0(missing_keys$1)(stack$0)(type$1);
          }
          props$0.set("record", decoded$0);
        } else {
          decode_error$0(input$0)(stack$0)(type$1);
        }
      } else {
        missing_keys$0 = stack_add$0("record")(missing_keys$0);
      }
      if (Object.hasOwn(arg$0, "tagged_record_bool")) {
        let input$0 = arg$0["tagged_record_bool"];
        let stack$0 = stack_add$0("tagged_record_bool")(stack_empty$0);
        let type$1 = "{@tag: false, a: string} | {@tag: true, b: int}";
        if (typeof input$0 === "object" && !(input$0 === null)) {
          if (Object.hasOwn(input$0, "tag")) {
            if (typeof input$0["tag"] === "boolean") {
              let decoded$0 = new Map();
              if (!(input$0["tag"])) {
                decoded$0.set("tag", 0);
                let missing_keys$1 = stack_empty$0;
                if (Object.hasOwn(input$0, "a")) {
                  let input$1 = input$0["a"];
                  let stack$1 = stack_add$0("a")(stack$0);
                  let type$2 = "string";
                  if (typeof input$1 === "string") {
                    decoded$0.set("a", input$1);
                  } else {
                    decode_error$0(input$1)(stack$1)(type$2);
                  }
                } else {
                  missing_keys$1 = stack_add$0("a")(missing_keys$1);
                }
                if (!(stack_is_empty$0(missing_keys$1))) {
                  key_error$0(missing_keys$1)(stack$0)(type$1);
                }
              } else {
                if (input$0["tag"]) {
                  decoded$0.set("tag", 1);
                  let missing_keys$1 = stack_empty$0;
                  if (Object.hasOwn(input$0, "b")) {
                    let input$1 = input$0["b"];
                    let stack$1 = stack_add$0("b")(stack$0);
                    let type$2 = "int";
                    if (Number.isInteger(input$1)) {
                      decoded$0.set("b", input$1);
                    } else {
                      decode_error$0(input$1)(stack$1)(type$2);
                    }
                  } else {
                    missing_keys$1 = stack_add$0("b")(missing_keys$1);
                  }
                  if (!(stack_is_empty$0(missing_keys$1))) {
                    key_error$0(missing_keys$1)(stack$0)(type$1);
                  }
                } else {
                  decode_error$0(input$0)(stack$0)(type$1);
                }
              }
              props$0.set("tagged_record_bool", decoded$0);
            } else {
              decode_error$0(input$0)(stack$0)(type$1);
            }
          } else {
            decode_error$0(input$0)(stack$0)(type$1);
          }
        } else {
          decode_error$0(input$0)(stack$0)(type$1);
        }
      } else {
        missing_keys$0 = stack_add$0("tagged_record_bool")(missing_keys$0);
      }
      if (Object.hasOwn(arg$0, "tagged_record_int")) {
        let input$0 = arg$0["tagged_record_int"];
        let stack$0 = stack_add$0("tagged_record_int")(stack_empty$0);
        let type$1 =
          "{@tag: 0} | {@tag: 1, tuple: (float, string, false | true)}";
        if (typeof input$0 === "object" && !(input$0 === null)) {
          if (Object.hasOwn(input$0, "tag")) {
            if (Number.isInteger(input$0["tag"])) {
              let decoded$0 = new Map();
              if (input$0["tag"] === 0) {
                decoded$0.set("tag", 0);
                let missing_keys$1 = stack_empty$0;
                if (!(stack_is_empty$0(missing_keys$1))) {
                  key_error$0(missing_keys$1)(stack$0)(type$1);
                }
              } else {
                if (input$0["tag"] === 1) {
                  decoded$0.set("tag", 1);
                  let missing_keys$1 = stack_empty$0;
                  if (Object.hasOwn(input$0, "tuple")) {
                    let input$1 = input$0["tuple"];
                    let stack$1 = stack_add$0("tuple")(stack$0);
                    let type$2 = "(float, string, false | true)";
                    if (Array.isArray(input$1)) {
                      let seq$0 = input$1.values();
                      let decoded$1 = [0, 0, 0];
                      let next$0 = seq$0.next();
                      if (next$0.done) {
                        decode_error$0(input$1)(stack$1)(type$2);
                      } else {
                        let stack$2 = stack_add$0(String(0))(stack$1);
                        let type$3 = "float";
                        if (typeof next$0.value === "number") {
                          decoded$1[0] = next$0.value;
                        } else {
                          decode_error$0(next$0.value)(stack$2)(type$3);
                        }
                        let next$1 = seq$0.next();
                        if (next$1.done) {
                          decode_error$0(input$1)(stack$1)(type$2);
                        } else {
                          let stack$3 = stack_add$0(String(1))(stack$1);
                          let type$4 = "string";
                          if (typeof next$1.value === "string") {
                            decoded$1[1] = next$1.value;
                          } else {
                            decode_error$0(next$1.value)(stack$3)(type$4);
                          }
                          let next$2 = seq$0.next();
                          if (next$2.done) {
                            decode_error$0(input$1)(stack$1)(type$2);
                          } else {
                            let stack$4 = stack_add$0(String(2))(stack$1);
                            let type$5 = "false | true";
                            if (typeof next$2.value === "boolean") {
                              if (next$2.value) {
                                decoded$1[2] = 1;
                              } else {
                                decoded$1[2] = 0;
                              }
                            } else {
                              decode_error$0(next$2.value)(stack$4)(type$5);
                            }
                          }
                        }
                      }
                      decoded$0.set("tuple", decoded$1);
                    } else {
                      decode_error$0(input$1)(stack$1)(type$2);
                    }
                  } else {
                    missing_keys$1 = stack_add$0("tuple")(missing_keys$1);
                  }
                  if (!(stack_is_empty$0(missing_keys$1))) {
                    key_error$0(missing_keys$1)(stack$0)(type$1);
                  }
                } else {
                  decode_error$0(input$0)(stack$0)(type$1);
                }
              }
              props$0.set("tagged_record_int", decoded$0);
            } else {
              decode_error$0(input$0)(stack$0)(type$1);
            }
          } else {
            decode_error$0(input$0)(stack$0)(type$1);
          }
        } else {
          decode_error$0(input$0)(stack$0)(type$1);
        }
      } else {
        missing_keys$0 = stack_add$0("tagged_record_int")(missing_keys$0);
      }
      if (Object.hasOwn(arg$0, "tagged_record_open")) {
        let input$0 = arg$0["tagged_record_open"];
        let stack$0 = stack_add$0("tagged_record_open")(stack_empty$0);
        let type$1 =
          "{@tag: 100, a: int} | {@tag: 200, b: string} | {@tag: 300, c: float} | ...";
        if (typeof input$0 === "object" && !(input$0 === null)) {
          if (Object.hasOwn(input$0, "tag")) {
            if (Number.isInteger(input$0["tag"])) {
              let decoded$0 = new Map();
              if (input$0["tag"] === 100) {
                decoded$0.set("tag", 100);
                let missing_keys$1 = stack_empty$0;
                if (Object.hasOwn(input$0, "a")) {
                  let input$1 = input$0["a"];
                  let stack$1 = stack_add$0("a")(stack$0);
                  let type$2 = "int";
                  if (Number.isInteger(input$1)) {
                    decoded$0.set("a", input$1);
                  } else {
                    decode_error$0(input$1)(stack$1)(type$2);
                  }
                } else {
                  missing_keys$1 = stack_add$0("a")(missing_keys$1);
                }
                if (!(stack_is_empty$0(missing_keys$1))) {
                  key_error$0(missing_keys$1)(stack$0)(type$1);
                }
              } else {
                if (input$0["tag"] === 200) {
                  decoded$0.set("tag", 200);
                  let missing_keys$1 = stack_empty$0;
                  if (Object.hasOwn(input$0, "b")) {
                    let input$1 = input$0["b"];
                    let stack$1 = stack_add$0("b")(stack$0);
                    let type$2 = "string";
                    if (typeof input$1 === "string") {
                      decoded$0.set("b", input$1);
                    } else {
                      decode_error$0(input$1)(stack$1)(type$2);
                    }
                  } else {
                    missing_keys$1 = stack_add$0("b")(missing_keys$1);
                  }
                  if (!(stack_is_empty$0(missing_keys$1))) {
                    key_error$0(missing_keys$1)(stack$0)(type$1);
                  }
                } else {
                  if (input$0["tag"] === 300) {
                    decoded$0.set("tag", 300);
                    let missing_keys$1 = stack_empty$0;
                    if (Object.hasOwn(input$0, "c")) {
                      let input$1 = input$0["c"];
                      let stack$1 = stack_add$0("c")(stack$0);
                      let type$2 = "float";
                      if (typeof input$1 === "number") {
                        decoded$0.set("c", input$1);
                      } else {
                        decode_error$0(input$1)(stack$1)(type$2);
                      }
                    } else {
                      missing_keys$1 = stack_add$0("c")(missing_keys$1);
                    }
                    if (!(stack_is_empty$0(missing_keys$1))) {
                      key_error$0(missing_keys$1)(stack$0)(type$1);
                    }
                  } else {
                    decoded$0.set("tag", input$0["tag"]);
                  }
                }
              }
              props$0.set("tagged_record_open", decoded$0);
            } else {
              decode_error$0(input$0)(stack$0)(type$1);
            }
          } else {
            decode_error$0(input$0)(stack$0)(type$1);
          }
        } else {
          decode_error$0(input$0)(stack$0)(type$1);
        }
      } else {
        missing_keys$0 = stack_add$0("tagged_record_open")(missing_keys$0);
      }
      if (Object.hasOwn(arg$0, "tagged_record_string")) {
        let input$0 = arg$0["tagged_record_string"];
        let stack$0 = stack_add$0("tagged_record_string")(stack_empty$0);
        let type$1 =
          "{@tag: \"a\", record_list: [{job: string, name: string}]} |\n\
  {@tag: \"b\", open_enum: @0 | @1 | ...}";
        if (typeof input$0 === "object" && !(input$0 === null)) {
          if (Object.hasOwn(input$0, "tag")) {
            if (typeof input$0["tag"] === "string") {
              let decoded$0 = new Map();
              if (input$0["tag"] === "a") {
                decoded$0.set("tag", "a");
                let missing_keys$1 = stack_empty$0;
                if (Object.hasOwn(input$0, "record_list")) {
                  let input$1 = input$0["record_list"];
                  let stack$1 = stack_add$0("record_list")(stack$0);
                  let type$2 = "[{job: string, name: string}]";
                  if (Array.isArray(input$1)) {
                    let seq$0 = input$1.values();
                    let index$0 = 0;
                    let decoded$1 = [0, 0];
                    let decode_dst$0 = decoded$1;
                    for (let item$0 of seq$0) {
                      let decode_dst_new$0 = [0, 0];
                      let stack$2 = stack_add$0(String(index$0))(stack$1);
                      let type$3 = "{job: string, name: string}";
                      if (typeof item$0 === "object" && !(item$0 === null)) {
                        let decoded$2 = new Map();
                        let missing_keys$2 = stack_empty$0;
                        if (Object.hasOwn(item$0, "job")) {
                          let input$2 = item$0["job"];
                          let stack$3 = stack_add$0("job")(stack$2);
                          let type$4 = "string";
                          if (typeof input$2 === "string") {
                            decoded$2.set("job", input$2);
                          } else {
                            decode_error$0(input$2)(stack$3)(type$4);
                          }
                        } else {
                          missing_keys$2 = stack_add$0("job")(missing_keys$2);
                        }
                        if (Object.hasOwn(item$0, "name")) {
                          let input$2 = item$0["name"];
                          let stack$3 = stack_add$0("name")(stack$2);
                          let type$4 = "string";
                          if (typeof input$2 === "string") {
                            decoded$2.set("name", input$2);
                          } else {
                            decode_error$0(input$2)(stack$3)(type$4);
                          }
                        } else {
                          missing_keys$2 = stack_add$0("name")(missing_keys$2);
                        }
                        if (!(stack_is_empty$0(missing_keys$2))) {
                          key_error$0(missing_keys$2)(stack$2)(type$3);
                        }
                        decode_dst_new$0[0] = decoded$2;
                      } else {
                        decode_error$0(item$0)(stack$2)(type$3);
                      }
                      decode_dst$0[1] = decode_dst_new$0;
                      index$0++;
                      decode_dst$0 = decode_dst_new$0;
                    }
                    decoded$0.set("record_list", decoded$1[1]);
                  } else {
                    decode_error$0(input$1)(stack$1)(type$2);
                  }
                } else {
                  missing_keys$1 = stack_add$0("record_list")(missing_keys$1);
                }
                if (!(stack_is_empty$0(missing_keys$1))) {
                  key_error$0(missing_keys$1)(stack$0)(type$1);
                }
              } else {
                if (input$0["tag"] === "b") {
                  decoded$0.set("tag", "b");
                  let missing_keys$1 = stack_empty$0;
                  if (Object.hasOwn(input$0, "open_enum")) {
                    let input$1 = input$0["open_enum"];
                    let stack$1 = stack_add$0("open_enum")(stack$0);
                    let type$2 = "@0 | @1 | ...";
                    if (Number.isInteger(input$1)) {
                      decoded$0.set("open_enum", input$1);
                    } else {
                      decode_error$0(input$1)(stack$1)(type$2);
                    }
                  } else {
                    missing_keys$1 = stack_add$0("open_enum")(missing_keys$1);
                  }
                  if (!(stack_is_empty$0(missing_keys$1))) {
                    key_error$0(missing_keys$1)(stack$0)(type$1);
                  }
                } else {
                  decode_error$0(input$0)(stack$0)(type$1);
                }
              }
              props$0.set("tagged_record_string", decoded$0);
            } else {
              decode_error$0(input$0)(stack$0)(type$1);
            }
          } else {
            decode_error$0(input$0)(stack$0)(type$1);
          }
        } else {
          decode_error$0(input$0)(stack$0)(type$1);
        }
      } else {
        missing_keys$0 = stack_add$0("tagged_record_string")(missing_keys$0);
      }
      if (Object.hasOwn(arg$0, "unicode_string")) {
        let input$0 = arg$0["unicode_string"];
        let stack$0 = stack_add$0("unicode_string")(stack_empty$0);
        let type$1 = "string";
        if (typeof input$0 === "string") {
          props$0.set("unicode_string", input$0);
        } else {
          decode_error$0(input$0)(stack$0)(type$1);
        }
      } else {
        missing_keys$0 = stack_add$0("unicode_string")(missing_keys$0);
      }
      if (Object.hasOwn(arg$0, "unknown")) {
        let input$0 = arg$0["unknown"];
        let stack$0 = stack_add$0("unknown")(stack_empty$0);
        let type$1 = "_";
        props$0.set("unknown", input$0);
      } else {
        props$0.set("unknown", 0);
      }
      if (!(stack_is_empty$0(missing_keys$0))) {
        key_error$0(missing_keys$0)(stack_empty$0)(type$0);
      }
    } else {
      decode_error$0(arg$0)(stack_empty$0)(type$0);
    }
    if (errors$0.contents.length === 0) {
      let buf$0 = {contents: ""};
      buf$0.contents += "Formatters\n----------\n\n%i    ";
      buffer_add_escape$0(buf$0)(String(props$0.get("big_int")));
      buf$0.contents += "\n%f    ";
      buffer_add_escape$0(buf$0)(String(props$0.get("big_float")));
      buf$0.contents += "\n%b    ";
      buffer_add_escape$0(buf$0)(String(!(props$0.get("bool1") === 0)));
      buf$0.contents += "\n%b    ";
      buffer_add_escape$0(buf$0)(String(!(props$0.get("bool2") === 0)));
      buf$0.contents += "\n\nEscaping\n--------\n\nEscaped     ";
      buffer_add_escape$0(buf$0)(props$0.get("dangerous"));
      buf$0.contents += "\nNot escaped ";
      buf$0.contents += props$0.get("dangerous");
      buf$0.contents +=
        "\n\nNullable echo chaining\n----------------------\n\n";
      let nullable$0 = props$0.get("null_int");
      if (!(nullable$0 === 0)) {
        buffer_add_escape$0(buf$0)(String(nullable$0[0]));
      } else {
        let nullable$1 = props$0.get("null_float");
        if (!(nullable$1 === 0)) {
          buffer_add_escape$0(buf$0)(String(nullable$1[0]));
        } else {
          let nullable$2 = props$0.get("null_bool");
          if (!(nullable$2 === 0)) {
            buffer_add_escape$0(buf$0)(String(!(nullable$2[0] === 0)));
          } else {
            let nullable$3 = props$0.get("null_string");
            if (!(nullable$3 === 0)) {
              buffer_add_escape$0(buf$0)(nullable$3[0]);
            } else {
              buffer_add_escape$0(buf$0)("pass");
            }
          }
        }
      }
      buf$0.contents += "\n\nMatching\n--------\n\n";
      let arg_match$0 = [props$0.get("record").get("int_enum")];
      let exit$0 = -1;
      let match_arg$0 = arg_match$0[0];
      if (match_arg$0 === 8) {
        exit$0 = 0;
      } else {
        if (match_arg$0 === 40) { exit$0 = 1; }
      }
      if (exit$0 === 0) {
        buf$0.contents += "8\n";
      } else {
        buf$0.contents += "40\n";
      }
      let arg_match$1 = [props$0.get("record")];
      let exit$1 = -1;
      let match_arg$1 = arg_match$1[0];
      let match_arg$2 = match_arg$1.get("string_enum");
      if (match_arg$2 === "no") {
        exit$1 = 1;
      } else {
        if (match_arg$2 === "yes") { exit$1 = 0; }
      }
      if (exit$1 === 0) {
        buf$0.contents += "yes\n";
      } else {
        buf$0.contents += "no\n";
      }
      let arg_match$2 = [props$0.get("tagged_record_bool")];
      let match_props$0 = new Map();
      let exit$2 = -1;
      let match_arg$3 = arg_match$2[0];
      let match_arg$4 = match_arg$3.get("tag");
      if (match_arg$4 === 0) {
        let match_arg$5 = match_arg$3.get("a");
        match_props$0.set("a", match_arg$5);
        exit$2 = 0;
      } else {
        if (match_arg$4 === 1) {
          let match_arg$5 = match_arg$3.get("b");
          match_props$0.set("b", match_arg$5);
          exit$2 = 1;
        }
      }
      if (exit$2 === 0) {
        buffer_add_escape$0(buf$0)(match_props$0.get("a"));
        buf$0.contents += "\n";
      } else {
        buffer_add_escape$0(buf$0)(String(match_props$0.get("b")));
        buf$0.contents += "\n";
      }
      let arg_match$3 = [props$0.get("tagged_record_int")];
      let match_props$1 = new Map();
      let exit$3 = -1;
      let match_arg$5 = arg_match$3[0];
      let match_arg$6 = match_arg$5.get("tag");
      if (match_arg$6 === 0) {
        exit$3 = 0;
      } else {
        if (match_arg$6 === 1) {
          let match_arg$7 = match_arg$5.get("tuple");
          let match_arg$8 = match_arg$7[0];
          let match_arg$9 = match_arg$7[1];
          let match_arg$10 = match_arg$7[2];
          match_props$1.set("a", match_arg$8);
          match_props$1.set("b", match_arg$9);
          match_props$1.set("c", match_arg$10);
          exit$3 = 1;
        }
      }
      if (exit$3 === 0) {
        buf$0.contents += "Fail\n";
      } else {
        buffer_add_escape$0(buf$0)(String(match_props$1.get("a")));
        buf$0.contents += " ";
        buffer_add_escape$0(buf$0)(match_props$1.get("b"));
        buf$0.contents += " ";
        buffer_add_escape$0(buf$0)(String(!(match_props$1.get("c") === 0)));
        buf$0.contents += "\n";
      }
      let arg_match$4 = [props$0.get("tagged_record_open")];
      let match_props$2 = new Map();
      let exit$4 = -1;
      let match_arg$7 = arg_match$4[0];
      let match_arg$8 = match_arg$7.get("tag");
      if (match_arg$8 === 200) {
        let match_arg$9 = match_arg$7.get("b");
        match_props$2.set("b", match_arg$9);
        exit$4 = 0;
      }
      if (exit$4 === -1) { exit$4 = 1; }
      if (exit$4 === 0) {
        buf$0.contents += " ";
        buffer_add_escape$0(buf$0)(match_props$2.get("b"));
        buf$0.contents += "\n";
      } else {
        buf$0.contents += "Another tag!\n";
      }
      buf$0.contents += "\n\nMapping\n-------\n\n";
      let match_arg$9 = props$0.get("null_string_dict");
      for (let item$0 of match_arg$9.entries()) {
        let match_props$3 = new Map();
        let exit$5 = -1;
        if (item$0[1] === 0) {
          match_props$3.set("key", item$0[0]);
          exit$5 = 0;
        } else {
          let match_arg$10 = item$0[1][0];
          match_props$3.set("key", item$0[0]);
          match_props$3.set("str", match_arg$10);
          exit$5 = 1;
        }
        if (exit$5 === 0) {
          buffer_add_escape$0(buf$0)(match_props$3.get("key"));
          buf$0.contents += " is null.\n";
        } else {
          buffer_add_escape$0(buf$0)(match_props$3.get("key"));
          buf$0.contents += " is ";
          buffer_add_escape$0(buf$0)(match_props$3.get("str"));
          buf$0.contents += "\n";
        }
      }
      let index$0 = 0;
      let cell$0 = props$0.get("int_list");
      while (!(cell$0 === 0)) {
        let match_props$3 = new Map();
        let head$0 = cell$0[0];
        let exit$5 = -1;
        match_props$3.set("i", head$0);
        exit$5 = 0;
        buffer_add_escape$0(buf$0)(String(match_props$3.get("i")));
        buf$0.contents += "\n";
        index$0++;
        cell$0 = cell$0[1];
      }
      let index$1 = 0;
      let cell$1 = props$0.get("int_list");
      while (!(cell$1 === 0)) {
        let match_props$3 = new Map();
        let head$0 = cell$1[0];
        let exit$5 = -1;
        match_props$3.set("i", head$0);
        match_props$3.set("key", index$1);
        exit$5 = 0;
        buffer_add_escape$0(buf$0)(String(match_props$3.get("key")));
        buf$0.contents += " : ";
        buffer_add_escape$0(buf$0)(String(match_props$3.get("i")));
        buf$0.contents += "\n";
        index$1++;
        cell$1 = cell$1[1];
      }
      let index$2 = 0;
      let cell$2 = props$0.get("nested_list");
      while (!(cell$2 === 0)) {
        let match_props$3 = new Map();
        let head$0 = cell$2[0];
        let exit$5 = -1;
        match_props$3.set("l", head$0);
        exit$5 = 0;
        let index$3 = 0;
        let cell$3 = match_props$3.get("l");
        while (!(cell$3 === 0)) {
          let match_props$4 = new Map();
          let head$1 = cell$3[0];
          let exit$6 = -1;
          match_props$4.set("l2", head$1);
          exit$6 = 0;
          let index$4 = 0;
          let cell$4 = match_props$4.get("l2");
          while (!(cell$4 === 0)) {
            let match_props$5 = new Map();
            let head$2 = cell$4[0];
            let exit$7 = -1;
            match_props$5.set("i", head$2);
            exit$7 = 0;
            buffer_add_escape$0(buf$0)(String(match_props$5.get("i")));
            buf$0.contents += " ";
            index$4++;
            cell$4 = cell$4[1];
          }
          index$3++;
          cell$3 = cell$3[1];
        }
        index$2++;
        cell$2 = cell$2[1];
      }
      buf$0.contents += "\n\n";
      let index$3 = 0;
      let cell$3 = props$0.get("nested_nullable_list");
      while (!(cell$3 === 0)) {
        let match_props$3 = new Map();
        let head$0 = cell$3[0];
        let exit$5 = -1;
        if (head$0 === 0) {
          exit$5 = 0;
        } else {
          let match_arg$10 = head$0[0];
          if (match_arg$10 === 0) {
            exit$5 = 1;
          } else {
            let match_arg$11 = head$0[0];
            let match_arg$12 = match_arg$11[0];
            match_props$3.set("b", match_arg$12);
            exit$5 = 2;
          }
        }
        if (exit$5 === 0) {
          buf$0.contents += "Level 1 null\n";
        } else {
          if (exit$5 === 1) {
            buf$0.contents += "Level 2 null (This shouldn't render.)\n";
          } else {
            buf$0.contents += "Level 3 ";
            buffer_add_escape$0(buf$0)(String(!(match_props$3.get("b") === 0)));
            buf$0.contents += "\n";
          }
        }
        index$3++;
        cell$3 = cell$3[1];
      }
      buf$0.contents +=
        "\n\
  \n\
  Dictionaries match correctly\n\
  ----------------------------\n\
  \n\
  ";
      let arg_match$5 = [props$0.get("null_string_dict")];
      let match_props$3 = new Map();
      let exit$5 = -1;
      let match_arg$10 = arg_match$5[0];
      if (match_arg$10.has("a")) {
        let match_arg$11 = match_arg$10.get("a");
        if (match_arg$11 === 0) {
          if (match_arg$10.has("does_not_exist")) {
            let match_arg$12 = match_arg$10.get("does_not_exist");
            exit$5 = 1;
          }
          if (exit$5 === -1) { exit$5 = 1; }
        } else {
          let match_arg$12 = match_arg$10.get("a");
          let match_arg$13 = match_arg$12[0];
          if (match_arg$13 === "a") {
            if (match_arg$10.has("does_not_exist")) {
              let match_arg$14 = match_arg$10.get("does_not_exist");
              if (match_arg$14 === 0) {
                exit$5 = 2;
              } else {
                let match_arg$15 = match_arg$10.get("does_not_exist");
                let match_arg$16 = match_arg$15[0];
                match_props$3.set("a", match_arg$13);
                match_props$3.set("b", match_arg$16);
                exit$5 = 0;
              }
            }
            if (exit$5 === -1) { exit$5 = 2; }
          } else {
            if (match_arg$10.has("does_not_exist")) {
              let match_arg$14 = match_arg$10.get("does_not_exist");
              if (!(match_arg$14 === 0)) {
                let match_arg$15 = match_arg$10.get("does_not_exist");
                let match_arg$16 = match_arg$15[0];
                match_props$3.set("a", match_arg$13);
                match_props$3.set("b", match_arg$16);
                exit$5 = 0;
              }
            }
          }
        }
      }
      if (exit$5 === -1) { exit$5 = 3; }
      if (exit$5 === 0) {
        buf$0.contents += " ";
        buffer_add_escape$0(buf$0)(match_props$3.get("a"));
        buf$0.contents += " ";
        buffer_add_escape$0(buf$0)(match_props$3.get("b"));
        buf$0.contents += "\n";
      } else {
        if (exit$5 === 1) {
          buf$0.contents += " Fail.\n";
        } else {
          if (exit$5 === 2) {
            buf$0.contents += " Pass.\n";
          } else {
            buf$0.contents += " Fail.\n";
          }
        }
      }
      let arg_match$6 = [new Map([["a", "a"]])];
      let match_props$4 = new Map();
      let exit$6 = -1;
      let match_arg$11 = arg_match$6[0];
      if (match_arg$11.has("a")) {
        let match_arg$12 = match_arg$11.get("a");
        if (match_arg$12 === "") {
          if (match_arg$11.has("does_not_exist")) {
            let match_arg$13 = match_arg$11.get("does_not_exist");
            match_props$4.set("a", match_arg$12);
            match_props$4.set("b", match_arg$13);
            exit$6 = 0;
          }
          if (exit$6 === -1) { exit$6 = 1; }
        } else {
          if (match_arg$12 === "a") {
            if (match_arg$11.has("does_not_exist")) {
              let match_arg$13 = match_arg$11.get("does_not_exist");
              match_props$4.set("a", match_arg$12);
              match_props$4.set("b", match_arg$13);
              exit$6 = 0;
            }
            if (exit$6 === -1) { exit$6 = 2; }
          } else {
            if (match_arg$11.has("does_not_exist")) {
              let match_arg$13 = match_arg$11.get("does_not_exist");
              match_props$4.set("a", match_arg$12);
              match_props$4.set("b", match_arg$13);
              exit$6 = 0;
            }
          }
        }
      }
      if (exit$6 === -1) { exit$6 = 3; }
      if (exit$6 === 0) {
        buf$0.contents += " Fail. ";
        buffer_add_escape$0(buf$0)(match_props$4.get("a"));
        buf$0.contents += " ";
        buffer_add_escape$0(buf$0)(match_props$4.get("b"));
        buf$0.contents += "\n";
      } else {
        if (exit$6 === 1) {
          buf$0.contents += " Fail.\n";
        } else {
          if (exit$6 === 2) {
            buf$0.contents += " Pass.\n";
          } else {
            buf$0.contents += " Fail.\n";
          }
        }
      }
      buf$0.contents +=
        "\n\nConstructing async blocks\n-------------------------\n\n";
      let buf$1 = {contents: ""};
      buf$1.contents += " Nested block ";
      let nullable$1 = props$0.get("null_string");
      if (!(nullable$1 === 0)) {
        buffer_add_escape$0(buf$1)(nullable$1[0]);
      } else {
        buffer_add_escape$0(buf$1)("pass");
      }
      let buf$2 = {contents: ""};
      buf$2.contents += " Another nested block";
      let arg_match$7 =
        [new Map([["a", buf$1.contents], ["b", buf$2.contents]])];
      let match_props$5 = new Map();
      let exit$7 = -1;
      let match_arg$12 = arg_match$7[0];
      let match_arg$13 = match_arg$12.get("a");
      let match_arg$14 = match_arg$12.get("b");
      match_props$5.set("a", match_arg$13);
      match_props$5.set("b", match_arg$14);
      exit$7 = 0;
      buffer_add_escape$0(buf$0)(match_props$5.get("a"));
      buf$0.contents += " ";
      buffer_add_escape$0(buf$0)(match_props$5.get("b"));
      buf$0.contents += "\n";
      buf$0.contents += "Component\n---------\n\n";
      let buf$3 = {contents: ""};
      buf$3.contents += "Children prop";
      buf$0.contents +=
        await
          Component$0(
            new Map(
              [
                ["children", buf$3.contents],
                ["list", [1, [2, [3, 0]]]],
                ["optional", 0],
              ]
            )
          );
      buf$0.contents += "\n\n";
      buf$0.contents += await Another_function$0(new Map([]));
      buf$0.contents +=
        "\n\
  \n\
  Complicated pattern matching\n\
  ----------------------------\n\
  \n\
  ";
      let arg_match$8 = [1, 0, 3];
      let match_props$6 = new Map();
      let exit$8 = -1;
      let match_arg$15 = arg_match$8[0];
      if (match_arg$15 === 1) {
        let match_arg$16 = arg_match$8[1];
        if (match_arg$16 === 0) {
          let match_arg$17 = arg_match$8[2];
          if (match_arg$17 === 0) {
            exit$8 = 0;
          } else {
            match_props$6.set("y", match_arg$17);
            exit$8 = 2;
          }
        } else {
          let match_arg$17 = arg_match$8[1];
          let match_arg$18 = match_arg$17[0];
          if (match_arg$18 === 1) {
            let match_arg$19 = arg_match$8[2];
            if (match_arg$19 === 0) {
              exit$8 = 0;
            } else {
              if (match_arg$19 === 1) { exit$8 = 3; } else { exit$8 = 4; }
            }
          }
          if (exit$8 === -1) {
            let match_arg$19 = arg_match$8[2];
            if (match_arg$19 === 0) { exit$8 = 0; } else { exit$8 = 4; }
          }
        }
      } else {
        let match_arg$16 = arg_match$8[1];
        if (match_arg$16 === 0) {
          let match_arg$17 = arg_match$8[2];
          match_props$6.set("y", match_arg$17);
          exit$8 = 2;
        } else {
          let match_arg$17 = arg_match$8[1];
          let match_arg$18 = match_arg$17[0];
          if (match_arg$18 === 1) {
            let match_arg$19 = arg_match$8[2];
            if (match_arg$19 === 0) {
              match_props$6.set("x", match_arg$15);
              exit$8 = 1;
            } else {
              exit$8 = 4;
            }
          }
          if (exit$8 === -1) { let match_arg$19 = arg_match$8[2]; exit$8 = 4; }
        }
      }
      if (exit$8 === 0) {
        buf$0.contents += " 0\n";
      } else {
        if (exit$8 === 1) {
          buf$0.contents += " 1 ";
          buffer_add_escape$0(buf$0)(String(match_props$6.get("x")));
          buf$0.contents += "\n";
        } else {
          if (exit$8 === 2) {
            buf$0.contents += " 2 ";
            buffer_add_escape$0(buf$0)(String(match_props$6.get("y")));
            buf$0.contents += "\n";
          } else {
            if (exit$8 === 3) {
              buf$0.contents += " 3\n";
            } else {
              buf$0.contents += " 4\n";
            }
          }
        }
      }
      let arg_match$9 = [[[10, 20], 30], 40];
      let match_props$7 = new Map();
      let exit$9 = -1;
      let match_arg$16 = arg_match$9[0];
      let match_arg$17 = match_arg$16[0];
      let match_arg$18 = match_arg$17[0];
      if (match_arg$18 === 10) {
        let match_arg$19 = match_arg$17[1];
        if (match_arg$19 === 20) {
          let match_arg$20 = match_arg$16[1];
          if (match_arg$20 === 30) {
            let match_arg$21 = arg_match$9[1];
            if (match_arg$21 === 40) {
              exit$9 = 1;
            } else {
              if (match_arg$21 === 41) {
                match_props$7.set("_x", match_arg$16);
                exit$9 = 0;
              } else {
                match_props$7.set("_y", match_arg$16);
                match_props$7.set("z", match_arg$21);
                exit$9 = 2;
              }
            }
          }
        }
      }
      if (exit$9 === -1) {
        let match_arg$19 = arg_match$9[1];
        if (match_arg$19 === 41) {
          match_props$7.set("_x", match_arg$16);
          exit$9 = 0;
        } else {
          match_props$7.set("_y", match_arg$16);
          match_props$7.set("z", match_arg$19);
          exit$9 = 2;
        }
      }
      if (exit$9 === 0) {
        buf$0.contents += "\n";
      } else {
        if (exit$9 === 1) {
          buf$0.contents += " Pass\n";
        } else {
          buf$0.contents += " ";
          buffer_add_escape$0(buf$0)(String(match_props$7.get("z")));
          buf$0.contents += "\n";
        }
      }
      let arg_match$10 = [[[10, 20], 99], 40];
      let match_props$8 = new Map();
      let exit$10 = -1;
      let match_arg$19 = arg_match$10[0];
      let match_arg$20 = match_arg$19[0];
      let match_arg$21 = match_arg$20[0];
      if (match_arg$21 === 10) {
        let match_arg$22 = match_arg$20[1];
        if (match_arg$22 === 20) {
          let match_arg$23 = match_arg$19[1];
          if (match_arg$23 === 30) {
            let match_arg$24 = arg_match$10[1];
            if (match_arg$24 === 40) {
              exit$10 = 1;
            } else {
              if (match_arg$24 === 41) {
                match_props$8.set("_x", match_arg$19);
                exit$10 = 0;
              } else {
                match_props$8.set("_y", match_arg$19);
                match_props$8.set("z", match_arg$24);
                exit$10 = 2;
              }
            }
          }
        }
      }
      if (exit$10 === -1) {
        let match_arg$22 = arg_match$10[1];
        if (match_arg$22 === 41) {
          match_props$8.set("_x", match_arg$19);
          exit$10 = 0;
        } else {
          match_props$8.set("_y", match_arg$19);
          match_props$8.set("z", match_arg$22);
          exit$10 = 2;
        }
      }
      if (exit$10 === 0) {
        buf$0.contents += "\n";
      } else {
        if (exit$10 === 1) {
          buf$0.contents += " Fail\n";
        } else {
          buf$0.contents += " ";
          buffer_add_escape$0(buf$0)(String(match_props$8.get("z")));
          buf$0.contents += "\n";
        }
      }
      buf$0.contents +=
        "String encoding\n\
  ---------------\n\
  \n\
  \n\
  \\\" \\ \\ \\\"\n\
  \n\
  ";
      buffer_add_escape$0(buf$0)(props$0.get("unicode_string"));
      buf$0.contents +=
        "\n\
  \n\
  External JavaScript template component: stringify arbitrary data\n\
  \n\
  ";
      buf$0.contents +=
        await
          Stringify$0(
            new Map(
              [
                ["int_list", props$0.get("int_list")],
                ["nested_list", props$0.get("nested_list")],
                ["nested_nullable_list", props$0.get("nested_nullable_list")],
                ["null_string_dict", props$0.get("null_string_dict")],
                ["record", props$0.get("record")],
                ["tagged_record_bool", props$0.get("tagged_record_bool")],
                ["tagged_record_int", props$0.get("tagged_record_int")],
                ["tagged_record_open", props$0.get("tagged_record_open")],
                ["tagged_record_string", props$0.get("tagged_record_string")],
                ["unknown", props$0.get("unknown")],
              ]
            )
          );
      buf$0.contents += "\n";
      return (Promise.resolve(buf$0.contents));
    } else {
      return (Promise.reject(new Error(errors$0.contents)));
    }
  };

  $ cat > run.mjs << EOF
  >   import main from "./compiled.mjs";
  >   let result = await main({
  >     big_int: 100_000_000,
  >     big_float: 1234.56789,
  >     bool1: true,
  >     bool2: false,
  >     dangerous: "&\"'></\`=",
  >     record: { int_enum: 8, string_enum: "yes" },
  >     tagged_record_bool: { tag: false, a: "a" },
  >     null_string_dict: { a: "a", b: null },
  >     int_list: [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5],
  >     tagged_record_int: { tag: 1, tuple: [1.5, "snd", true] },
  >     tagged_record_string: {
  >       tag: "a",
  >       record_list: [{ name: "John", job: "librarian" }],
  >     },
  >     tagged_record_open: {
  >       tag: 999,
  >       b: "200",
  >     },
  >     unknown: new Date("2023-04-09T00:00:00.000Z"),
  >     nested_list: [
  >       [
  >         [1, 1, 1],
  >         [2, 2, 2],
  >       ],
  >       [[3, 3, 3]],
  >     ],
  >     nested_nullable_list: [null, true, false, null],
  >     null_int: null,
  >     null_float: null,
  >     null_bool: null,
  >     null_string: null,
  >     unicode_string: "",
  >   });
  >   process.stdout.write(result);
  > EOF

  $ node run.mjs
  Formatters
  ----------
  
  %i    100000000
  %f    1234.56789
  %b    true
  %b    false
  
  Escaping
  --------
  
  Escaped     &amp;&quot;&apos;&gt;&lt;&sol;&grave;&equals;
  Not escaped &"'></`=
  
  Nullable echo chaining
  ----------------------
  
  pass
  
  Matching
  --------
  
  8
  yes
  a
  1.5 snd true
  Another tag!
  
  
  Mapping
  -------
  
  a is a
  b is null.
  -5
  -4
  -3
  -2
  -1
  0
  1
  2
  3
  4
  5
  0 : -5
  1 : -4
  2 : -3
  3 : -2
  4 : -1
  5 : 0
  6 : 1
  7 : 2
  8 : 3
  9 : 4
  10 : 5
  1 1 1 2 2 2 3 3 3 
  
  Level 1 null
  Level 3 true
  Level 3 false
  Level 1 null
  
  
  Dictionaries match correctly
  ----------------------------
  
   Pass.
   Pass.
  
  
  Constructing async blocks
  -------------------------
  
   Nested block pass  Another nested block
  Component
  ---------
  
  Children prop
  123
  Nested component
  
  
  success
  
  Complicated pattern matching
  ----------------------------
  
   2 3
   Pass
   40
  String encoding
  ---------------
  
  
  \" \ \ \"
  
  
  
  External JavaScript template component: stringify arbitrary data
  
  {
    "int_list": [
      -5,
      -4,
      -3,
      -2,
      -1,
      0,
      1,
      2,
      3,
      4,
      5
    ],
    "nested_list": [
      [
        [
          1,
          1,
          1
        ],
        [
          2,
          2,
          2
        ]
      ],
      [
        [
          3,
          3,
          3
        ]
      ]
    ],
    "nested_nullable_list": [
      null,
      true,
      false,
      null
    ],
    "null_string_dict": {
      "a": "a",
      "b": null
    },
    "record": {
      "int_enum": 8,
      "string_enum": "yes"
    },
    "tagged_record_bool": {
      "tag": false,
      "a": "a"
    },
    "tagged_record_int": {
      "tag": 1,
      "tuple": [
        1.5,
        "snd",
        true
      ]
    },
    "tagged_record_open": {
      "tag": 999
    },
    "tagged_record_string": {
      "tag": "a",
      "record_list": [
        {
          "job": "librarian",
          "name": "John"
        }
      ]
    },
    "unknown": "2023-04-09T00:00:00.000Z"
  }

  $ acutis \
  >   --mode js \
  >   template.acutis \
  >   component.acutis \
  >   unused.acutis \
  >   --fun ./jscomponents.mjs stringify "$(cat stringify_interface)" \
  >   --fun ./jscomponents.mjs another_function "" \
  >   --fun ./jscomponents.mjs an_unused_function "" \
  >   > compiled.mjs

  $ cat compiled.mjs
  /* THIS FILE WAS GENERATED BY ACUTIS. */
  let buffer_add_escape$0 =
    (arg$0) => {
      return (
        (arg$1) => {
          for (let i$0 = 0; i$0 < arg$1.length; i$0++) {
            let c$0 = arg$1.charCodeAt(i$0);
            switch (c$0) {
              case 38: arg$0.contents += "&amp;"; break;
              case 34: arg$0.contents += "&quot;"; break;
              case 39: arg$0.contents += "&apos;"; break;
              case 62: arg$0.contents += "&gt;"; break;
              case 60: arg$0.contents += "&lt;"; break;
              case 47: arg$0.contents += "&sol;"; break;
              case 96: arg$0.contents += "&grave;"; break;
              case 61: arg$0.contents += "&equals;"; break;
              default: arg$0.contents += String.fromCharCode(c$0);
            }
          }
        }
      );
    };
  let components$0 = new Map();
  import {"another_function" as import$0} from "./jscomponents.mjs";
  components$0.set(
    "Another_function",
    (arg$0) => {
      let encoded$0 = new Map();
      return (import$0(Object.fromEntries(encoded$0)));
    }
  );
  import {"stringify" as import$1} from "./jscomponents.mjs";
  components$0.set(
    "Stringify",
    (arg$0) => {
      let encoded$0 = new Map();
      let props$0 = arg$0.get("int_list");
      let index$0 = 0;
      let cell$0 = props$0;
      while (!(cell$0 === 0)) { index$0++; cell$0 = cell$0[1]; }
      let encoded$1 =
        Array.from({length: index$0}, (arg$1) => { return (null); });
      cell$0 = props$0;
      index$0 = 0;
      while (!(cell$0 === 0)) {
        let props$1 = cell$0[0];
        encoded$1[index$0] = props$1;
        index$0++;
        cell$0 = cell$0[1];
      }
      encoded$0.set("int_list", encoded$1);
      let props$1 = arg$0.get("nested_list");
      let index$1 = 0;
      let cell$1 = props$1;
      while (!(cell$1 === 0)) { index$1++; cell$1 = cell$1[1]; }
      let encoded$2 =
        Array.from({length: index$1}, (arg$1) => { return (null); });
      cell$1 = props$1;
      index$1 = 0;
      while (!(cell$1 === 0)) {
        let props$2 = cell$1[0];
        let index$2 = 0;
        let cell$2 = props$2;
        while (!(cell$2 === 0)) { index$2++; cell$2 = cell$2[1]; }
        let encoded$3 =
          Array.from({length: index$2}, (arg$1) => { return (null); });
        cell$2 = props$2;
        index$2 = 0;
        while (!(cell$2 === 0)) {
          let props$3 = cell$2[0];
          let index$3 = 0;
          let cell$3 = props$3;
          while (!(cell$3 === 0)) { index$3++; cell$3 = cell$3[1]; }
          let encoded$4 =
            Array.from({length: index$3}, (arg$1) => { return (null); });
          cell$3 = props$3;
          index$3 = 0;
          while (!(cell$3 === 0)) {
            let props$4 = cell$3[0];
            encoded$4[index$3] = props$4;
            index$3++;
            cell$3 = cell$3[1];
          }
          encoded$3[index$2] = encoded$4;
          index$2++;
          cell$2 = cell$2[1];
        }
        encoded$2[index$1] = encoded$3;
        index$1++;
        cell$1 = cell$1[1];
      }
      encoded$0.set("nested_list", encoded$2);
      let props$2 = arg$0.get("nested_nullable_list");
      let index$2 = 0;
      let cell$2 = props$2;
      while (!(cell$2 === 0)) { index$2++; cell$2 = cell$2[1]; }
      let encoded$3 =
        Array.from({length: index$2}, (arg$1) => { return (null); });
      cell$2 = props$2;
      index$2 = 0;
      while (!(cell$2 === 0)) {
        let props$3 = cell$2[0];
        if (props$3 === 0) {
          encoded$3[index$2] = null;
        } else {
          let props$4 = props$3[0];
          if (props$4 === 0) {
            encoded$3[index$2] = null;
          } else {
            let props$5 = props$4[0];
            encoded$3[index$2] = !(props$5 === 0);
          }
        }
        index$2++;
        cell$2 = cell$2[1];
      }
      encoded$0.set("nested_nullable_list", encoded$3);
      let props$3 = arg$0.get("null_string_dict");
      let encoded$4 = new Map();
      for (let x$0 of props$3) {
        if (x$0[1] === 0) {
          encoded$4.set(x$0[0], null);
        } else {
          let props$4 = x$0[1][0];
          encoded$4.set(x$0[0], props$4);
        }
      }
      encoded$0.set("null_string_dict", Object.fromEntries(encoded$4));
      let props$4 = arg$0.get("record");
      let encoded$5 = new Map();
      let props$5 = props$4.get("int_enum");
      encoded$5.set("int_enum", props$5);
      let props$6 = props$4.get("string_enum");
      encoded$5.set("string_enum", props$6);
      encoded$0.set("record", Object.fromEntries(encoded$5));
      let props$7 = arg$0.get("tagged_record_bool");
      let tag$0 = props$7.get("tag");
      if (tag$0 === 0) {
        let encoded$6 = new Map();
        encoded$6.set("tag", !(tag$0 === 0));
        let props$8 = props$7.get("a");
        encoded$6.set("a", props$8);
        encoded$0.set("tagged_record_bool", Object.fromEntries(encoded$6));
      } else {
        if (tag$0 === 1) {
          let encoded$6 = new Map();
          encoded$6.set("tag", !(tag$0 === 0));
          let props$8 = props$7.get("b");
          encoded$6.set("b", props$8);
          encoded$0.set("tagged_record_bool", Object.fromEntries(encoded$6));
        }
      }
      let props$8 = arg$0.get("tagged_record_int");
      let tag$1 = props$8.get("tag");
      if (tag$1 === 0) {
        let encoded$6 = new Map();
        encoded$6.set("tag", tag$1);
        encoded$0.set("tagged_record_int", Object.fromEntries(encoded$6));
      } else {
        if (tag$1 === 1) {
          let encoded$6 = new Map();
          encoded$6.set("tag", tag$1);
          let props$9 = props$8.get("tuple");
          let encoded$7 =
            Array.from({length: 3}, (arg$1) => { return (null); });
          let props$10 = props$9[0];
          encoded$7[0] = props$10;
          let props$11 = props$9[1];
          encoded$7[1] = props$11;
          let props$12 = props$9[2];
          encoded$7[2] = !(props$12 === 0);
          encoded$6.set("tuple", encoded$7);
          encoded$0.set("tagged_record_int", Object.fromEntries(encoded$6));
        }
      }
      let props$9 = arg$0.get("tagged_record_open");
      let tag$2 = props$9.get("tag");
      if (tag$2 === 100) {
        let encoded$6 = new Map();
        encoded$6.set("tag", tag$2);
        let props$10 = props$9.get("a");
        encoded$6.set("a", props$10);
        encoded$0.set("tagged_record_open", Object.fromEntries(encoded$6));
      } else {
        if (tag$2 === 200) {
          let encoded$6 = new Map();
          encoded$6.set("tag", tag$2);
          let props$10 = props$9.get("b");
          encoded$6.set("b", props$10);
          encoded$0.set("tagged_record_open", Object.fromEntries(encoded$6));
        } else {
          if (tag$2 === 300) {
            let encoded$6 = new Map();
            encoded$6.set("tag", tag$2);
            let props$10 = props$9.get("c");
            encoded$6.set("c", props$10);
            encoded$0.set("tagged_record_open", Object.fromEntries(encoded$6));
          } else {
            let encoded$6 = new Map();
            encoded$6.set("tag", tag$2);
            encoded$0.set("tagged_record_open", Object.fromEntries(encoded$6));
          }
        }
      }
      let props$10 = arg$0.get("tagged_record_string");
      let tag$3 = props$10.get("tag");
      if (tag$3 === "a") {
        let encoded$6 = new Map();
        encoded$6.set("tag", tag$3);
        let props$11 = props$10.get("record_list");
        let index$3 = 0;
        let cell$3 = props$11;
        while (!(cell$3 === 0)) { index$3++; cell$3 = cell$3[1]; }
        let encoded$7 =
          Array.from({length: index$3}, (arg$1) => { return (null); });
        cell$3 = props$11;
        index$3 = 0;
        while (!(cell$3 === 0)) {
          let props$12 = cell$3[0];
          let encoded$8 = new Map();
          let props$13 = props$12.get("job");
          encoded$8.set("job", props$13);
          let props$14 = props$12.get("name");
          encoded$8.set("name", props$14);
          encoded$7[index$3] = Object.fromEntries(encoded$8);
          index$3++;
          cell$3 = cell$3[1];
        }
        encoded$6.set("record_list", encoded$7);
        encoded$0.set("tagged_record_string", Object.fromEntries(encoded$6));
      } else {
        if (tag$3 === "b") {
          let encoded$6 = new Map();
          encoded$6.set("tag", tag$3);
          let props$11 = props$10.get("open_enum");
          encoded$6.set("open_enum", props$11);
          encoded$0.set("tagged_record_string", Object.fromEntries(encoded$6));
        }
      }
      let props$11 = arg$0.get("unknown");
      encoded$0.set("unknown", props$11);
      return (import$1(Object.fromEntries(encoded$0)));
    }
  );
  components$0.set(
    "Component",
    async (arg$0) => {
      let buf$0 = {contents: ""};
      let nullable$0 = arg$0.get("optional");
      if (!(nullable$0 === 0)) {
        buffer_add_escape$0(buf$0)(String(nullable$0[0]));
      } else {
        buffer_add_escape$0(buf$0)(arg$0.get("children"));
      }
      buf$0.contents += "\n";
      let index$0 = 0;
      let cell$0 = arg$0.get("list");
      while (!(cell$0 === 0)) {
        let match_props$0 = new Map();
        let head$0 = cell$0[0];
        let exit$0 = -1;
        match_props$0.set("i", head$0);
        exit$0 = 0;
        buffer_add_escape$0(buf$0)(String(match_props$0.get("i")));
        index$0++;
        cell$0 = cell$0[1];
      }
      return (Promise.resolve(buf$0.contents));
    }
  );
  export default async (arg$0) => {
    let errors$0 = {contents: ""};
    let decode_error$0 =
      (arg$1) => {
        return (
          (arg$2) => {
            return (
              (arg$3) => {
                if (!(errors$0.contents.length === 0)) {
                  errors$0.contents += "\n\n";
                }
                errors$0.contents += "File \"";
                errors$0.contents += "template.acutis";
                errors$0.contents +=
                  "\"\n\
  Render error.\n\
  The data supplied does not match this template's interface.\n\
  ";
                errors$0.contents += "Path:\n";
                errors$0.contents += arg$1[0];
                let stack$0 = arg$1[1];
                while (!(stack$0 === 0)) {
                  errors$0.contents += " <- ";
                  errors$0.contents += stack$0[0];
                  stack$0 = stack$0[1];
                }
                errors$0.contents += "\nExpected type:\n";
                errors$0.contents += arg$2;
                errors$0.contents += "\nReceived value:\n";
                errors$0.contents += String(arg$3);
              }
            );
          }
        );
      };
    let key_error$0 =
      (arg$1) => {
        return (
          (arg$2) => {
            return (
              (arg$3) => {
                if (!(errors$0.contents.length === 0)) {
                  errors$0.contents += "\n\n";
                }
                errors$0.contents += "File: ";
                errors$0.contents += "template.acutis";
                errors$0.contents +=
                  "\n\
  Render error.\n\
  The data supplied does not match this template's interface.\n\
  ";
                errors$0.contents += "Path:\n";
                errors$0.contents += arg$1[0];
                let stack$0 = arg$1[1];
                while (!(stack$0 === 0)) {
                  errors$0.contents += " <- ";
                  errors$0.contents += stack$0[0];
                  stack$0 = stack$0[1];
                }
                errors$0.contents += "\nExpected type:\n";
                errors$0.contents += arg$2;
                errors$0.contents += "\nInput is missing keys:\n";
                errors$0.contents += arg$3[0];
                let stack$1 = arg$3[1];
                while (!(stack$1 === 0)) {
                  errors$0.contents += ", ";
                  errors$0.contents += stack$1[0];
                  stack$1 = stack$1[1];
                }
              }
            );
          }
        );
      };
    let props$0 = new Map();
    let stack$0 = ["<input>", 0];
    let type$0 =
      "{\n\
    big_float: float,\n\
    big_int: int,\n\
    bool1: false | true,\n\
    bool2: false | true,\n\
    dangerous: string,\n\
    int_list: [int],\n\
    nested_list: [[[int]]],\n\
    nested_nullable_list: [??false | true],\n\
    null_bool: ?false | true,\n\
    null_float: ?float,\n\
    null_int: ?int,\n\
    null_string: ?string,\n\
    null_string_dict: <?string>,\n\
    record: {int_enum: @8 | @40, string_enum: @\"no\" | @\"yes\"},\n\
    tagged_record_bool: {@tag: false, a: string} | {@tag: true, b: int},\n\
    tagged_record_int:\n\
      {@tag: 0} | {@tag: 1, tuple: (float, string, false | true)},\n\
    tagged_record_open:\n\
      {@tag: 100, a: int} |\n\
      {@tag: 200, b: string} |\n\
      {@tag: 300, c: float} |\n\
      ...,\n\
    tagged_record_string:\n\
      {@tag: \"a\", record_list: [{job: string, name: string}]} |\n\
      {@tag: \"b\", open_enum: @0 | @1 | ...},\n\
    unicode_string: string,\n\
    unknown: _\n\
  }";
    if (typeof arg$0 === "object" && !(arg$0 === null)) {
      let missing_keys$0 = 0;
      if (Object.hasOwn(arg$0, "big_float")) {
        let input$0 = arg$0["big_float"];
        let stack$1 = ["big_float", stack$0];
        let type$1 = "float";
        if (typeof input$0 === "number") {
          props$0.set("big_float", input$0);
        } else {
          if (Number.isInteger(input$0)) {
            props$0.set("big_float", input$0);
          } else {
            decode_error$0(stack$1)(type$1)(input$0);
          }
        }
      } else {
        missing_keys$0 = ["big_float", missing_keys$0];
      }
      if (Object.hasOwn(arg$0, "big_int")) {
        let input$0 = arg$0["big_int"];
        let stack$1 = ["big_int", stack$0];
        let type$1 = "int";
        if (Number.isInteger(input$0)) {
          props$0.set("big_int", input$0);
        } else {
          decode_error$0(stack$1)(type$1)(input$0);
        }
      } else {
        missing_keys$0 = ["big_int", missing_keys$0];
      }
      if (Object.hasOwn(arg$0, "bool1")) {
        let input$0 = arg$0["bool1"];
        let stack$1 = ["bool1", stack$0];
        let type$1 = "false | true";
        if (typeof input$0 === "boolean") {
          if (input$0) {
            props$0.set("bool1", 1);
          } else {
            props$0.set("bool1", 0);
          }
        } else {
          decode_error$0(stack$1)(type$1)(input$0);
        }
      } else {
        missing_keys$0 = ["bool1", missing_keys$0];
      }
      if (Object.hasOwn(arg$0, "bool2")) {
        let input$0 = arg$0["bool2"];
        let stack$1 = ["bool2", stack$0];
        let type$1 = "false | true";
        if (typeof input$0 === "boolean") {
          if (input$0) {
            props$0.set("bool2", 1);
          } else {
            props$0.set("bool2", 0);
          }
        } else {
          decode_error$0(stack$1)(type$1)(input$0);
        }
      } else {
        missing_keys$0 = ["bool2", missing_keys$0];
      }
      if (Object.hasOwn(arg$0, "dangerous")) {
        let input$0 = arg$0["dangerous"];
        let stack$1 = ["dangerous", stack$0];
        let type$1 = "string";
        if (typeof input$0 === "string") {
          props$0.set("dangerous", input$0);
        } else {
          decode_error$0(stack$1)(type$1)(input$0);
        }
      } else {
        missing_keys$0 = ["dangerous", missing_keys$0];
      }
      if (Object.hasOwn(arg$0, "int_list")) {
        let input$0 = arg$0["int_list"];
        let stack$1 = ["int_list", stack$0];
        let type$1 = "[int]";
        if (Array.isArray(input$0)) {
          let decoded$0 = [0, 0];
          let decode_dst$0 = decoded$0;
          for (let i$0 = 0; i$0 < input$0.length; i$0++) {
            let decode_dst_new$0 = [0, 0];
            let stack$2 = [String(i$0), stack$1];
            let type$2 = "int";
            if (Number.isInteger(input$0[i$0])) {
              decode_dst_new$0[0] = input$0[i$0];
            } else {
              decode_error$0(stack$2)(type$2)(input$0[i$0]);
            }
            decode_dst$0[1] = decode_dst_new$0;
            decode_dst$0 = decode_dst_new$0;
          }
          props$0.set("int_list", decoded$0[1]);
        } else {
          decode_error$0(stack$1)(type$1)(input$0);
        }
      } else {
        missing_keys$0 = ["int_list", missing_keys$0];
      }
      if (Object.hasOwn(arg$0, "nested_list")) {
        let input$0 = arg$0["nested_list"];
        let stack$1 = ["nested_list", stack$0];
        let type$1 = "[[[int]]]";
        if (Array.isArray(input$0)) {
          let decoded$0 = [0, 0];
          let decode_dst$0 = decoded$0;
          for (let i$0 = 0; i$0 < input$0.length; i$0++) {
            let decode_dst_new$0 = [0, 0];
            let stack$2 = [String(i$0), stack$1];
            let type$2 = "[[int]]";
            if (Array.isArray(input$0[i$0])) {
              let decoded$1 = [0, 0];
              let decode_dst$1 = decoded$1;
              for (let i$1 = 0; i$1 < input$0[i$0].length; i$1++) {
                let decode_dst_new$1 = [0, 0];
                let stack$3 = [String(i$1), stack$2];
                let type$3 = "[int]";
                if (Array.isArray(input$0[i$0][i$1])) {
                  let decoded$2 = [0, 0];
                  let decode_dst$2 = decoded$2;
                  for (let i$2 = 0; i$2 < input$0[i$0][i$1].length; i$2++) {
                    let decode_dst_new$2 = [0, 0];
                    let stack$4 = [String(i$2), stack$3];
                    let type$4 = "int";
                    if (Number.isInteger(input$0[i$0][i$1][i$2])) {
                      decode_dst_new$2[0] = input$0[i$0][i$1][i$2];
                    } else {
                      decode_error$0(stack$4)(type$4)(input$0[i$0][i$1][i$2]);
                    }
                    decode_dst$2[1] = decode_dst_new$2;
                    decode_dst$2 = decode_dst_new$2;
                  }
                  decode_dst_new$1[0] = decoded$2[1];
                } else {
                  decode_error$0(stack$3)(type$3)(input$0[i$0][i$1]);
                }
                decode_dst$1[1] = decode_dst_new$1;
                decode_dst$1 = decode_dst_new$1;
              }
              decode_dst_new$0[0] = decoded$1[1];
            } else {
              decode_error$0(stack$2)(type$2)(input$0[i$0]);
            }
            decode_dst$0[1] = decode_dst_new$0;
            decode_dst$0 = decode_dst_new$0;
          }
          props$0.set("nested_list", decoded$0[1]);
        } else {
          decode_error$0(stack$1)(type$1)(input$0);
        }
      } else {
        missing_keys$0 = ["nested_list", missing_keys$0];
      }
      if (Object.hasOwn(arg$0, "nested_nullable_list")) {
        let input$0 = arg$0["nested_nullable_list"];
        let stack$1 = ["nested_nullable_list", stack$0];
        let type$1 = "[??false | true]";
        if (Array.isArray(input$0)) {
          let decoded$0 = [0, 0];
          let decode_dst$0 = decoded$0;
          for (let i$0 = 0; i$0 < input$0.length; i$0++) {
            let decode_dst_new$0 = [0, 0];
            let stack$2 = [String(i$0), stack$1];
            let type$2 = "??false | true";
            if (!(input$0[i$0] === null) && !(input$0[i$0] === undefined)) {
              let decoded$1 = [0];
              let stack$3 = ["<nullable>", stack$2];
              let type$3 = "?false | true";
              if (!(input$0[i$0] === null) && !(input$0[i$0] === undefined)) {
                let decoded$2 = [0];
                let stack$4 = ["<nullable>", stack$3];
                let type$4 = "false | true";
                if (typeof input$0[i$0] === "boolean") {
                  if (input$0[i$0]) {
                    decoded$2[0] = 1;
                  } else {
                    decoded$2[0] = 0;
                  }
                } else {
                  decode_error$0(stack$4)(type$4)(input$0[i$0]);
                }
                decoded$1[0] = decoded$2;
              } else {
                decoded$1[0] = 0;
              }
              decode_dst_new$0[0] = decoded$1;
            } else {
              decode_dst_new$0[0] = 0;
            }
            decode_dst$0[1] = decode_dst_new$0;
            decode_dst$0 = decode_dst_new$0;
          }
          props$0.set("nested_nullable_list", decoded$0[1]);
        } else {
          decode_error$0(stack$1)(type$1)(input$0);
        }
      } else {
        missing_keys$0 = ["nested_nullable_list", missing_keys$0];
      }
      if (Object.hasOwn(arg$0, "null_bool")) {
        let input$0 = arg$0["null_bool"];
        let stack$1 = ["null_bool", stack$0];
        let type$1 = "?false | true";
        if (!(input$0 === null) && !(input$0 === undefined)) {
          let decoded$0 = [0];
          let stack$2 = ["<nullable>", stack$1];
          let type$2 = "false | true";
          if (typeof input$0 === "boolean") {
            if (input$0) { decoded$0[0] = 1; } else { decoded$0[0] = 0; }
          } else {
            decode_error$0(stack$2)(type$2)(input$0);
          }
          props$0.set("null_bool", decoded$0);
        } else {
          props$0.set("null_bool", 0);
        }
      } else {
        props$0.set("null_bool", 0);
      }
      if (Object.hasOwn(arg$0, "null_float")) {
        let input$0 = arg$0["null_float"];
        let stack$1 = ["null_float", stack$0];
        let type$1 = "?float";
        if (!(input$0 === null) && !(input$0 === undefined)) {
          let decoded$0 = [0];
          let stack$2 = ["<nullable>", stack$1];
          let type$2 = "float";
          if (typeof input$0 === "number") {
            decoded$0[0] = input$0;
          } else {
            if (Number.isInteger(input$0)) {
              decoded$0[0] = input$0;
            } else {
              decode_error$0(stack$2)(type$2)(input$0);
            }
          }
          props$0.set("null_float", decoded$0);
        } else {
          props$0.set("null_float", 0);
        }
      } else {
        props$0.set("null_float", 0);
      }
      if (Object.hasOwn(arg$0, "null_int")) {
        let input$0 = arg$0["null_int"];
        let stack$1 = ["null_int", stack$0];
        let type$1 = "?int";
        if (!(input$0 === null) && !(input$0 === undefined)) {
          let decoded$0 = [0];
          let stack$2 = ["<nullable>", stack$1];
          let type$2 = "int";
          if (Number.isInteger(input$0)) {
            decoded$0[0] = input$0;
          } else {
            decode_error$0(stack$2)(type$2)(input$0);
          }
          props$0.set("null_int", decoded$0);
        } else {
          props$0.set("null_int", 0);
        }
      } else {
        props$0.set("null_int", 0);
      }
      if (Object.hasOwn(arg$0, "null_string")) {
        let input$0 = arg$0["null_string"];
        let stack$1 = ["null_string", stack$0];
        let type$1 = "?string";
        if (!(input$0 === null) && !(input$0 === undefined)) {
          let decoded$0 = [0];
          let stack$2 = ["<nullable>", stack$1];
          let type$2 = "string";
          if (typeof input$0 === "string") {
            decoded$0[0] = input$0;
          } else {
            decode_error$0(stack$2)(type$2)(input$0);
          }
          props$0.set("null_string", decoded$0);
        } else {
          props$0.set("null_string", 0);
        }
      } else {
        props$0.set("null_string", 0);
      }
      if (Object.hasOwn(arg$0, "null_string_dict")) {
        let input$0 = arg$0["null_string_dict"];
        let stack$1 = ["null_string_dict", stack$0];
        let type$1 = "<?string>";
        if (typeof input$0 === "object" && !(input$0 === null)) {
          let decoded$0 = new Map();
          for (let x$0 of Object.keys(input$0)) {
            let stack$2 = [x$0, stack$1];
            let type$2 = "?string";
            if (!(input$0[x$0] === null) && !(input$0[x$0] === undefined)) {
              let decoded$1 = [0];
              let stack$3 = ["<nullable>", stack$2];
              let type$3 = "string";
              if (typeof input$0[x$0] === "string") {
                decoded$1[0] = input$0[x$0];
              } else {
                decode_error$0(stack$3)(type$3)(input$0[x$0]);
              }
              decoded$0.set(x$0, decoded$1);
            } else {
              decoded$0.set(x$0, 0);
            }
            props$0.set("null_string_dict", decoded$0);
          }
        } else {
          decode_error$0(stack$1)(type$1)(input$0);
        }
      } else {
        missing_keys$0 = ["null_string_dict", missing_keys$0];
      }
      if (Object.hasOwn(arg$0, "record")) {
        let input$0 = arg$0["record"];
        let stack$1 = ["record", stack$0];
        let type$1 = "{int_enum: @8 | @40, string_enum: @\"no\" | @\"yes\"}";
        if (typeof input$0 === "object" && !(input$0 === null)) {
          let decoded$0 = new Map();
          let missing_keys$1 = 0;
          if (Object.hasOwn(input$0, "int_enum")) {
            let input$1 = input$0["int_enum"];
            let stack$2 = ["int_enum", stack$1];
            let type$2 = "@8 | @40";
            if (Number.isInteger(input$1)) {
              if (input$1 === 8) {
                decoded$0.set("int_enum", input$1);
              } else {
                if (input$1 === 40) {
                  decoded$0.set("int_enum", input$1);
                } else {
                  decode_error$0(stack$2)(type$2)(input$1);
                }
              }
            } else {
              decode_error$0(stack$2)(type$2)(input$1);
            }
          } else {
            missing_keys$1 = ["int_enum", missing_keys$1];
          }
          if (Object.hasOwn(input$0, "string_enum")) {
            let input$1 = input$0["string_enum"];
            let stack$2 = ["string_enum", stack$1];
            let type$2 = "@\"no\" | @\"yes\"";
            if (typeof input$1 === "string") {
              if (input$1 === "no") {
                decoded$0.set("string_enum", input$1);
              } else {
                if (input$1 === "yes") {
                  decoded$0.set("string_enum", input$1);
                } else {
                  decode_error$0(stack$2)(type$2)(input$1);
                }
              }
            } else {
              decode_error$0(stack$2)(type$2)(input$1);
            }
          } else {
            missing_keys$1 = ["string_enum", missing_keys$1];
          }
          if (!(missing_keys$1 === 0)) {
            key_error$0(stack$1)(type$1)(missing_keys$1);
          }
          props$0.set("record", decoded$0);
        } else {
          decode_error$0(stack$1)(type$1)(input$0);
        }
      } else {
        missing_keys$0 = ["record", missing_keys$0];
      }
      if (Object.hasOwn(arg$0, "tagged_record_bool")) {
        let input$0 = arg$0["tagged_record_bool"];
        let stack$1 = ["tagged_record_bool", stack$0];
        let type$1 = "{@tag: false, a: string} | {@tag: true, b: int}";
        if (typeof input$0 === "object" && !(input$0 === null)) {
          if (Object.hasOwn(input$0, "tag")) {
            if (typeof input$0["tag"] === "boolean") {
              if (input$0["tag"]) {
                let decoded$0 = new Map();
                decoded$0.set("tag", 1);
                let missing_keys$1 = 0;
                if (Object.hasOwn(input$0, "b")) {
                  let input$1 = input$0["b"];
                  let stack$2 = ["b", stack$1];
                  let type$2 = "int";
                  if (Number.isInteger(input$1)) {
                    decoded$0.set("b", input$1);
                  } else {
                    decode_error$0(stack$2)(type$2)(input$1);
                  }
                } else {
                  missing_keys$1 = ["b", missing_keys$1];
                }
                if (!(missing_keys$1 === 0)) {
                  key_error$0(stack$1)(type$1)(missing_keys$1);
                }
                props$0.set("tagged_record_bool", decoded$0);
              } else {
                let decoded$0 = new Map();
                decoded$0.set("tag", 0);
                let missing_keys$1 = 0;
                if (Object.hasOwn(input$0, "a")) {
                  let input$1 = input$0["a"];
                  let stack$2 = ["a", stack$1];
                  let type$2 = "string";
                  if (typeof input$1 === "string") {
                    decoded$0.set("a", input$1);
                  } else {
                    decode_error$0(stack$2)(type$2)(input$1);
                  }
                } else {
                  missing_keys$1 = ["a", missing_keys$1];
                }
                if (!(missing_keys$1 === 0)) {
                  key_error$0(stack$1)(type$1)(missing_keys$1);
                }
                props$0.set("tagged_record_bool", decoded$0);
              }
            } else {
              decode_error$0(stack$1)(type$1)(input$0);
            }
          } else {
            decode_error$0(stack$1)(type$1)(input$0);
          }
        } else {
          decode_error$0(stack$1)(type$1)(input$0);
        }
      } else {
        missing_keys$0 = ["tagged_record_bool", missing_keys$0];
      }
      if (Object.hasOwn(arg$0, "tagged_record_int")) {
        let input$0 = arg$0["tagged_record_int"];
        let stack$1 = ["tagged_record_int", stack$0];
        let type$1 =
          "{@tag: 0} | {@tag: 1, tuple: (float, string, false | true)}";
        if (typeof input$0 === "object" && !(input$0 === null)) {
          if (Object.hasOwn(input$0, "tag")) {
            if (Number.isInteger(input$0["tag"])) {
              if (input$0["tag"] === 0) {
                let decoded$0 = new Map();
                decoded$0.set("tag", input$0["tag"]);
                let missing_keys$1 = 0;
                if (!(missing_keys$1 === 0)) {
                  key_error$0(stack$1)(type$1)(missing_keys$1);
                }
                props$0.set("tagged_record_int", decoded$0);
              } else {
                if (input$0["tag"] === 1) {
                  let decoded$0 = new Map();
                  decoded$0.set("tag", input$0["tag"]);
                  let missing_keys$1 = 0;
                  if (Object.hasOwn(input$0, "tuple")) {
                    let input$1 = input$0["tuple"];
                    let stack$2 = ["tuple", stack$1];
                    let type$2 = "(float, string, false | true)";
                    if (Array.isArray(input$1)) {
                      if (input$1.length === 3) {
                        let decoded$1 =
                          Array.from({length: 3}, (arg$1) => { return (0); });
                        for (let i$0 = 0; i$0 < input$1.length; i$0++) {
                          let stack$3 = [String(i$0), stack$2];
                          if (i$0 === 0) {
                            let type$3 = "float";
                            if (typeof input$1[i$0] === "number") {
                              decoded$1[i$0] = input$1[i$0];
                            } else {
                              if (Number.isInteger(input$1[i$0])) {
                                decoded$1[i$0] = input$1[i$0];
                              } else {
                                decode_error$0(stack$3)(type$3)(input$1[i$0]);
                              }
                            }
                          } else {
                            if (i$0 === 1) {
                              let type$3 = "string";
                              if (typeof input$1[i$0] === "string") {
                                decoded$1[i$0] = input$1[i$0];
                              } else {
                                decode_error$0(stack$3)(type$3)(input$1[i$0]);
                              }
                            } else {
                              if (i$0 === 2) {
                                let type$3 = "false | true";
                                if (typeof input$1[i$0] === "boolean") {
                                  if (input$1[i$0]) {
                                    decoded$1[i$0] = 1;
                                  } else {
                                    decoded$1[i$0] = 0;
                                  }
                                } else {
                                  decode_error$0(stack$3)(type$3)(input$1[i$0]);
                                }
                              } else {
                                decode_error$0(stack$3)(type$2)(input$1[i$0]);
                              }
                            }
                          }
                          decoded$0.set("tuple", decoded$1);
                        }
                      } else {
                        decode_error$0(stack$2)(type$2)(input$1);
                      }
                    } else {
                      decode_error$0(stack$2)(type$2)(input$1);
                    }
                  } else {
                    missing_keys$1 = ["tuple", missing_keys$1];
                  }
                  if (!(missing_keys$1 === 0)) {
                    key_error$0(stack$1)(type$1)(missing_keys$1);
                  }
                  props$0.set("tagged_record_int", decoded$0);
                } else {
                  decode_error$0(stack$1)(type$1)(input$0);
                }
              }
            } else {
              decode_error$0(stack$1)(type$1)(input$0);
            }
          } else {
            decode_error$0(stack$1)(type$1)(input$0);
          }
        } else {
          decode_error$0(stack$1)(type$1)(input$0);
        }
      } else {
        missing_keys$0 = ["tagged_record_int", missing_keys$0];
      }
      if (Object.hasOwn(arg$0, "tagged_record_open")) {
        let input$0 = arg$0["tagged_record_open"];
        let stack$1 = ["tagged_record_open", stack$0];
        let type$1 =
          "{@tag: 100, a: int} | {@tag: 200, b: string} | {@tag: 300, c: float} | ...";
        if (typeof input$0 === "object" && !(input$0 === null)) {
          if (Object.hasOwn(input$0, "tag")) {
            if (Number.isInteger(input$0["tag"])) {
              if (input$0["tag"] === 100) {
                let decoded$0 = new Map();
                decoded$0.set("tag", input$0["tag"]);
                let missing_keys$1 = 0;
                if (Object.hasOwn(input$0, "a")) {
                  let input$1 = input$0["a"];
                  let stack$2 = ["a", stack$1];
                  let type$2 = "int";
                  if (Number.isInteger(input$1)) {
                    decoded$0.set("a", input$1);
                  } else {
                    decode_error$0(stack$2)(type$2)(input$1);
                  }
                } else {
                  missing_keys$1 = ["a", missing_keys$1];
                }
                if (!(missing_keys$1 === 0)) {
                  key_error$0(stack$1)(type$1)(missing_keys$1);
                }
                props$0.set("tagged_record_open", decoded$0);
              } else {
                if (input$0["tag"] === 200) {
                  let decoded$0 = new Map();
                  decoded$0.set("tag", input$0["tag"]);
                  let missing_keys$1 = 0;
                  if (Object.hasOwn(input$0, "b")) {
                    let input$1 = input$0["b"];
                    let stack$2 = ["b", stack$1];
                    let type$2 = "string";
                    if (typeof input$1 === "string") {
                      decoded$0.set("b", input$1);
                    } else {
                      decode_error$0(stack$2)(type$2)(input$1);
                    }
                  } else {
                    missing_keys$1 = ["b", missing_keys$1];
                  }
                  if (!(missing_keys$1 === 0)) {
                    key_error$0(stack$1)(type$1)(missing_keys$1);
                  }
                  props$0.set("tagged_record_open", decoded$0);
                } else {
                  if (input$0["tag"] === 300) {
                    let decoded$0 = new Map();
                    decoded$0.set("tag", input$0["tag"]);
                    let missing_keys$1 = 0;
                    if (Object.hasOwn(input$0, "c")) {
                      let input$1 = input$0["c"];
                      let stack$2 = ["c", stack$1];
                      let type$2 = "float";
                      if (typeof input$1 === "number") {
                        decoded$0.set("c", input$1);
                      } else {
                        if (Number.isInteger(input$1)) {
                          decoded$0.set("c", input$1);
                        } else {
                          decode_error$0(stack$2)(type$2)(input$1);
                        }
                      }
                    } else {
                      missing_keys$1 = ["c", missing_keys$1];
                    }
                    if (!(missing_keys$1 === 0)) {
                      key_error$0(stack$1)(type$1)(missing_keys$1);
                    }
                    props$0.set("tagged_record_open", decoded$0);
                  } else {
                    let decoded$0 = new Map();
                    decoded$0.set("tag", input$0["tag"]);
                    props$0.set("tagged_record_open", decoded$0);
                  }
                }
              }
            } else {
              decode_error$0(stack$1)(type$1)(input$0);
            }
          } else {
            decode_error$0(stack$1)(type$1)(input$0);
          }
        } else {
          decode_error$0(stack$1)(type$1)(input$0);
        }
      } else {
        missing_keys$0 = ["tagged_record_open", missing_keys$0];
      }
      if (Object.hasOwn(arg$0, "tagged_record_string")) {
        let input$0 = arg$0["tagged_record_string"];
        let stack$1 = ["tagged_record_string", stack$0];
        let type$1 =
          "{@tag: \"a\", record_list: [{job: string, name: string}]} |\n\
  {@tag: \"b\", open_enum: @0 | @1 | ...}";
        if (typeof input$0 === "object" && !(input$0 === null)) {
          if (Object.hasOwn(input$0, "tag")) {
            if (typeof input$0["tag"] === "string") {
              if (input$0["tag"] === "a") {
                let decoded$0 = new Map();
                decoded$0.set("tag", input$0["tag"]);
                let missing_keys$1 = 0;
                if (Object.hasOwn(input$0, "record_list")) {
                  let input$1 = input$0["record_list"];
                  let stack$2 = ["record_list", stack$1];
                  let type$2 = "[{job: string, name: string}]";
                  if (Array.isArray(input$1)) {
                    let decoded$1 = [0, 0];
                    let decode_dst$0 = decoded$1;
                    for (let i$0 = 0; i$0 < input$1.length; i$0++) {
                      let decode_dst_new$0 = [0, 0];
                      let stack$3 = [String(i$0), stack$2];
                      let type$3 = "{job: string, name: string}";
                      if (
                        typeof input$1[i$0] === "object" &&
                        !(input$1[i$0] === null)
                      ) {
                        let decoded$2 = new Map();
                        let missing_keys$2 = 0;
                        if (Object.hasOwn(input$1[i$0], "job")) {
                          let input$2 = input$1[i$0]["job"];
                          let stack$4 = ["job", stack$3];
                          let type$4 = "string";
                          if (typeof input$2 === "string") {
                            decoded$2.set("job", input$2);
                          } else {
                            decode_error$0(stack$4)(type$4)(input$2);
                          }
                        } else {
                          missing_keys$2 = ["job", missing_keys$2];
                        }
                        if (Object.hasOwn(input$1[i$0], "name")) {
                          let input$2 = input$1[i$0]["name"];
                          let stack$4 = ["name", stack$3];
                          let type$4 = "string";
                          if (typeof input$2 === "string") {
                            decoded$2.set("name", input$2);
                          } else {
                            decode_error$0(stack$4)(type$4)(input$2);
                          }
                        } else {
                          missing_keys$2 = ["name", missing_keys$2];
                        }
                        if (!(missing_keys$2 === 0)) {
                          key_error$0(stack$3)(type$3)(missing_keys$2);
                        }
                        decode_dst_new$0[0] = decoded$2;
                      } else {
                        decode_error$0(stack$3)(type$3)(input$1[i$0]);
                      }
                      decode_dst$0[1] = decode_dst_new$0;
                      decode_dst$0 = decode_dst_new$0;
                    }
                    decoded$0.set("record_list", decoded$1[1]);
                  } else {
                    decode_error$0(stack$2)(type$2)(input$1);
                  }
                } else {
                  missing_keys$1 = ["record_list", missing_keys$1];
                }
                if (!(missing_keys$1 === 0)) {
                  key_error$0(stack$1)(type$1)(missing_keys$1);
                }
                props$0.set("tagged_record_string", decoded$0);
              } else {
                if (input$0["tag"] === "b") {
                  let decoded$0 = new Map();
                  decoded$0.set("tag", input$0["tag"]);
                  let missing_keys$1 = 0;
                  if (Object.hasOwn(input$0, "open_enum")) {
                    let input$1 = input$0["open_enum"];
                    let stack$2 = ["open_enum", stack$1];
                    let type$2 = "@0 | @1 | ...";
                    if (Number.isInteger(input$1)) {
                      decoded$0.set("open_enum", input$1);
                    } else {
                      decode_error$0(stack$2)(type$2)(input$1);
                    }
                  } else {
                    missing_keys$1 = ["open_enum", missing_keys$1];
                  }
                  if (!(missing_keys$1 === 0)) {
                    key_error$0(stack$1)(type$1)(missing_keys$1);
                  }
                  props$0.set("tagged_record_string", decoded$0);
                } else {
                  decode_error$0(stack$1)(type$1)(input$0);
                }
              }
            } else {
              decode_error$0(stack$1)(type$1)(input$0);
            }
          } else {
            decode_error$0(stack$1)(type$1)(input$0);
          }
        } else {
          decode_error$0(stack$1)(type$1)(input$0);
        }
      } else {
        missing_keys$0 = ["tagged_record_string", missing_keys$0];
      }
      if (Object.hasOwn(arg$0, "unicode_string")) {
        let input$0 = arg$0["unicode_string"];
        let stack$1 = ["unicode_string", stack$0];
        let type$1 = "string";
        if (typeof input$0 === "string") {
          props$0.set("unicode_string", input$0);
        } else {
          decode_error$0(stack$1)(type$1)(input$0);
        }
      } else {
        missing_keys$0 = ["unicode_string", missing_keys$0];
      }
      if (Object.hasOwn(arg$0, "unknown")) {
        let input$0 = arg$0["unknown"];
        let stack$1 = ["unknown", stack$0];
        let type$1 = "_";
        props$0.set("unknown", input$0);
      } else {
        props$0.set("unknown", 0);
      }
      if (!(missing_keys$0 === 0)) {
        key_error$0(stack$0)(type$0)(missing_keys$0);
      }
    } else {
      decode_error$0(stack$0)(type$0)(arg$0);
    }
    if (errors$0.contents.length === 0) {
      let buf$0 = {contents: ""};
      buf$0.contents += "Formatters\n----------\n\n%i    ";
      buffer_add_escape$0(buf$0)(String(props$0.get("big_int")));
      buf$0.contents += "\n%f    ";
      buffer_add_escape$0(buf$0)(String(props$0.get("big_float")));
      buf$0.contents += "\n%b    ";
      buffer_add_escape$0(buf$0)(String(!(props$0.get("bool1") === 0)));
      buf$0.contents += "\n%b    ";
      buffer_add_escape$0(buf$0)(String(!(props$0.get("bool2") === 0)));
      buf$0.contents += "\n\nEscaping\n--------\n\nEscaped     ";
      buffer_add_escape$0(buf$0)(props$0.get("dangerous"));
      buf$0.contents += "\nNot escaped ";
      buf$0.contents += props$0.get("dangerous");
      buf$0.contents +=
        "\n\nNullable echo chaining\n----------------------\n\n";
      let nullable$0 = props$0.get("null_int");
      if (!(nullable$0 === 0)) {
        buffer_add_escape$0(buf$0)(String(nullable$0[0]));
      } else {
        let nullable$1 = props$0.get("null_float");
        if (!(nullable$1 === 0)) {
          buffer_add_escape$0(buf$0)(String(nullable$1[0]));
        } else {
          let nullable$2 = props$0.get("null_bool");
          if (!(nullable$2 === 0)) {
            buffer_add_escape$0(buf$0)(String(!(nullable$2[0] === 0)));
          } else {
            let nullable$3 = props$0.get("null_string");
            if (!(nullable$3 === 0)) {
              buffer_add_escape$0(buf$0)(nullable$3[0]);
            } else {
              buffer_add_escape$0(buf$0)("pass");
            }
          }
        }
      }
      buf$0.contents += "\n\nMatching\n--------\n\n";
      let arg_match$0 = [props$0.get("record").get("int_enum")];
      let exit$0 = -1;
      let match_arg$0 = arg_match$0[0];
      if (match_arg$0 === 8) {
        exit$0 = 0;
      } else {
        if (match_arg$0 === 40) { exit$0 = 1; }
      }
      if (exit$0 === 0) {
        buf$0.contents += "8\n";
      } else {
        buf$0.contents += "40\n";
      }
      let arg_match$1 = [props$0.get("record")];
      let exit$1 = -1;
      let match_arg$1 = arg_match$1[0];
      let match_arg$2 = match_arg$1.get("string_enum");
      if (match_arg$2 === "no") {
        exit$1 = 1;
      } else {
        if (match_arg$2 === "yes") { exit$1 = 0; }
      }
      if (exit$1 === 0) {
        buf$0.contents += "yes\n";
      } else {
        buf$0.contents += "no\n";
      }
      let arg_match$2 = [props$0.get("tagged_record_bool")];
      let match_props$0 = new Map();
      let exit$2 = -1;
      let match_arg$3 = arg_match$2[0];
      let match_arg$4 = match_arg$3.get("tag");
      if (match_arg$4 === 0) {
        let match_arg$5 = match_arg$3.get("a");
        match_props$0.set("a", match_arg$5);
        exit$2 = 0;
      } else {
        if (match_arg$4 === 1) {
          let match_arg$5 = match_arg$3.get("b");
          match_props$0.set("b", match_arg$5);
          exit$2 = 1;
        }
      }
      if (exit$2 === 0) {
        buffer_add_escape$0(buf$0)(match_props$0.get("a"));
        buf$0.contents += "\n";
      } else {
        buffer_add_escape$0(buf$0)(String(match_props$0.get("b")));
        buf$0.contents += "\n";
      }
      let arg_match$3 = [props$0.get("tagged_record_int")];
      let match_props$1 = new Map();
      let exit$3 = -1;
      let match_arg$5 = arg_match$3[0];
      let match_arg$6 = match_arg$5.get("tag");
      if (match_arg$6 === 0) {
        exit$3 = 0;
      } else {
        if (match_arg$6 === 1) {
          let match_arg$7 = match_arg$5.get("tuple");
          let match_arg$8 = match_arg$7[0];
          let match_arg$9 = match_arg$7[1];
          let match_arg$10 = match_arg$7[2];
          match_props$1.set("a", match_arg$8);
          match_props$1.set("b", match_arg$9);
          match_props$1.set("c", match_arg$10);
          exit$3 = 1;
        }
      }
      if (exit$3 === 0) {
        buf$0.contents += "Fail\n";
      } else {
        buffer_add_escape$0(buf$0)(String(match_props$1.get("a")));
        buf$0.contents += " ";
        buffer_add_escape$0(buf$0)(match_props$1.get("b"));
        buf$0.contents += " ";
        buffer_add_escape$0(buf$0)(String(!(match_props$1.get("c") === 0)));
        buf$0.contents += "\n";
      }
      let arg_match$4 = [props$0.get("tagged_record_open")];
      let match_props$2 = new Map();
      let exit$4 = -1;
      let match_arg$7 = arg_match$4[0];
      let match_arg$8 = match_arg$7.get("tag");
      if (match_arg$8 === 200) {
        let match_arg$9 = match_arg$7.get("b");
        match_props$2.set("b", match_arg$9);
        exit$4 = 0;
      }
      if (exit$4 === -1) { exit$4 = 1; }
      if (exit$4 === 0) {
        buf$0.contents += " ";
        buffer_add_escape$0(buf$0)(match_props$2.get("b"));
        buf$0.contents += "\n";
      } else {
        buf$0.contents += "Another tag!\n";
      }
      buf$0.contents += "\n\nMapping\n-------\n\n";
      let match_arg$9 = props$0.get("null_string_dict");
      for (let x$0 of match_arg$9) {
        let match_props$3 = new Map();
        let exit$5 = -1;
        if (x$0[1] === 0) {
          match_props$3.set("key", x$0[0]);
          exit$5 = 0;
        } else {
          let match_arg$10 = x$0[1][0];
          match_props$3.set("key", x$0[0]);
          match_props$3.set("str", match_arg$10);
          exit$5 = 1;
        }
        if (exit$5 === 0) {
          buffer_add_escape$0(buf$0)(match_props$3.get("key"));
          buf$0.contents += " is null.\n";
        } else {
          buffer_add_escape$0(buf$0)(match_props$3.get("key"));
          buf$0.contents += " is ";
          buffer_add_escape$0(buf$0)(match_props$3.get("str"));
          buf$0.contents += "\n";
        }
      }
      let index$0 = 0;
      let cell$0 = props$0.get("int_list");
      while (!(cell$0 === 0)) {
        let match_props$3 = new Map();
        let head$0 = cell$0[0];
        let exit$5 = -1;
        match_props$3.set("i", head$0);
        exit$5 = 0;
        buffer_add_escape$0(buf$0)(String(match_props$3.get("i")));
        buf$0.contents += "\n";
        index$0++;
        cell$0 = cell$0[1];
      }
      let index$1 = 0;
      let cell$1 = props$0.get("int_list");
      while (!(cell$1 === 0)) {
        let match_props$3 = new Map();
        let head$0 = cell$1[0];
        let exit$5 = -1;
        match_props$3.set("i", head$0);
        match_props$3.set("key", index$1);
        exit$5 = 0;
        buffer_add_escape$0(buf$0)(String(match_props$3.get("key")));
        buf$0.contents += " : ";
        buffer_add_escape$0(buf$0)(String(match_props$3.get("i")));
        buf$0.contents += "\n";
        index$1++;
        cell$1 = cell$1[1];
      }
      let index$2 = 0;
      let cell$2 = props$0.get("nested_list");
      while (!(cell$2 === 0)) {
        let match_props$3 = new Map();
        let head$0 = cell$2[0];
        let exit$5 = -1;
        match_props$3.set("l", head$0);
        exit$5 = 0;
        let index$3 = 0;
        let cell$3 = match_props$3.get("l");
        while (!(cell$3 === 0)) {
          let match_props$4 = new Map();
          let head$1 = cell$3[0];
          let exit$6 = -1;
          match_props$4.set("l2", head$1);
          exit$6 = 0;
          let index$4 = 0;
          let cell$4 = match_props$4.get("l2");
          while (!(cell$4 === 0)) {
            let match_props$5 = new Map();
            let head$2 = cell$4[0];
            let exit$7 = -1;
            match_props$5.set("i", head$2);
            exit$7 = 0;
            buffer_add_escape$0(buf$0)(String(match_props$5.get("i")));
            buf$0.contents += " ";
            index$4++;
            cell$4 = cell$4[1];
          }
          index$3++;
          cell$3 = cell$3[1];
        }
        index$2++;
        cell$2 = cell$2[1];
      }
      buf$0.contents += "\n\n";
      let index$3 = 0;
      let cell$3 = props$0.get("nested_nullable_list");
      while (!(cell$3 === 0)) {
        let match_props$3 = new Map();
        let head$0 = cell$3[0];
        let exit$5 = -1;
        if (head$0 === 0) {
          exit$5 = 0;
        } else {
          let match_arg$10 = head$0[0];
          if (match_arg$10 === 0) {
            exit$5 = 1;
          } else {
            let match_arg$11 = head$0[0];
            let match_arg$12 = match_arg$11[0];
            match_props$3.set("b", match_arg$12);
            exit$5 = 2;
          }
        }
        if (exit$5 === 0) {
          buf$0.contents += "Level 1 null\n";
        } else {
          if (exit$5 === 1) {
            buf$0.contents += "Level 2 null (This shouldn't render.)\n";
          } else {
            buf$0.contents += "Level 3 ";
            buffer_add_escape$0(buf$0)(String(!(match_props$3.get("b") === 0)));
            buf$0.contents += "\n";
          }
        }
        index$3++;
        cell$3 = cell$3[1];
      }
      buf$0.contents +=
        "\n\
  \n\
  Dictionaries match correctly\n\
  ----------------------------\n\
  \n\
  ";
      let arg_match$5 = [props$0.get("null_string_dict")];
      let match_props$3 = new Map();
      let exit$5 = -1;
      let match_arg$10 = arg_match$5[0];
      if (match_arg$10.has("a")) {
        let match_arg$11 = match_arg$10.get("a");
        if (match_arg$11 === 0) {
          if (match_arg$10.has("does_not_exist")) {
            let match_arg$12 = match_arg$10.get("does_not_exist");
            exit$5 = 1;
          }
          if (exit$5 === -1) { exit$5 = 1; }
        } else {
          let match_arg$12 = match_arg$10.get("a");
          let match_arg$13 = match_arg$12[0];
          if (match_arg$13 === "a") {
            if (match_arg$10.has("does_not_exist")) {
              let match_arg$14 = match_arg$10.get("does_not_exist");
              if (match_arg$14 === 0) {
                exit$5 = 2;
              } else {
                let match_arg$15 = match_arg$10.get("does_not_exist");
                let match_arg$16 = match_arg$15[0];
                match_props$3.set("a", match_arg$13);
                match_props$3.set("b", match_arg$16);
                exit$5 = 0;
              }
            }
            if (exit$5 === -1) { exit$5 = 2; }
          } else {
            if (match_arg$10.has("does_not_exist")) {
              let match_arg$14 = match_arg$10.get("does_not_exist");
              if (!(match_arg$14 === 0)) {
                let match_arg$15 = match_arg$10.get("does_not_exist");
                let match_arg$16 = match_arg$15[0];
                match_props$3.set("a", match_arg$13);
                match_props$3.set("b", match_arg$16);
                exit$5 = 0;
              }
            }
          }
        }
      }
      if (exit$5 === -1) { exit$5 = 3; }
      if (exit$5 === 0) {
        buf$0.contents += " ";
        buffer_add_escape$0(buf$0)(match_props$3.get("a"));
        buf$0.contents += " ";
        buffer_add_escape$0(buf$0)(match_props$3.get("b"));
        buf$0.contents += "\n";
      } else {
        if (exit$5 === 1) {
          buf$0.contents += " Fail.\n";
        } else {
          if (exit$5 === 2) {
            buf$0.contents += " Pass.\n";
          } else {
            buf$0.contents += " Fail.\n";
          }
        }
      }
      let arg_match$6 = [new Map([["a", "a"]])];
      let match_props$4 = new Map();
      let exit$6 = -1;
      let match_arg$11 = arg_match$6[0];
      if (match_arg$11.has("a")) {
        let match_arg$12 = match_arg$11.get("a");
        if (match_arg$12 === "") {
          if (match_arg$11.has("does_not_exist")) {
            let match_arg$13 = match_arg$11.get("does_not_exist");
            match_props$4.set("a", match_arg$12);
            match_props$4.set("b", match_arg$13);
            exit$6 = 0;
          }
          if (exit$6 === -1) { exit$6 = 1; }
        } else {
          if (match_arg$12 === "a") {
            if (match_arg$11.has("does_not_exist")) {
              let match_arg$13 = match_arg$11.get("does_not_exist");
              match_props$4.set("a", match_arg$12);
              match_props$4.set("b", match_arg$13);
              exit$6 = 0;
            }
            if (exit$6 === -1) { exit$6 = 2; }
          } else {
            if (match_arg$11.has("does_not_exist")) {
              let match_arg$13 = match_arg$11.get("does_not_exist");
              match_props$4.set("a", match_arg$12);
              match_props$4.set("b", match_arg$13);
              exit$6 = 0;
            }
          }
        }
      }
      if (exit$6 === -1) { exit$6 = 3; }
      if (exit$6 === 0) {
        buf$0.contents += " Fail. ";
        buffer_add_escape$0(buf$0)(match_props$4.get("a"));
        buf$0.contents += " ";
        buffer_add_escape$0(buf$0)(match_props$4.get("b"));
        buf$0.contents += "\n";
      } else {
        if (exit$6 === 1) {
          buf$0.contents += " Fail.\n";
        } else {
          if (exit$6 === 2) {
            buf$0.contents += " Pass.\n";
          } else {
            buf$0.contents += " Fail.\n";
          }
        }
      }
      buf$0.contents +=
        "\n\nConstructing async blocks\n-------------------------\n\n";
      let buf$1 = {contents: ""};
      buf$1.contents += " Nested block ";
      let nullable$1 = props$0.get("null_string");
      if (!(nullable$1 === 0)) {
        buffer_add_escape$0(buf$1)(nullable$1[0]);
      } else {
        buffer_add_escape$0(buf$1)("pass");
      }
      let buf$2 = {contents: ""};
      buf$2.contents += " Another nested block";
      let arg_match$7 =
        [new Map([["a", buf$1.contents], ["b", buf$2.contents]])];
      let match_props$5 = new Map();
      let exit$7 = -1;
      let match_arg$12 = arg_match$7[0];
      let match_arg$13 = match_arg$12.get("a");
      let match_arg$14 = match_arg$12.get("b");
      match_props$5.set("a", match_arg$13);
      match_props$5.set("b", match_arg$14);
      exit$7 = 0;
      buffer_add_escape$0(buf$0)(match_props$5.get("a"));
      buf$0.contents += " ";
      buffer_add_escape$0(buf$0)(match_props$5.get("b"));
      buf$0.contents += "\n";
      buf$0.contents += "Component\n---------\n\n";
      let buf$3 = {contents: ""};
      buf$3.contents += "Children prop";
      buf$0.contents +=
        await
          components$0.get("Component")(
            new Map(
              [
                ["children", buf$3.contents],
                ["list", [1, [2, [3, 0]]]],
                ["optional", 0],
              ]
            )
          );
      buf$0.contents += "\n\n";
      buf$0.contents +=
        await components$0.get("Another_function")(new Map([]));
      buf$0.contents +=
        "\n\
  \n\
  Complicated pattern matching\n\
  ----------------------------\n\
  \n\
  ";
      let arg_match$8 = [1, 0, 3];
      let match_props$6 = new Map();
      let exit$8 = -1;
      let match_arg$15 = arg_match$8[0];
      if (match_arg$15 === 1) {
        let match_arg$16 = arg_match$8[1];
        if (match_arg$16 === 0) {
          let match_arg$17 = arg_match$8[2];
          if (match_arg$17 === 0) {
            exit$8 = 0;
          } else {
            match_props$6.set("y", match_arg$17);
            exit$8 = 2;
          }
        } else {
          let match_arg$17 = arg_match$8[1];
          let match_arg$18 = match_arg$17[0];
          if (match_arg$18 === 1) {
            let match_arg$19 = arg_match$8[2];
            if (match_arg$19 === 0) {
              exit$8 = 0;
            } else {
              if (match_arg$19 === 1) { exit$8 = 3; } else { exit$8 = 4; }
            }
          }
          if (exit$8 === -1) {
            let match_arg$19 = arg_match$8[2];
            if (match_arg$19 === 0) { exit$8 = 0; } else { exit$8 = 4; }
          }
        }
      } else {
        let match_arg$16 = arg_match$8[1];
        if (match_arg$16 === 0) {
          let match_arg$17 = arg_match$8[2];
          match_props$6.set("y", match_arg$17);
          exit$8 = 2;
        } else {
          let match_arg$17 = arg_match$8[1];
          let match_arg$18 = match_arg$17[0];
          if (match_arg$18 === 1) {
            let match_arg$19 = arg_match$8[2];
            if (match_arg$19 === 0) {
              match_props$6.set("x", match_arg$15);
              exit$8 = 1;
            } else {
              exit$8 = 4;
            }
          }
          if (exit$8 === -1) { let match_arg$19 = arg_match$8[2]; exit$8 = 4; }
        }
      }
      if (exit$8 === 0) {
        buf$0.contents += " 0\n";
      } else {
        if (exit$8 === 1) {
          buf$0.contents += " 1 ";
          buffer_add_escape$0(buf$0)(String(match_props$6.get("x")));
          buf$0.contents += "\n";
        } else {
          if (exit$8 === 2) {
            buf$0.contents += " 2 ";
            buffer_add_escape$0(buf$0)(String(match_props$6.get("y")));
            buf$0.contents += "\n";
          } else {
            if (exit$8 === 3) {
              buf$0.contents += " 3\n";
            } else {
              buf$0.contents += " 4\n";
            }
          }
        }
      }
      let arg_match$9 = [[[10, 20], 30], 40];
      let match_props$7 = new Map();
      let exit$9 = -1;
      let match_arg$16 = arg_match$9[0];
      let match_arg$17 = match_arg$16[0];
      let match_arg$18 = match_arg$17[0];
      if (match_arg$18 === 10) {
        let match_arg$19 = match_arg$17[1];
        if (match_arg$19 === 20) {
          let match_arg$20 = match_arg$16[1];
          if (match_arg$20 === 30) {
            let match_arg$21 = arg_match$9[1];
            if (match_arg$21 === 40) {
              exit$9 = 1;
            } else {
              if (match_arg$21 === 41) {
                match_props$7.set("_x", match_arg$16);
                exit$9 = 0;
              } else {
                match_props$7.set("_y", match_arg$16);
                match_props$7.set("z", match_arg$21);
                exit$9 = 2;
              }
            }
          }
        }
      }
      if (exit$9 === -1) {
        let match_arg$19 = arg_match$9[1];
        if (match_arg$19 === 41) {
          match_props$7.set("_x", match_arg$16);
          exit$9 = 0;
        } else {
          match_props$7.set("_y", match_arg$16);
          match_props$7.set("z", match_arg$19);
          exit$9 = 2;
        }
      }
      if (exit$9 === 0) {
        buf$0.contents += "\n";
      } else {
        if (exit$9 === 1) {
          buf$0.contents += " Pass\n";
        } else {
          buf$0.contents += " ";
          buffer_add_escape$0(buf$0)(String(match_props$7.get("z")));
          buf$0.contents += "\n";
        }
      }
      let arg_match$10 = [[[10, 20], 99], 40];
      let match_props$8 = new Map();
      let exit$10 = -1;
      let match_arg$19 = arg_match$10[0];
      let match_arg$20 = match_arg$19[0];
      let match_arg$21 = match_arg$20[0];
      if (match_arg$21 === 10) {
        let match_arg$22 = match_arg$20[1];
        if (match_arg$22 === 20) {
          let match_arg$23 = match_arg$19[1];
          if (match_arg$23 === 30) {
            let match_arg$24 = arg_match$10[1];
            if (match_arg$24 === 40) {
              exit$10 = 1;
            } else {
              if (match_arg$24 === 41) {
                match_props$8.set("_x", match_arg$19);
                exit$10 = 0;
              } else {
                match_props$8.set("_y", match_arg$19);
                match_props$8.set("z", match_arg$24);
                exit$10 = 2;
              }
            }
          }
        }
      }
      if (exit$10 === -1) {
        let match_arg$22 = arg_match$10[1];
        if (match_arg$22 === 41) {
          match_props$8.set("_x", match_arg$19);
          exit$10 = 0;
        } else {
          match_props$8.set("_y", match_arg$19);
          match_props$8.set("z", match_arg$22);
          exit$10 = 2;
        }
      }
      if (exit$10 === 0) {
        buf$0.contents += "\n";
      } else {
        if (exit$10 === 1) {
          buf$0.contents += " Fail\n";
        } else {
          buf$0.contents += " ";
          buffer_add_escape$0(buf$0)(String(match_props$8.get("z")));
          buf$0.contents += "\n";
        }
      }
      buf$0.contents +=
        "String encoding\n\
  ---------------\n\
  \n\
  \n\
  \\\" \\ \\ \\\"\n\
  \n\
  ";
      buffer_add_escape$0(buf$0)(props$0.get("unicode_string"));
      buf$0.contents +=
        "\n\
  \n\
  External JavaScript template component: stringify arbitrary data\n\
  \n\
  ";
      buf$0.contents +=
        await
          components$0.get("Stringify")(
            new Map(
              [
                ["int_list", props$0.get("int_list")],
                ["nested_list", props$0.get("nested_list")],
                ["nested_nullable_list", props$0.get("nested_nullable_list")],
                ["null_string_dict", props$0.get("null_string_dict")],
                ["record", props$0.get("record")],
                ["tagged_record_bool", props$0.get("tagged_record_bool")],
                ["tagged_record_int", props$0.get("tagged_record_int")],
                ["tagged_record_open", props$0.get("tagged_record_open")],
                ["tagged_record_string", props$0.get("tagged_record_string")],
                ["unknown", props$0.get("unknown")],
              ]
            )
          );
      buf$0.contents += "\n";
      return (Promise.resolve(buf$0.contents));
    } else {
      return (Promise.reject(new Error(errors$0.contents)));
    }
  };

  $ cat > run.mjs << EOF
  >   import main from "./compiled.mjs";
  >   let result = await main({
  >     big_int: 100_000_000,
  >     big_float: 1234.56789,
  >     bool1: true,
  >     bool2: false,
  >     dangerous: "&\"'></\`=",
  >     record: { int_enum: 8, string_enum: "yes" },
  >     tagged_record_bool: { tag: false, a: "a" },
  >     null_string_dict: { a: "a", b: null },
  >     int_list: [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5],
  >     tagged_record_int: { tag: 1, tuple: [1.5, "snd", true] },
  >     tagged_record_string: {
  >       tag: "a",
  >       record_list: [{ name: "John", job: "librarian" }],
  >     },
  >     tagged_record_open: {
  >       tag: 999,
  >       b: "200",
  >     },
  >     unknown: new Date("2023-04-09T00:00:00.000Z"),
  >     nested_list: [
  >       [
  >         [1, 1, 1],
  >         [2, 2, 2],
  >       ],
  >       [[3, 3, 3]],
  >     ],
  >     nested_nullable_list: [null, true, false, null],
  >     null_int: null,
  >     null_float: null,
  >     null_bool: null,
  >     null_string: null,
  >     unicode_string: "",
  >   });
  >   process.stdout.write(result);
  > EOF

  $ node run.mjs
  Formatters
  ----------
  
  %i    100000000
  %f    1234.56789
  %b    true
  %b    false
  
  Escaping
  --------
  
  Escaped     &amp;&quot;&apos;&gt;&lt;&sol;&grave;&equals;
  Not escaped &"'></`=
  
  Nullable echo chaining
  ----------------------
  
  pass
  
  Matching
  --------
  
  8
  yes
  a
  1.5 snd true
  Another tag!
  
  
  Mapping
  -------
  
  a is a
  b is null.
  -5
  -4
  -3
  -2
  -1
  0
  1
  2
  3
  4
  5
  0 : -5
  1 : -4
  2 : -3
  3 : -2
  4 : -1
  5 : 0
  6 : 1
  7 : 2
  8 : 3
  9 : 4
  10 : 5
  1 1 1 2 2 2 3 3 3 
  
  Level 1 null
  Level 3 true
  Level 3 false
  Level 1 null
  
  
  Dictionaries match correctly
  ----------------------------
  
   Pass.
   Pass.
  
  
  Constructing async blocks
  -------------------------
  
   Nested block pass  Another nested block
  Component
  ---------
  
  Children prop
  123
  
  success
  
  Complicated pattern matching
  ----------------------------
  
   2 3
   Pass
   40
  String encoding
  ---------------
  
  
  \" \ \ \"
  
  
  
  External JavaScript template component: stringify arbitrary data
  
  {
    "int_list": [
      -5,
      -4,
      -3,
      -2,
      -1,
      0,
      1,
      2,
      3,
      4,
      5
    ],
    "nested_list": [
      [
        [
          1,
          1,
          1
        ],
        [
          2,
          2,
          2
        ]
      ],
      [
        [
          3,
          3,
          3
        ]
      ]
    ],
    "nested_nullable_list": [
      null,
      true,
      false,
      null
    ],
    "null_string_dict": {
      "a": "a",
      "b": null
    },
    "record": {
      "int_enum": 8,
      "string_enum": "yes"
    },
    "tagged_record_bool": {
      "tag": false,
      "a": "a"
    },
    "tagged_record_int": {
      "tag": 1,
      "tuple": [
        1.5,
        "snd",
        true
      ]
    },
    "tagged_record_open": {
      "tag": 999
    },
    "tagged_record_string": {
      "tag": "a",
      "record_list": [
        {
          "job": "librarian",
          "name": "John"
        }
      ]
    },
    "unknown": "2023-04-09T00:00:00.000Z"
  }

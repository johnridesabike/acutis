/* THIS FILE WAS GENERATED BY ACUTIS. */

import * as External_fixture_components from "./fixture_components.mjs";

let error_decode_bool = "This field must be a boolean.";
let error_decode_str = "This field must be a string.";
let error_decode_str_enum = "This field must be a string enum.";
let error_decode_int = "This field must be an int.";
let error_decode_int_enum = "This field must be an int enum.";
let error_decode_float = "This field must be a float.";
let error_decode_array = "This field must be an array.";
let error_decode_missing_field = "This object is missing a field.";
let error_decode_bad_union_key = "This object is missing a field.";
let error_pattern_failure = "This pattern-matching failed to find a path. This probably means there's a problem with the compiler.";

let escapes = {
  "&": "&amp;",
  '"': "&quot;",
  "'": "&apos;",
  ">": "&gt;",
  "<": "&lt;",
  "/": "&#x2F;",
  "`": "&#x60;",
  "=": "&#x3D;",
};

function acutis_escape(str) {
  let result = "";
  for (let c of str) {
    result += escapes[c] || c;
  }
  return result;
}

function fmt_int(i) {
  return i.toString();
}

function fmt_int_comma(i) {
  let s = i.toString();
  let l = s.length;
  let left = ((l - 1) % 3) + 1;
  let result = "";
  for (let idx = 0; idx < l; idx++) {
    if (left === 0) {
      result += ",";
      left = 3;
    }
    left--;
    result += s[idx];
  }
  return result;
}

function toFixed(prec, f) {
  if (Math.abs(f) < 1.0) {
    return f.toFixed(prec);
  } else {
    var e = parseInt(f.toString().split("+")[1]);
    if (e > 20) {
      e -= 20;
      f /= Math.pow(10, e);
      f += Array(e + 1).join("0");
      if (prec > 0) {
        f = f + "." + Array(prec + 1).join("0");
      }
      return f;
    } else {
      return f.toFixed(prec);
    }
  }
}

function fmt_float(prec, f) {
  return toFixed(prec, f).toString();
}

function fmt_float_e(prec, f) {
  let s = f.toExponential(prec);
  // exponent should be at least two digits
  let i = s.length;
  if (s.charAt(i - 3) == "e") {
    s = s.slice(0, i - 1) + "0" + s.slice(i - 1);
  }
  return s;
}

function fmt_float_g(prec, f) {
  prec = prec === 0 ? 1 : prec;
  let s = f.toExponential(prec - 1);
  let j = s.indexOf("e");
  let exp = +s.slice(j + 1);
  if (exp < -4 || f >= 1e21 || f.toFixed(0).length > prec) {
    // remove trailing zeroes
    let i = j - 1;
    while (s.charAt(i) == "0") {
      i--;
    }
    if (s.charAt(i) == ".") {
      i--;
    }
    s = s.slice(0, i + 1) + s.slice(j);
    i = s.length;
    if (s.charAt(i - 3) == "e") {
      s = s.slice(0, i - 1) + "0" + s.slice(i - 1);
    }
  }
  return s;
}

function fmt_bool(b) {
  return b ? "true" : "false";
}

async function template_Another(input1) {
  let data = new Object();
  return External_fixture_components.another_function(data);
}

async function template_Component(data) {
  return (await Promise.all([
    "",
    "",
    acutis_escape(data.get("optional") !== null
      ? fmt_int(data.get("optional"))
      : data.get("children")),
    "\n",
    (async function () {
      let result = [];
      let index = 0;
      let arg0 = data.get("list");
      while (arg0 !== null) {
        let data1 = new Map(data);
        let exit = null;
        exit = 0;
        data1.set("i", arg0[0]);
        switch (exit) {
          case 0:
            result.push("", acutis_escape(fmt_int(data1.get("i"))), "");
            break;
          default:
            throw new Error(error_pattern_failure);
        }
        index++;
        arg0 = arg0[1];
      }
      return (await Promise.all(result)).join("");
    })(),
    "",
  ])).join("");
}

async function template_Stringify(input1) {
  let data = new Object();
  let input2 = input1.get("int_list");
  let array1 = new Array();
  data.int_list = array1;
  while (input2 !== null) {
    let input3 = input2[0];
    array1.push(input3);
    input2 = input2[1];
  }
  let input4 = input1.get("nested_list");
  let array2 = new Array();
  data.nested_list = array2;
  while (input4 !== null) {
    let input5 = input4[0];
    let array3 = new Array();
    array2.push(array3);
    while (input5 !== null) {
      let input6 = input5[0];
      let array4 = new Array();
      array3.push(array4);
      while (input6 !== null) {
        let input7 = input6[0];
        array4.push(input7);
        input6 = input6[1];
      }
      input5 = input5[1];
    }
    input4 = input4[1];
  }
  let input8 = input1.get("nested_nullable_list");
  let array5 = new Array();
  data.nested_nullable_list = array5;
  while (input8 !== null) {
    let input9 = input8[0];
    if (input9 === null) {
      array5.push(null);
    } else {
      let input10 = input9[0];
      if (input10 === null) {
        array5.push(null);
      } else {
        let input11 = input10[0];
        if (input11) {
          array5.push(true);
        } else {
          array5.push(false);
        }
      }
    }
    input8 = input8[1];
  }
  let input12 = input1.get("null_string_dict");
  let dict1 = new Object();
  data.null_string_dict = dict1;
  for (let entry of input12) {
    if (entry[1] === null) {
      dict1[entry[0]] = null;
    } else {
      let input13 = entry[1][0];
      dict1[entry[0]] = input13;
    }
  }
  let input14 = input1.get("record");
  let record1 = new Object();
  data.record = record1;
  let input15 = input14.get("int_enum");
  record1.int_enum = input15;
  let input16 = input14.get("string_enum");
  record1.string_enum = input16;
  let input17 = input1.get("tagged_record_bool");
  let union1 = new Object();
  data.tagged_record_bool = union1;
  let input18 = input17.get("tag");
  switch (input18) {
    case 0:
      union1.tag = false;
      let input26 = input17.get("a");
      union1.a = input26;
      break;
    case 1:
      union1.tag = true;
      let input27 = input17.get("b");
      union1.b = input27;
      break;
    default:
      union1.tag = input18;
  }
  let input19 = input1.get("tagged_record_int");
  let union2 = new Object();
  data.tagged_record_int = union2;
  let input20 = input19.get("tag");
  switch (input20) {
    case 0:
      union2.tag = 0;
      break;
    case 1:
      union2.tag = 1;
      let input28 = input19.get("tuple");
      let array6 = new Array(3);
      union2.tuple = array6;
      let input29 = input28[0];
      array6[0] = input29;
      let input30 = input28[1];
      array6[1] = input30;
      let input31 = input28[2];
      if (input31) {
        array6[2] = true;
      } else {
        array6[2] = false;
      }
      break;
    default:
      union2.tag = input20;
  }
  let input21 = input1.get("tagged_record_open");
  let union3 = new Object();
  data.tagged_record_open = union3;
  let input22 = input21.get("tag");
  switch (input22) {
    case 100:
      union3.tag = 100;
      let input32 = input21.get("a");
      union3.a = input32;
      break;
    case 200:
      union3.tag = 200;
      let input33 = input21.get("b");
      union3.b = input33;
      break;
    case 300:
      union3.tag = 300;
      let input34 = input21.get("c");
      union3.c = input34;
      break;
    default:
      union3.tag = input22;
  }
  let input23 = input1.get("tagged_record_string");
  let union4 = new Object();
  data.tagged_record_string = union4;
  let input24 = input23.get("tag");
  switch (input24) {
    case "a":
      union4.tag = "a";
      let input35 = input23.get("record_list");
      let array7 = new Array();
      union4.record_list = array7;
      while (input35 !== null) {
        let input36 = input35[0];
        let record2 = new Object();
        array7.push(record2);
        let input37 = input36.get("job");
        record2.job = input37;
        let input38 = input36.get("name");
        record2.name = input38;
        input35 = input35[1];
      }
      break;
    case "b":
      union4.tag = "b";
      let input39 = input23.get("open_enum");
      union4.open_enum = input39;
      break;
    default:
      union4.tag = input24;
  }
  let input25 = input1.get("unknown");
  data.unknown = input25;
  return External_fixture_components.stringify(data);
}

export default async function main(input1) {
  let data = new Map();
  if ("big_float" in input1) {
    let input2 = input1.big_float;
    if (typeof input2 === "number") {
      data.set("big_float", input2);
    } else {
      throw new Error(error_decode_float);
    }
  } else {
    throw new Error(error_decode_missing_field);
  }
  if ("big_int" in input1) {
    let input3 = input1.big_int;
    if (typeof input3 === "number") {
      data.set("big_int", input3 | 0);
    } else {
      throw new Error(error_decode_int);
    }
  } else {
    throw new Error(error_decode_missing_field);
  }
  if ("bool1" in input1) {
    let input4 = input1.bool1;
    switch (input4) {
      case false:
        data.set("bool1", 0);
        break;
      case true:
        data.set("bool1", 1);
        break;
      default:
        throw new Error(error_decode_bool);
    }
  } else {
    throw new Error(error_decode_missing_field);
  }
  if ("bool2" in input1) {
    let input5 = input1.bool2;
    switch (input5) {
      case false:
        data.set("bool2", 0);
        break;
      case true:
        data.set("bool2", 1);
        break;
      default:
        throw new Error(error_decode_bool);
    }
  } else {
    throw new Error(error_decode_missing_field);
  }
  if ("dangerous" in input1) {
    let input6 = input1.dangerous;
    if (typeof input6 === "string") {
      data.set("dangerous", input6);
    } else {
      throw new Error(error_decode_str);
    }
  } else {
    throw new Error(error_decode_missing_field);
  }
  if ("int_list" in input1) {
    let input7 = input1.int_list;
    if (input7 instanceof Array) {
      let dst_base1 = new Array(2);
      let dst1 = dst_base1;
      for (let input_hd1 of input7) {
        let dst_new1 = new Array(2);
        if (typeof input_hd1 === "number") {
          dst_new1[0] = input_hd1 | 0;
        } else {
          throw new Error(error_decode_int);
        }
        dst1[1] = dst_new1;
        dst1 = dst_new1;
      }
      dst1[1] = null;
      data.set("int_list", dst_base1[1]);
    } else {
      throw new Error(error_decode_array);
    }
  } else {
    throw new Error(error_decode_missing_field);
  }
  if ("nested_list" in input1) {
    let input8 = input1.nested_list;
    if (input8 instanceof Array) {
      let dst_base2 = new Array(2);
      let dst2 = dst_base2;
      for (let input_hd2 of input8) {
        let dst_new2 = new Array(2);
        if (input_hd2 instanceof Array) {
          let dst_base3 = new Array(2);
          let dst3 = dst_base3;
          for (let input_hd3 of input_hd2) {
            let dst_new3 = new Array(2);
            if (input_hd3 instanceof Array) {
              let dst_base4 = new Array(2);
              let dst4 = dst_base4;
              for (let input_hd4 of input_hd3) {
                let dst_new4 = new Array(2);
                if (typeof input_hd4 === "number") {
                  dst_new4[0] = input_hd4 | 0;
                } else {
                  throw new Error(error_decode_int);
                }
                dst4[1] = dst_new4;
                dst4 = dst_new4;
              }
              dst4[1] = null;
              dst_new3[0] = dst_base4[1];
            } else {
              throw new Error(error_decode_array);
            }
            dst3[1] = dst_new3;
            dst3 = dst_new3;
          }
          dst3[1] = null;
          dst_new2[0] = dst_base3[1];
        } else {
          throw new Error(error_decode_array);
        }
        dst2[1] = dst_new2;
        dst2 = dst_new2;
      }
      dst2[1] = null;
      data.set("nested_list", dst_base2[1]);
    } else {
      throw new Error(error_decode_array);
    }
  } else {
    throw new Error(error_decode_missing_field);
  }
  if ("nested_nullable_list" in input1) {
    let input9 = input1.nested_nullable_list;
    if (input9 instanceof Array) {
      let dst_base5 = new Array(2);
      let dst5 = dst_base5;
      for (let input_hd5 of input9) {
        let dst_new5 = new Array(2);
        if (input_hd5 === null || input_hd5 === undefined) {
          dst_new5[0] = null;
        } else {
          let nullable1 = new Array(1);
          dst_new5[0] = nullable1;
          if (input_hd5 === null || input_hd5 === undefined) {
            nullable1[0] = null;
          } else {
            let nullable2 = new Array(1);
            nullable1[0] = nullable2;
            switch (input_hd5) {
              case false:
                nullable2[0] = 0;
                break;
              case true:
                nullable2[0] = 1;
                break;
              default:
                throw new Error(error_decode_bool);
            }
          }
        }
        dst5[1] = dst_new5;
        dst5 = dst_new5;
      }
      dst5[1] = null;
      data.set("nested_nullable_list", dst_base5[1]);
    } else {
      throw new Error(error_decode_array);
    }
  } else {
    throw new Error(error_decode_missing_field);
  }
  if ("null_string_dict" in input1) {
    let input10 = input1.null_string_dict;
    let dict1 = new Map();
    data.set("null_string_dict", dict1);
    for (let key1 in input10) {
      let input11 = input10[key1];
      if (input11 === null || input11 === undefined) {
        dict1.set(key1, null);
      } else {
        let nullable3 = new Array(1);
        dict1.set(key1, nullable3);
        if (typeof input11 === "string") {
          nullable3[0] = input11;
        } else {
          throw new Error(error_decode_str);
        }
      }
    }
  } else {
    throw new Error(error_decode_missing_field);
  }
  if ("record" in input1) {
    let input12 = input1.record;
    let record1 = new Map();
    data.set("record", record1);
    if ("int_enum" in input12) {
      let input13 = input12.int_enum;
      switch (input13) {
        case 8:
          record1.set("int_enum", 8);
          break;
        case 40:
          record1.set("int_enum", 40);
          break;
        default:
          throw new Error(error_decode_int_enum);
      }
    } else {
      throw new Error(error_decode_missing_field);
    }
    if ("string_enum" in input12) {
      let input14 = input12.string_enum;
      switch (input14) {
        case "no":
          record1.set("string_enum", "no");
          break;
        case "yes":
          record1.set("string_enum", "yes");
          break;
        default:
          throw new Error(error_decode_str_enum);
      }
    } else {
      throw new Error(error_decode_missing_field);
    }
  } else {
    throw new Error(error_decode_missing_field);
  }
  if ("tagged_record_bool" in input1) {
    let input15 = input1.tagged_record_bool;
    let union1 = new Map();
    data.set("tagged_record_bool", union1);
    let input16 = input15.tag;
    switch (input16) {
      case false:
        union1.set("tag", 0);
        if ("a" in input15) {
          let input24 = input15.a;
          if (typeof input24 === "string") {
            union1.set("a", input24);
          } else {
            throw new Error(error_decode_str);
          }
        } else {
          throw new Error(error_decode_missing_field);
        }
        break;
      case true:
        union1.set("tag", 1);
        if ("b" in input15) {
          let input25 = input15.b;
          if (typeof input25 === "number") {
            union1.set("b", input25 | 0);
          } else {
            throw new Error(error_decode_int);
          }
        } else {
          throw new Error(error_decode_missing_field);
        }
        break;
      default:
        throw new Error(error_decode_bad_union_key);
    }
  } else {
    throw new Error(error_decode_missing_field);
  }
  if ("tagged_record_int" in input1) {
    let input17 = input1.tagged_record_int;
    let union2 = new Map();
    data.set("tagged_record_int", union2);
    let input18 = input17.tag;
    switch (input18) {
      case 0:
        union2.set("tag", 0);
        break;
      case 1:
        union2.set("tag", 1);
        if ("tuple" in input17) {
          let input26 = input17.tuple;
          if (input26 instanceof Array && input26.length === 3) {
            let tuple1 = new Array(3);
            union2.set("tuple", tuple1);
            let input27 = input26[0];
            if (typeof input27 === "number") {
              tuple1[0] = input27;
            } else {
              throw new Error(error_decode_float);
            }
            let input28 = input26[1];
            if (typeof input28 === "string") {
              tuple1[1] = input28;
            } else {
              throw new Error(error_decode_str);
            }
            let input29 = input26[2];
            switch (input29) {
              case false:
                tuple1[2] = 0;
                break;
              case true:
                tuple1[2] = 1;
                break;
              default:
                throw new Error(error_decode_bool);
            }
          } else {
            throw new Error(error_decode_array);
          }
        } else {
          throw new Error(error_decode_missing_field);
        }
        break;
      default:
        throw new Error(error_decode_bad_union_key);
    }
  } else {
    throw new Error(error_decode_missing_field);
  }
  if ("tagged_record_open" in input1) {
    let input19 = input1.tagged_record_open;
    let union3 = new Map();
    data.set("tagged_record_open", union3);
    let input20 = input19.tag;
    switch (input20) {
      case 100:
        union3.set("tag", 100);
        if ("a" in input19) {
          let input30 = input19.a;
          if (typeof input30 === "number") {
            union3.set("a", input30 | 0);
          } else {
            throw new Error(error_decode_int);
          }
        } else {
          throw new Error(error_decode_missing_field);
        }
        break;
      case 200:
        union3.set("tag", 200);
        if ("b" in input19) {
          let input31 = input19.b;
          if (typeof input31 === "string") {
            union3.set("b", input31);
          } else {
            throw new Error(error_decode_str);
          }
        } else {
          throw new Error(error_decode_missing_field);
        }
        break;
      case 300:
        union3.set("tag", 300);
        if ("c" in input19) {
          let input32 = input19.c;
          if (typeof input32 === "number") {
            union3.set("c", input32);
          } else {
            throw new Error(error_decode_float);
          }
        } else {
          throw new Error(error_decode_missing_field);
        }
        break;
      default:
        if (typeof input20 === "number") {
          union3.set("tag", input20 | 0);
        } else {
          throw new Error(error_decode_int);
        }
    }
  } else {
    throw new Error(error_decode_missing_field);
  }
  if ("tagged_record_string" in input1) {
    let input21 = input1.tagged_record_string;
    let union4 = new Map();
    data.set("tagged_record_string", union4);
    let input22 = input21.tag;
    switch (input22) {
      case "a":
        union4.set("tag", "a");
        if ("record_list" in input21) {
          let input33 = input21.record_list;
          if (input33 instanceof Array) {
            let dst_base6 = new Array(2);
            let dst6 = dst_base6;
            for (let input_hd6 of input33) {
              let dst_new6 = new Array(2);
              let record2 = new Map();
              dst_new6[0] = record2;
              if ("job" in input_hd6) {
                let input34 = input_hd6.job;
                if (typeof input34 === "string") {
                  record2.set("job", input34);
                } else {
                  throw new Error(error_decode_str);
                }
              } else {
                throw new Error(error_decode_missing_field);
              }
              if ("name" in input_hd6) {
                let input35 = input_hd6.name;
                if (typeof input35 === "string") {
                  record2.set("name", input35);
                } else {
                  throw new Error(error_decode_str);
                }
              } else {
                throw new Error(error_decode_missing_field);
              }
              dst6[1] = dst_new6;
              dst6 = dst_new6;
            }
            dst6[1] = null;
            union4.set("record_list", dst_base6[1]);
          } else {
            throw new Error(error_decode_array);
          }
        } else {
          throw new Error(error_decode_missing_field);
        }
        break;
      case "b":
        union4.set("tag", "b");
        if ("open_enum" in input21) {
          let input36 = input21.open_enum;
          if (typeof input36 === "number") {
            union4.set("open_enum", input36 | 0);
          } else {
            throw new Error(error_decode_int);
          }
        } else {
          throw new Error(error_decode_missing_field);
        }
        break;
      default:
        throw new Error(error_decode_bad_union_key);
    }
  } else {
    throw new Error(error_decode_missing_field);
  }
  if ("unknown" in input1) {
    let input23 = input1.unknown;
    data.set("unknown", input23);
  } else {
    data.set("unknown", null);
  }
  return (await Promise.all([
    "",
    "Formatters\n----------\n\n%i    ",
    acutis_escape(fmt_int(data.get("big_int"))),
    "\n%,i   ",
    acutis_escape(fmt_int_comma(data.get("big_int"))),
    "\n%f    ",
    acutis_escape(fmt_float(6, data.get("big_float"))),
    "\n%2f   ",
    acutis_escape(fmt_float(2, data.get("big_float"))),
    "\n%e    ",
    acutis_escape(fmt_float_e(6, data.get("big_float"))),
    "\n%.2e  ",
    acutis_escape(fmt_float_e(2, data.get("big_float"))),
    "\n%g    ",
    acutis_escape(fmt_float_g(6, data.get("big_float"))),
    "\n%.2g  ",
    acutis_escape(fmt_float_g(2, data.get("big_float"))),
    "\n%b    ",
    acutis_escape(fmt_bool(data.get("bool1"))),
    "\n%b    ",
    acutis_escape(fmt_bool(data.get("bool2"))),
    "\n\nEscaping\n--------\n\nEscaped     ",
    acutis_escape(data.get("dangerous")),
    "\nNot escaped ",
    data.get("dangerous"),
    "\n\nMatching\n--------\n\n",
    (async function () {
      let data1 = new Map(data);
      let exit = null;
      let arg0 = data.get("record").get("int_enum");
      switch (arg0) {
        case 8:
          exit = 0;
          break;
        case 40:
          exit = 1;
          break;
      }
      switch (exit) {
        case 0:
          return (await Promise.all(["8\n"])).join("");
        case 1:
          return (await Promise.all(["40\n"])).join("");
        default:
          throw new Error(error_pattern_failure);
      }
    })(),
    "",
    (async function () {
      let data1 = new Map(data);
      let exit = null;
      let arg0 = data.get("record");
      switch (arg0.get("string_enum")) {
        case "no":
          exit = 1;
          break;
        case "yes":
          exit = 0;
          break;
      }
      switch (exit) {
        case 0:
          return (await Promise.all(["yes\n"])).join("");
        case 1:
          return (await Promise.all(["no\n"])).join("");
        default:
          throw new Error(error_pattern_failure);
      }
    })(),
    "",
    (async function () {
      let data1 = new Map(data);
      let exit = null;
      let arg0 = data.get("tagged_record_bool");
      switch (arg0.get("tag")) {
        case 0:
          exit = 0;
          data1.set("a", arg0.get("a"));
          break;
        case 1:
          exit = 1;
          data1.set("b", arg0.get("b"));
          break;
      }
      switch (exit) {
        case 0:
          return (await Promise.all([
            "",
            acutis_escape(data1.get("a")),
            "\n",
          ])).join("");
        case 1:
          return (await Promise.all([
            "",
            acutis_escape(fmt_int(data1.get("b"))),
            "\n",
          ])).join("");
        default:
          throw new Error(error_pattern_failure);
      }
    })(),
    "",
    (async function () {
      let data1 = new Map(data);
      let exit = null;
      let arg0 = data.get("tagged_record_int");
      switch (arg0.get("tag")) {
        case 0:
          exit = 0;
          break;
        case 1:
          exit = 1;
          data1.set("c", arg0.get("tuple")[2]);
          data1.set("b", arg0.get("tuple")[1]);
          data1.set("a", arg0.get("tuple")[0]);
          break;
      }
      switch (exit) {
        case 0:
          return (await Promise.all(["Fail\n"])).join("");
        case 1:
          return (await Promise.all([
            "",
            acutis_escape(fmt_float(6, data1.get("a"))),
            " ",
            acutis_escape(data1.get("b")),
            " ",
            acutis_escape(fmt_bool(data1.get("c"))),
            "\n",
          ])).join("");
        default:
          throw new Error(error_pattern_failure);
      }
    })(),
    "",
    (async function () {
      let data1 = new Map(data);
      let exit = null;
      let arg0 = data.get("tagged_record_open");
      switch (arg0.get("tag")) {
        case 200:
          exit = 0;
          data1.set("b", arg0.get("b"));
          break;
      }
      if (exit === null) {
        exit = 1;
      }
      switch (exit) {
        case 0:
          return (await Promise.all([
            " ",
            acutis_escape(data1.get("b")),
            "\n",
          ])).join("");
        case 1:
          return (await Promise.all(["Another tag!\n"])).join("");
        default:
          throw new Error(error_pattern_failure);
      }
    })(),
    "\n\nMapping\n-------\n\n",
    (async function () {
      let result = [];
      let arg0 = data.get("null_string_dict");
      for (let entry of arg0) {
        let data1 = new Map(data);
        let exit = null;
        if (entry[1] === null) {
          exit = 0;
          data1.set("key", entry[0]);
        } else {
          exit = 1;
          data1.set("str", entry[1][0]);
          data1.set("key", entry[0]);
        }
        switch (exit) {
          case 0:
            result.push("", acutis_escape(data1.get("key")), " is null.\n");
            break;
          case 1:
            result.push(
              "",
              acutis_escape(data1.get("key")),
              " is ",
              acutis_escape(data1.get("str")),
              "\n"
            );
            break;
          default:
            throw new Error(error_pattern_failure);
        }
      }
      return (await Promise.all(result)).join("");
    })(),
    "",
    (async function () {
      let result = [];
      let index = 0;
      let arg0 = data.get("int_list");
      while (arg0 !== null) {
        let data1 = new Map(data);
        let exit = null;
        exit = 0;
        data1.set("i", arg0[0]);
        switch (exit) {
          case 0:
            result.push("", acutis_escape(fmt_int(data1.get("i"))), "\n");
            break;
          default:
            throw new Error(error_pattern_failure);
        }
        index++;
        arg0 = arg0[1];
      }
      return (await Promise.all(result)).join("");
    })(),
    "",
    (async function () {
      let result = [];
      let index = 0;
      let arg0 = data.get("int_list");
      while (arg0 !== null) {
        let data1 = new Map(data);
        let exit = null;
        exit = 0;
        data1.set("key", index);
        data1.set("i", arg0[0]);
        switch (exit) {
          case 0:
            result.push(
              "",
              acutis_escape(fmt_int(data1.get("key"))),
              " : ",
              acutis_escape(fmt_int(data1.get("i"))),
              "\n"
            );
            break;
          default:
            throw new Error(error_pattern_failure);
        }
        index++;
        arg0 = arg0[1];
      }
      return (await Promise.all(result)).join("");
    })(),
    "",
    (async function () {
      let result = [];
      let index = 0;
      let arg0 = data.get("nested_list");
      while (arg0 !== null) {
        let data1 = new Map(data);
        let exit = null;
        exit = 0;
        data1.set("l", arg0[0]);
        switch (exit) {
          case 0:
            result.push(
              "",
              (async function () {
                let result = [];
                let index = 0;
                let arg0 = data1.get("l");
                while (arg0 !== null) {
                  let data2 = new Map(data1);
                  let exit = null;
                  exit = 0;
                  data2.set("l2", arg0[0]);
                  switch (exit) {
                    case 0:
                      result.push(
                        "",
                        (async function () {
                          let result = [];
                          let index = 0;
                          let arg0 = data2.get("l2");
                          while (arg0 !== null) {
                            let data3 = new Map(data2);
                            let exit = null;
                            exit = 0;
                            data3.set("i", arg0[0]);
                            switch (exit) {
                              case 0:
                                result.push(
                                  "",
                                  acutis_escape(fmt_int(data3.get("i"))),
                                  " "
                                );
                                break;
                              default:
                                throw new Error(error_pattern_failure);
                            }
                            index++;
                            arg0 = arg0[1];
                          }
                          return (await Promise.all(result)).join("");
                        })(),
                        ""
                      );
                      break;
                    default:
                      throw new Error(error_pattern_failure);
                  }
                  index++;
                  arg0 = arg0[1];
                }
                return (await Promise.all(result)).join("");
              })(),
              ""
            );
            break;
          default:
            throw new Error(error_pattern_failure);
        }
        index++;
        arg0 = arg0[1];
      }
      return (await Promise.all(result)).join("");
    })(),
    "\n\n",
    (async function () {
      let result = [];
      let index = 0;
      let arg0 = data.get("nested_nullable_list");
      while (arg0 !== null) {
        let data1 = new Map(data);
        let exit = null;
        if (arg0[0] === null) {
          exit = 0;
        } else {
          if (arg0[0][0] === null) {
            exit = 1;
          } else {
            exit = 2;
            data1.set("b", arg0[0][0][0]);
          }
        }
        switch (exit) {
          case 0:
            result.push("Level 1 null\n");
            break;
          case 1:
            result.push("Level 2 null (This shouldn't render.)\n");
            break;
          case 2:
            result.push(
              "Level 3 ",
              acutis_escape(fmt_bool(data1.get("b"))),
              "\n"
            );
            break;
          default:
            throw new Error(error_pattern_failure);
        }
        index++;
        arg0 = arg0[1];
      }
      return (await Promise.all(result)).join("");
    })(),
    "\n\nConstructing async blocks\n-------------------------\n\n",
    (async function () {
      let data1 = new Map(data);
      let exit = null;
      let resolved1 = (await Promise.all([
        " Another nested block",
      ])).join("");
      let resolved0 = (await Promise.all([" Nested block"])).join("");
      let arg0 = new Map([["a", resolved0], ["b", resolved1]]);
      exit = 0;
      data1.set("b", arg0.get("b"));
      data1.set("a", arg0.get("a"));
      switch (exit) {
        case 0:
          return (await Promise.all([
            "",
            acutis_escape(data1.get("a")),
            " ",
            acutis_escape(data1.get("b")),
            "\n",
          ])).join("");
        default:
          throw new Error(error_pattern_failure);
      }
    })(),
    "Component\n---------\n\n",
    (async function () {
      let resolved0 = (await Promise.all(["Children prop"])).join("");
      let arg0 = new Map([
        ["children", resolved0],
        ["list", [1, [2, [3, null]]]],
        ["optional", null],
      ]);
      return template_Component(arg0);
    })(),
    "\n\nComplicated pattern matching\n----------------------------\n\n",
    (async function () {
      let data1 = new Map(data);
      let exit = null;
      let arg0 = 1;
      let arg1 = null;
      let arg2 = 3;
      switch (arg0) {
        case 1:
          if (arg1 === null) {
            switch (arg2) {
              case 0:
                exit = 0;
                break;
              default:
                exit = 2;
                data1.set("y", arg2);
            }
          } else {
            switch (arg1[0]) {
              case 1:
                switch (arg2) {
                  case 0:
                    exit = 0;
                    break;
                  case 1:
                    exit = 3;
                    break;
                  default:
                    exit = 4;
                }
                break;
            }
            if (exit === null) {
              switch (arg2) {
                case 0:
                  exit = 0;
                  break;
                default:
                  exit = 4;
              }
            }
          }
          break;
        default:
          if (arg1 === null) {
            exit = 2;
            data1.set("y", arg2);
          } else {
            switch (arg1[0]) {
              case 1:
                switch (arg2) {
                  case 0:
                    exit = 1;
                    data1.set("x", arg0);
                    break;
                  default:
                    exit = 4;
                }
                break;
            }
            if (exit === null) {
              exit = 4;
            }
          }
      }
      switch (exit) {
        case 0:
          return (await Promise.all([" 0\n"])).join("");
        case 1:
          return (await Promise.all([
            " 1 ",
            acutis_escape(fmt_int(data1.get("x"))),
            "\n",
          ])).join("");
        case 2:
          return (await Promise.all([
            " 2 ",
            acutis_escape(fmt_int(data1.get("y"))),
            "\n",
          ])).join("");
        case 3:
          return (await Promise.all([" 3\n"])).join("");
        case 4:
          return (await Promise.all([" 4\n"])).join("");
        default:
          throw new Error(error_pattern_failure);
      }
    })(),
    "",
    (async function () {
      let data1 = new Map(data);
      let exit = null;
      let arg0 = [[10, 20], 30];
      let arg1 = 40;
      switch (arg0[0][0]) {
        case 10:
          switch (arg0[0][1]) {
            case 20:
              switch (arg0[1]) {
                case 30:
                  switch (arg1) {
                    case 40:
                      exit = 1;
                      break;
                    case 41:
                      exit = 0;
                      data1.set("_x", arg0);
                      break;
                    default:
                      exit = 2;
                      data1.set("z", arg1);
                      data1.set("_y", arg0);
                  }
                  break;
              }
              break;
          }
          break;
      }
      if (exit === null) {
        switch (arg1) {
          case 41:
            exit = 0;
            data1.set("_x", arg0);
            break;
          default:
            exit = 2;
            data1.set("z", arg1);
            data1.set("_y", arg0);
        }
      }
      switch (exit) {
        case 0:
          return (await Promise.all(["\n"])).join("");
        case 1:
          return (await Promise.all([" Pass\n"])).join("");
        case 2:
          return (await Promise.all([
            " ",
            acutis_escape(fmt_int(data1.get("z"))),
            "\n",
          ])).join("");
        default:
          throw new Error(error_pattern_failure);
      }
    })(),
    "",
    (async function () {
      let data1 = new Map(data);
      let exit = null;
      let arg0 = [[10, 20], 99];
      let arg1 = 40;
      switch (arg0[0][0]) {
        case 10:
          switch (arg0[0][1]) {
            case 20:
              switch (arg0[1]) {
                case 30:
                  switch (arg1) {
                    case 40:
                      exit = 1;
                      break;
                    case 41:
                      exit = 0;
                      data1.set("_x", arg0);
                      break;
                    default:
                      exit = 2;
                      data1.set("z", arg1);
                      data1.set("_y", arg0);
                  }
                  break;
              }
              break;
          }
          break;
      }
      if (exit === null) {
        switch (arg1) {
          case 41:
            exit = 0;
            data1.set("_x", arg0);
            break;
          default:
            exit = 2;
            data1.set("z", arg1);
            data1.set("_y", arg0);
        }
      }
      switch (exit) {
        case 0:
          return (await Promise.all(["\n"])).join("");
        case 1:
          return (await Promise.all([" Fail\n"])).join("");
        case 2:
          return (await Promise.all([
            " ",
            acutis_escape(fmt_int(data1.get("z"))),
            "\n",
          ])).join("");
        default:
          throw new Error(error_pattern_failure);
      }
    })(),
    "String encoding\n---------------\n\n😇👨‍💻😇\n\\\" \\ \\ \\\"\n\nExternal JavaScript template component: stringify arbitrary data\n\n",
    (async function () {
      let arg0 = new Map([
        ["int_list", data.get("int_list")],
        ["nested_list", data.get("nested_list")],
        ["nested_nullable_list", data.get("nested_nullable_list")],
        ["null_string_dict", data.get("null_string_dict")],
        ["record", data.get("record")],
        ["tagged_record_bool", data.get("tagged_record_bool")],
        ["tagged_record_int", data.get("tagged_record_int")],
        ["tagged_record_open", data.get("tagged_record_open")],
        ["tagged_record_string", data.get("tagged_record_string")],
        ["unknown", data.get("unknown")],
      ]);
      return template_Stringify(arg0);
    })(),
    "\n",
  ])).join("");
}


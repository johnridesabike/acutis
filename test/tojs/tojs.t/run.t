  $ acutis \
  >   --mode js \
  >   template.acutis \
  >   component.acutis \
  >   unused.acutis \
  >   --fun ./jscomponents.mjs stringify "$(cat stringify_interface)" \
  >   --fun ./jscomponents.mjs another_function "" \
  >   --fun ./jscomponents.mjs an_unused_function "" \
  >   > compiled.mjs

  $ cat compiled.mjs
  /* THIS FILE WAS GENERATED BY ACUTIS. */
  
  import * as External_jscomponents from "./jscomponents.mjs";
  
  function pattern_failure_error() {
    throw new Error("This pattern-matching failed to find a path.\n\
  This probably means there's a problem with the compiler.");
  }
  
  function decode_error(expected, recieved, debug_stack) {
    throw new Error([
      "Decode error in field: ",
      debug_stack.join(" -> "),
      "\n\
  Expected type:\n\
  ",
      expected,
      "\n\
  Recieved value:\n\
  ",
      recieved,
    ].join(""));
  }
  
  function decode_error_field(field, debug_stack) {
    throw new Error([
      "Decode error.\n\
  An object is missing the field:\n\
  ",
      field,
      "\n\
  In field: ",
      debug_stack.join(" -> "),
    ].join(""));
  }
  
  function acutis_escape(str) {
    let result = "";
    for (let index = 0; index < str.length; index++) {
      let c = str[index];
      switch (c) {
        case "&":
          result += "&amp;"
          break;
        case "\"":
          result += "&quot;"
          break;
        case "'":
          result += "&apos;"
          break;
        case ">":
          result += "&gt;"
          break;
        case "<":
          result += "&lt;"
          break;
        case "/":
          result += "&#x2F;"
          break;
        case "`":
          result += "&#x60;"
          break;
        case "=":
          result += "&#x3D;"
          break;
        default:
          result += c
      }
    }
    return result;
  }
  
  async function template_Stringify(input1) {
    let data = new Object();
    let input2 = input1.get("int_list");
    let array1 = new Array();
    data.int_list = array1;
    while (input2 !== null) {
      let input3 = input2[0];
      array1.push(input3);
      input2 = input2[1];
    }
    let input4 = input1.get("nested_list");
    let array2 = new Array();
    data.nested_list = array2;
    while (input4 !== null) {
      let input5 = input4[0];
      let array3 = new Array();
      array2.push(array3);
      while (input5 !== null) {
        let input6 = input5[0];
        let array4 = new Array();
        array3.push(array4);
        while (input6 !== null) {
          let input7 = input6[0];
          array4.push(input7);
          input6 = input6[1];
        }
        input5 = input5[1];
      }
      input4 = input4[1];
    }
    let input8 = input1.get("nested_nullable_list");
    let array5 = new Array();
    data.nested_nullable_list = array5;
    while (input8 !== null) {
      let input9 = input8[0];
      if (input9 === null) {
        array5.push(null);
      } else {
        let input10 = input9[0];
        if (input10 === null) {
          array5.push(null);
        } else {
          let input11 = input10[0];
          if (input11) {
            array5.push(true);
          } else {
            array5.push(false);
          }
        }
      }
      input8 = input8[1];
    }
    let input12 = input1.get("null_string_dict");
    let dict1 = new Object();
    data.null_string_dict = dict1;
    for (let entry of input12) {
      if (entry[1] === null) {
        dict1[entry[0]] = null;
      } else {
        let input13 = entry[1][0];
        dict1[entry[0]] = input13;
      }
    }
    let input14 = input1.get("record");
    let record1 = new Object();
    data.record = record1;
    let input15 = input14.get("int_enum");
    record1.int_enum = input15;
    let input16 = input14.get("string_enum");
    record1.string_enum = input16;
    let input17 = input1.get("tagged_record_bool");
    let union1 = new Object();
    data.tagged_record_bool = union1;
    let input18 = input17.get("tag");
    switch (input18) {
      case 0:
        union1.tag = false;
        let input26 = input17.get("a");
        union1.a = input26;
        break;
      case 1:
        union1.tag = true;
        let input27 = input17.get("b");
        union1.b = input27;
        break;
      default:
        union1.tag = input18;
    }
    let input19 = input1.get("tagged_record_int");
    let union2 = new Object();
    data.tagged_record_int = union2;
    let input20 = input19.get("tag");
    switch (input20) {
      case 0:
        union2.tag = 0;
        break;
      case 1:
        union2.tag = 1;
        let input28 = input19.get("tuple");
        let array6 = new Array(3);
        union2.tuple = array6;
        let input29 = input28[0];
        array6[0] = input29;
        let input30 = input28[1];
        array6[1] = input30;
        let input31 = input28[2];
        if (input31) {
          array6[2] = true;
        } else {
          array6[2] = false;
        }
        break;
      default:
        union2.tag = input20;
    }
    let input21 = input1.get("tagged_record_open");
    let union3 = new Object();
    data.tagged_record_open = union3;
    let input22 = input21.get("tag");
    switch (input22) {
      case 100:
        union3.tag = 100;
        let input32 = input21.get("a");
        union3.a = input32;
        break;
      case 200:
        union3.tag = 200;
        let input33 = input21.get("b");
        union3.b = input33;
        break;
      case 300:
        union3.tag = 300;
        let input34 = input21.get("c");
        union3.c = input34;
        break;
      default:
        union3.tag = input22;
    }
    let input23 = input1.get("tagged_record_string");
    let union4 = new Object();
    data.tagged_record_string = union4;
    let input24 = input23.get("tag");
    switch (input24) {
      case "a":
        union4.tag = "a";
        let input35 = input23.get("record_list");
        let array7 = new Array();
        union4.record_list = array7;
        while (input35 !== null) {
          let input36 = input35[0];
          let record2 = new Object();
          array7.push(record2);
          let input37 = input36.get("job");
          record2.job = input37;
          let input38 = input36.get("name");
          record2.name = input38;
          input35 = input35[1];
        }
        break;
      case "b":
        union4.tag = "b";
        let input39 = input23.get("open_enum");
        union4.open_enum = input39;
        break;
      default:
        union4.tag = input24;
    }
    let input25 = input1.get("unknown");
    data.unknown = input25;
    return External_jscomponents.stringify(data);
  }
  
  async function template_Another_function(input1) {
    let data = new Object();
    return External_jscomponents.another_function(data);
  }
  
  async function template_Component(data) {
    return (await Promise.all([
      acutis_escape(data.get("optional") !== null
        ? data.get("optional").toString()
        : data.get("children")),
      "\n\
  ",
      (async function () {
        let result = [];
        let index = 0;
        let arg0 = data.get("list");
        while (arg0 !== null) {
          let data1 = new Map(data);
          let exit = null;
          exit = 0;
          data1.set("i", arg0[0]);
          switch (exit) {
            case 0:
              result.push(acutis_escape(data1.get("i").toString()));
              break;
            default:
              return pattern_failure_error();
          }
          index++;
          arg0 = arg0[1];
        }
        return (await Promise.all(result)).join("");
      })(),
    ])).join("");
  }
  
  export default async function main(input1) {
    let data = new Map();
    let debug_stack = new Array();
    if ("big_float" in input1) {
      debug_stack.push("big_float");
      let input2 = input1.big_float;
      if (typeof input2 === "number") {
        data.set("big_float", input2);
      } else {
        return decode_error("float", input2, debug_stack);
      }
      debug_stack.pop();
    } else {
      return decode_error_field("big_float", debug_stack);
    }
    if ("big_int" in input1) {
      debug_stack.push("big_int");
      let input3 = input1.big_int;
      if (typeof input3 === "number") {
        data.set("big_int", input3 | 0);
      } else {
        return decode_error("int", input3, debug_stack);
      }
      debug_stack.pop();
    } else {
      return decode_error_field("big_int", debug_stack);
    }
    if ("bool1" in input1) {
      debug_stack.push("bool1");
      let input4 = input1.bool1;
      switch (input4) {
        case false:
          data.set("bool1", 0);
          break;
        case true:
          data.set("bool1", 1);
          break;
        default:
          return decode_error("false | true", input4, debug_stack);
      }
      debug_stack.pop();
    } else {
      return decode_error_field("bool1", debug_stack);
    }
    if ("bool2" in input1) {
      debug_stack.push("bool2");
      let input5 = input1.bool2;
      switch (input5) {
        case false:
          data.set("bool2", 0);
          break;
        case true:
          data.set("bool2", 1);
          break;
        default:
          return decode_error("false | true", input5, debug_stack);
      }
      debug_stack.pop();
    } else {
      return decode_error_field("bool2", debug_stack);
    }
    if ("dangerous" in input1) {
      debug_stack.push("dangerous");
      let input6 = input1.dangerous;
      if (typeof input6 === "string") {
        data.set("dangerous", input6);
      } else {
        return decode_error("string", input6, debug_stack);
      }
      debug_stack.pop();
    } else {
      return decode_error_field("dangerous", debug_stack);
    }
    if ("int_list" in input1) {
      debug_stack.push("int_list");
      let input7 = input1.int_list;
      if (input7 instanceof Array) {
        let dst_base1 = new Array(2);
        let dst1 = dst_base1;
        for (let index = 0; index < input7.length; index++) {
          let input_hd1 = input7[index];
          debug_stack.push(index);
          let dst_new1 = new Array(2);
          if (typeof input_hd1 === "number") {
            dst_new1[0] = input_hd1 | 0;
          } else {
            return decode_error("int", input_hd1, debug_stack);
          }
          dst1[1] = dst_new1;
          dst1 = dst_new1;
          debug_stack.pop();
        }
        dst1[1] = null;
        data.set("int_list", dst_base1[1]);
      } else {
        return decode_error("int", input7, debug_stack);
      }
      debug_stack.pop();
    } else {
      return decode_error_field("int_list", debug_stack);
    }
    if ("nested_list" in input1) {
      debug_stack.push("nested_list");
      let input8 = input1.nested_list;
      if (input8 instanceof Array) {
        let dst_base2 = new Array(2);
        let dst2 = dst_base2;
        for (let index = 0; index < input8.length; index++) {
          let input_hd2 = input8[index];
          debug_stack.push(index);
          let dst_new2 = new Array(2);
          if (input_hd2 instanceof Array) {
            let dst_base3 = new Array(2);
            let dst3 = dst_base3;
            for (let index = 0; index < input_hd2.length; index++) {
              let input_hd3 = input_hd2[index];
              debug_stack.push(index);
              let dst_new3 = new Array(2);
              if (input_hd3 instanceof Array) {
                let dst_base4 = new Array(2);
                let dst4 = dst_base4;
                for (let index = 0; index < input_hd3.length; index++) {
                  let input_hd4 = input_hd3[index];
                  debug_stack.push(index);
                  let dst_new4 = new Array(2);
                  if (typeof input_hd4 === "number") {
                    dst_new4[0] = input_hd4 | 0;
                  } else {
                    return decode_error("int", input_hd4, debug_stack);
                  }
                  dst4[1] = dst_new4;
                  dst4 = dst_new4;
                  debug_stack.pop();
                }
                dst4[1] = null;
                dst_new3[0] = dst_base4[1];
              } else {
                return decode_error("int", input_hd3, debug_stack);
              }
              dst3[1] = dst_new3;
              dst3 = dst_new3;
              debug_stack.pop();
            }
            dst3[1] = null;
            dst_new2[0] = dst_base3[1];
          } else {
            return decode_error("[int]", input_hd2, debug_stack);
          }
          dst2[1] = dst_new2;
          dst2 = dst_new2;
          debug_stack.pop();
        }
        dst2[1] = null;
        data.set("nested_list", dst_base2[1]);
      } else {
        return decode_error("[[int]]", input8, debug_stack);
      }
      debug_stack.pop();
    } else {
      return decode_error_field("nested_list", debug_stack);
    }
    if ("nested_nullable_list" in input1) {
      debug_stack.push("nested_nullable_list");
      let input9 = input1.nested_nullable_list;
      if (input9 instanceof Array) {
        let dst_base5 = new Array(2);
        let dst5 = dst_base5;
        for (let index = 0; index < input9.length; index++) {
          let input_hd5 = input9[index];
          debug_stack.push(index);
          let dst_new5 = new Array(2);
          if (input_hd5 === null || input_hd5 === undefined) {
            dst_new5[0] = null;
          } else {
            let nullable1 = new Array(1);
            dst_new5[0] = nullable1;
            if (input_hd5 === null || input_hd5 === undefined) {
              nullable1[0] = null;
            } else {
              let nullable2 = new Array(1);
              nullable1[0] = nullable2;
              switch (input_hd5) {
                case false:
                  nullable2[0] = 0;
                  break;
                case true:
                  nullable2[0] = 1;
                  break;
                default:
                  return decode_error("false | true", input_hd5, debug_stack);
              }
            }
          }
          dst5[1] = dst_new5;
          dst5 = dst_new5;
          debug_stack.pop();
        }
        dst5[1] = null;
        data.set("nested_nullable_list", dst_base5[1]);
      } else {
        return decode_error("??false | true", input9, debug_stack);
      }
      debug_stack.pop();
    } else {
      return decode_error_field("nested_nullable_list", debug_stack);
    }
    if ("null_string_dict" in input1) {
      debug_stack.push("null_string_dict");
      let input10 = input1.null_string_dict;
      let dict1 = new Map();
      data.set("null_string_dict", dict1);
      for (let key1 in input10) {
        debug_stack.push(key1);
        let input11 = input10[key1];
        if (input11 === null || input11 === undefined) {
          dict1.set(key1, null);
        } else {
          let nullable3 = new Array(1);
          dict1.set(key1, nullable3);
          if (typeof input11 === "string") {
            nullable3[0] = input11;
          } else {
            return decode_error("string", input11, debug_stack);
          }
        }
        debug_stack.pop();
      }
      debug_stack.pop();
    } else {
      return decode_error_field("null_string_dict", debug_stack);
    }
    if ("record" in input1) {
      debug_stack.push("record");
      let input12 = input1.record;
      let record1 = new Map();
      data.set("record", record1);
      if ("int_enum" in input12) {
        debug_stack.push("int_enum");
        let input13 = input12.int_enum;
        switch (input13) {
          case 8:
            record1.set("int_enum", 8);
            break;
          case 40:
            record1.set("int_enum", 40);
            break;
          default:
            return decode_error("@8 | @40", input13, debug_stack);
        }
        debug_stack.pop();
      } else {
        return decode_error_field("int_enum", debug_stack);
      }
      if ("string_enum" in input12) {
        debug_stack.push("string_enum");
        let input14 = input12.string_enum;
        switch (input14) {
          case "no":
            record1.set("string_enum", "no");
            break;
          case "yes":
            record1.set("string_enum", "yes");
            break;
          default:
            return decode_error("@\"no\" | @\"yes\"", input14, debug_stack);
        }
        debug_stack.pop();
      } else {
        return decode_error_field("string_enum", debug_stack);
      }
      debug_stack.pop();
    } else {
      return decode_error_field("record", debug_stack);
    }
    if ("tagged_record_bool" in input1) {
      debug_stack.push("tagged_record_bool");
      let input15 = input1.tagged_record_bool;
      let union1 = new Map();
      data.set("tagged_record_bool", union1);
      let input16 = input15.tag;
      switch (input16) {
        case false:
          union1.set("tag", 0);
          if ("a" in input15) {
            debug_stack.push("a");
            let input24 = input15.a;
            if (typeof input24 === "string") {
              union1.set("a", input24);
            } else {
              return decode_error("string", input24, debug_stack);
            }
            debug_stack.pop();
          } else {
            return decode_error_field("a", debug_stack);
          }
          break;
        case true:
          union1.set("tag", 1);
          if ("b" in input15) {
            debug_stack.push("b");
            let input25 = input15.b;
            if (typeof input25 === "number") {
              union1.set("b", input25 | 0);
            } else {
              return decode_error("int", input25, debug_stack);
            }
            debug_stack.pop();
          } else {
            return decode_error_field("b", debug_stack);
          }
          break;
        default:
          return decode_error(
            "{@tag: false, a: string} | {@tag: true, b: int}",
            input15,
            debug_stack
          );
      }
      debug_stack.pop();
    } else {
      return decode_error_field("tagged_record_bool", debug_stack);
    }
    if ("tagged_record_int" in input1) {
      debug_stack.push("tagged_record_int");
      let input17 = input1.tagged_record_int;
      let union2 = new Map();
      data.set("tagged_record_int", union2);
      let input18 = input17.tag;
      switch (input18) {
        case 0:
          union2.set("tag", 0);
          break;
        case 1:
          union2.set("tag", 1);
          if ("tuple" in input17) {
            debug_stack.push("tuple");
            let input26 = input17.tuple;
            if (input26 instanceof Array && input26.length === 3) {
              let tuple1 = new Array(3);
              union2.set("tuple", tuple1);
              debug_stack.push(0);
              let input27 = input26[0];
              if (typeof input27 === "number") {
                tuple1[0] = input27;
              } else {
                return decode_error("float", input27, debug_stack);
              }
              debug_stack.pop();
              debug_stack.push(1);
              let input28 = input26[1];
              if (typeof input28 === "string") {
                tuple1[1] = input28;
              } else {
                return decode_error("string", input28, debug_stack);
              }
              debug_stack.pop();
              debug_stack.push(2);
              let input29 = input26[2];
              switch (input29) {
                case false:
                  tuple1[2] = 0;
                  break;
                case true:
                  tuple1[2] = 1;
                  break;
                default:
                  return decode_error("false | true", input29, debug_stack);
              }
              debug_stack.pop();
            } else {
              return decode_error(
                "(float, string, false | true)",
                input26,
                debug_stack
              );
            }
            debug_stack.pop();
          } else {
            return decode_error_field("tuple", debug_stack);
          }
          break;
        default:
          return decode_error(
            "{@tag: 0} | {@tag: 1, tuple: (float, string, false | true)}",
            input17,
            debug_stack
          );
      }
      debug_stack.pop();
    } else {
      return decode_error_field("tagged_record_int", debug_stack);
    }
    if ("tagged_record_open" in input1) {
      debug_stack.push("tagged_record_open");
      let input19 = input1.tagged_record_open;
      let union3 = new Map();
      data.set("tagged_record_open", union3);
      let input20 = input19.tag;
      switch (input20) {
        case 100:
          union3.set("tag", 100);
          if ("a" in input19) {
            debug_stack.push("a");
            let input30 = input19.a;
            if (typeof input30 === "number") {
              union3.set("a", input30 | 0);
            } else {
              return decode_error("int", input30, debug_stack);
            }
            debug_stack.pop();
          } else {
            return decode_error_field("a", debug_stack);
          }
          break;
        case 200:
          union3.set("tag", 200);
          if ("b" in input19) {
            debug_stack.push("b");
            let input31 = input19.b;
            if (typeof input31 === "string") {
              union3.set("b", input31);
            } else {
              return decode_error("string", input31, debug_stack);
            }
            debug_stack.pop();
          } else {
            return decode_error_field("b", debug_stack);
          }
          break;
        case 300:
          union3.set("tag", 300);
          if ("c" in input19) {
            debug_stack.push("c");
            let input32 = input19.c;
            if (typeof input32 === "number") {
              union3.set("c", input32);
            } else {
              return decode_error("float", input32, debug_stack);
            }
            debug_stack.pop();
          } else {
            return decode_error_field("c", debug_stack);
          }
          break;
        default:
          if (typeof input20 === "number") {
            union3.set("tag", input20 | 0);
          } else {
            return decode_error("int", input20, debug_stack);
          }
      }
      debug_stack.pop();
    } else {
      return decode_error_field("tagged_record_open", debug_stack);
    }
    if ("tagged_record_string" in input1) {
      debug_stack.push("tagged_record_string");
      let input21 = input1.tagged_record_string;
      let union4 = new Map();
      data.set("tagged_record_string", union4);
      let input22 = input21.tag;
      switch (input22) {
        case "a":
          union4.set("tag", "a");
          if ("record_list" in input21) {
            debug_stack.push("record_list");
            let input33 = input21.record_list;
            if (input33 instanceof Array) {
              let dst_base6 = new Array(2);
              let dst6 = dst_base6;
              for (let index = 0; index < input33.length; index++) {
                let input_hd6 = input33[index];
                debug_stack.push(index);
                let dst_new6 = new Array(2);
                let record2 = new Map();
                dst_new6[0] = record2;
                if ("job" in input_hd6) {
                  debug_stack.push("job");
                  let input34 = input_hd6.job;
                  if (typeof input34 === "string") {
                    record2.set("job", input34);
                  } else {
                    return decode_error("string", input34, debug_stack);
                  }
                  debug_stack.pop();
                } else {
                  return decode_error_field("job", debug_stack);
                }
                if ("name" in input_hd6) {
                  debug_stack.push("name");
                  let input35 = input_hd6.name;
                  if (typeof input35 === "string") {
                    record2.set("name", input35);
                  } else {
                    return decode_error("string", input35, debug_stack);
                  }
                  debug_stack.pop();
                } else {
                  return decode_error_field("name", debug_stack);
                }
                dst6[1] = dst_new6;
                dst6 = dst_new6;
                debug_stack.pop();
              }
              dst6[1] = null;
              union4.set("record_list", dst_base6[1]);
            } else {
              return decode_error(
                "{job: string, name: string}",
                input33,
                debug_stack
              );
            }
            debug_stack.pop();
          } else {
            return decode_error_field("record_list", debug_stack);
          }
          break;
        case "b":
          union4.set("tag", "b");
          if ("open_enum" in input21) {
            debug_stack.push("open_enum");
            let input36 = input21.open_enum;
            if (typeof input36 === "number") {
              union4.set("open_enum", input36 | 0);
            } else {
              return decode_error("@0 | @1 | ...", input36, debug_stack);
            }
            debug_stack.pop();
          } else {
            return decode_error_field("open_enum", debug_stack);
          }
          break;
        default:
          return decode_error(
            "{@tag: \"a\", record_list: [{job: string, name: string}]} |\n\
  {@tag: \"b\", open_enum: @0 | @1 | ...}",
            input21,
            debug_stack
          );
      }
      debug_stack.pop();
    } else {
      return decode_error_field("tagged_record_string", debug_stack);
    }
    if ("unknown" in input1) {
      debug_stack.push("unknown");
      let input23 = input1.unknown;
      data.set("unknown", input23);
      debug_stack.pop();
    } else {
      data.set("unknown", null);
    }
    return (await Promise.all([
      "Formatters\n\
  ----------\n\
  \n\
  %i    ",
      acutis_escape(data.get("big_int").toString()),
      "\n\
  %f    ",
      acutis_escape(data.get("big_float").toString()),
      "\n\
  %b    ",
      acutis_escape(data.get("bool1") ? "true" : "false"),
      "\n\
  %b    ",
      acutis_escape(data.get("bool2") ? "true" : "false"),
      "\n\
  \n\
  Escaping\n\
  --------\n\
  \n\
  Escaped     ",
      acutis_escape(data.get("dangerous")),
      "\n\
  Not escaped ",
      data.get("dangerous"),
      "\n\
  \n\
  Matching\n\
  --------\n\
  \n\
  ",
      (async function () {
        let data1 = new Map(data);
        let exit = null;
        let arg0 = data.get("record").get("int_enum");
        switch (arg0) {
          case 8:
            exit = 0;
            break;
          case 40:
            exit = 1;
            break;
        }
        switch (exit) {
          case 0:
            return (await Promise.all(["8\n\
  "])).join("");
          case 1:
            return (await Promise.all(["40\n\
  "])).join("");
          default:
            return pattern_failure_error();
        }
      })(),
      (async function () {
        let data1 = new Map(data);
        let exit = null;
        let arg0 = data.get("record");
        switch (arg0.get("string_enum")) {
          case "no":
            exit = 1;
            break;
          case "yes":
            exit = 0;
            break;
        }
        switch (exit) {
          case 0:
            return (await Promise.all(["yes\n\
  "])).join("");
          case 1:
            return (await Promise.all(["no\n\
  "])).join("");
          default:
            return pattern_failure_error();
        }
      })(),
      (async function () {
        let data1 = new Map(data);
        let exit = null;
        let arg0 = data.get("tagged_record_bool");
        switch (arg0.get("tag")) {
          case 0:
            exit = 0;
            data1.set("a", arg0.get("a"));
            break;
          case 1:
            exit = 1;
            data1.set("b", arg0.get("b"));
            break;
        }
        switch (exit) {
          case 0:
            return (await Promise.all([
              acutis_escape(data1.get("a")),
              "\n\
  ",
            ])).join("");
          case 1:
            return (await Promise.all([
              acutis_escape(data1.get("b").toString()),
              "\n\
  ",
            ])).join("");
          default:
            return pattern_failure_error();
        }
      })(),
      (async function () {
        let data1 = new Map(data);
        let exit = null;
        let arg0 = data.get("tagged_record_int");
        switch (arg0.get("tag")) {
          case 0:
            exit = 0;
            break;
          case 1:
            exit = 1;
            data1.set("c", arg0.get("tuple")[2]);
            data1.set("b", arg0.get("tuple")[1]);
            data1.set("a", arg0.get("tuple")[0]);
            break;
        }
        switch (exit) {
          case 0:
            return (await Promise.all(["Fail\n\
  "])).join("");
          case 1:
            return (await Promise.all([
              acutis_escape(data1.get("a").toString()),
              " ",
              acutis_escape(data1.get("b")),
              " ",
              acutis_escape(data1.get("c") ? "true" : "false"),
              "\n\
  ",
            ])).join("");
          default:
            return pattern_failure_error();
        }
      })(),
      (async function () {
        let data1 = new Map(data);
        let exit = null;
        let arg0 = data.get("tagged_record_open");
        switch (arg0.get("tag")) {
          case 200:
            exit = 0;
            data1.set("b", arg0.get("b"));
            break;
        }
        if (exit === null) {
          exit = 1;
        }
        switch (exit) {
          case 0:
            return (await Promise.all([
              " ",
              acutis_escape(data1.get("b")),
              "\n\
  ",
            ])).join("");
          case 1:
            return (await Promise.all(["Another tag!\n\
  "])).join("");
          default:
            return pattern_failure_error();
        }
      })(),
      "\n\
  \n\
  Mapping\n\
  -------\n\
  \n\
  ",
      (async function () {
        let result = [];
        let arg0 = data.get("null_string_dict");
        for (let entry of arg0) {
          let data1 = new Map(data);
          let exit = null;
          if (entry[1] === null) {
            exit = 0;
            data1.set("key", entry[0]);
          } else {
            exit = 1;
            data1.set("str", entry[1][0]);
            data1.set("key", entry[0]);
          }
          switch (exit) {
            case 0:
              result.push(acutis_escape(data1.get("key")), " is null.\n\
  ");
              break;
            case 1:
              result.push(
                acutis_escape(data1.get("key")),
                " is ",
                acutis_escape(data1.get("str")),
                "\n\
  "
              );
              break;
            default:
              return pattern_failure_error();
          }
        }
        return (await Promise.all(result)).join("");
      })(),
      (async function () {
        let result = [];
        let index = 0;
        let arg0 = data.get("int_list");
        while (arg0 !== null) {
          let data1 = new Map(data);
          let exit = null;
          exit = 0;
          data1.set("i", arg0[0]);
          switch (exit) {
            case 0:
              result.push(acutis_escape(data1.get("i").toString()), "\n\
  ");
              break;
            default:
              return pattern_failure_error();
          }
          index++;
          arg0 = arg0[1];
        }
        return (await Promise.all(result)).join("");
      })(),
      (async function () {
        let result = [];
        let index = 0;
        let arg0 = data.get("int_list");
        while (arg0 !== null) {
          let data1 = new Map(data);
          let exit = null;
          exit = 0;
          data1.set("key", index);
          data1.set("i", arg0[0]);
          switch (exit) {
            case 0:
              result.push(
                acutis_escape(data1.get("key").toString()),
                " : ",
                acutis_escape(data1.get("i").toString()),
                "\n\
  "
              );
              break;
            default:
              return pattern_failure_error();
          }
          index++;
          arg0 = arg0[1];
        }
        return (await Promise.all(result)).join("");
      })(),
      (async function () {
        let result = [];
        let index = 0;
        let arg0 = data.get("nested_list");
        while (arg0 !== null) {
          let data1 = new Map(data);
          let exit = null;
          exit = 0;
          data1.set("l", arg0[0]);
          switch (exit) {
            case 0:
              result.push((async function () {
                let result = [];
                let index = 0;
                let arg0 = data1.get("l");
                while (arg0 !== null) {
                  let data2 = new Map(data1);
                  let exit = null;
                  exit = 0;
                  data2.set("l2", arg0[0]);
                  switch (exit) {
                    case 0:
                      result.push((async function () {
                        let result = [];
                        let index = 0;
                        let arg0 = data2.get("l2");
                        while (arg0 !== null) {
                          let data3 = new Map(data2);
                          let exit = null;
                          exit = 0;
                          data3.set("i", arg0[0]);
                          switch (exit) {
                            case 0:
                              result.push(
                                acutis_escape(data3.get("i").toString()),
                                " "
                              );
                              break;
                            default:
                              return pattern_failure_error();
                          }
                          index++;
                          arg0 = arg0[1];
                        }
                        return (await Promise.all(result)).join("");
                      })());
                      break;
                    default:
                      return pattern_failure_error();
                  }
                  index++;
                  arg0 = arg0[1];
                }
                return (await Promise.all(result)).join("");
              })());
              break;
            default:
              return pattern_failure_error();
          }
          index++;
          arg0 = arg0[1];
        }
        return (await Promise.all(result)).join("");
      })(),
      "\n\
  \n\
  ",
      (async function () {
        let result = [];
        let index = 0;
        let arg0 = data.get("nested_nullable_list");
        while (arg0 !== null) {
          let data1 = new Map(data);
          let exit = null;
          if (arg0[0] === null) {
            exit = 0;
          } else {
            if (arg0[0][0] === null) {
              exit = 1;
            } else {
              exit = 2;
              data1.set("b", arg0[0][0][0]);
            }
          }
          switch (exit) {
            case 0:
              result.push("Level 1 null\n\
  ");
              break;
            case 1:
              result.push("Level 2 null (This shouldn't render.)\n\
  ");
              break;
            case 2:
              result.push(
                "Level 3 ",
                acutis_escape(data1.get("b") ? "true" : "false"),
                "\n\
  "
              );
              break;
            default:
              return pattern_failure_error();
          }
          index++;
          arg0 = arg0[1];
        }
        return (await Promise.all(result)).join("");
      })(),
      "\n\
  \n\
  Constructing async blocks\n\
  -------------------------\n\
  \n\
  ",
      (async function () {
        let data1 = new Map(data);
        let exit = null;
        let resolved1 = (await Promise.all([
          " Another nested block",
        ])).join("");
        let resolved0 = (await Promise.all([" Nested block"])).join("");
        let arg0 = new Map([["a", resolved0], ["b", resolved1]]);
        exit = 0;
        data1.set("b", arg0.get("b"));
        data1.set("a", arg0.get("a"));
        switch (exit) {
          case 0:
            return (await Promise.all([
              acutis_escape(data1.get("a")),
              " ",
              acutis_escape(data1.get("b")),
              "\n\
  ",
            ])).join("");
          default:
            return pattern_failure_error();
        }
      })(),
      "Component\n\
  ---------\n\
  \n\
  ",
      (async function () {
        let resolved0 = (await Promise.all(["Children prop"])).join("");
        let arg0 = new Map([
          ["children", resolved0],
          ["list", [1, [2, [3, null]]]],
          ["optional", null],
        ]);
        return template_Component(arg0);
      })(),
      "\n\
  \n\
  ",
      (async function () {
        let arg0 = new Map([]);
        return template_Another_function(arg0);
      })(),
      "\n\
  \n\
  Complicated pattern matching\n\
  ----------------------------\n\
  \n\
  ",
      (async function () {
        let data1 = new Map(data);
        let exit = null;
        let arg0 = 1;
        let arg1 = null;
        let arg2 = 3;
        switch (arg0) {
          case 1:
            if (arg1 === null) {
              switch (arg2) {
                case 0:
                  exit = 0;
                  break;
                default:
                  exit = 2;
                  data1.set("y", arg2);
              }
            } else {
              switch (arg1[0]) {
                case 1:
                  switch (arg2) {
                    case 0:
                      exit = 0;
                      break;
                    case 1:
                      exit = 3;
                      break;
                    default:
                      exit = 4;
                  }
                  break;
              }
              if (exit === null) {
                switch (arg2) {
                  case 0:
                    exit = 0;
                    break;
                  default:
                    exit = 4;
                }
              }
            }
            break;
          default:
            if (arg1 === null) {
              exit = 2;
              data1.set("y", arg2);
            } else {
              switch (arg1[0]) {
                case 1:
                  switch (arg2) {
                    case 0:
                      exit = 1;
                      data1.set("x", arg0);
                      break;
                    default:
                      exit = 4;
                  }
                  break;
              }
              if (exit === null) {
                exit = 4;
              }
            }
        }
        switch (exit) {
          case 0:
            return (await Promise.all([" 0\n\
  "])).join("");
          case 1:
            return (await Promise.all([
              " 1 ",
              acutis_escape(data1.get("x").toString()),
              "\n\
  ",
            ])).join("");
          case 2:
            return (await Promise.all([
              " 2 ",
              acutis_escape(data1.get("y").toString()),
              "\n\
  ",
            ])).join("");
          case 3:
            return (await Promise.all([" 3\n\
  "])).join("");
          case 4:
            return (await Promise.all([" 4\n\
  "])).join("");
          default:
            return pattern_failure_error();
        }
      })(),
      (async function () {
        let data1 = new Map(data);
        let exit = null;
        let arg0 = [[10, 20], 30];
        let arg1 = 40;
        switch (arg0[0][0]) {
          case 10:
            switch (arg0[0][1]) {
              case 20:
                switch (arg0[1]) {
                  case 30:
                    switch (arg1) {
                      case 40:
                        exit = 1;
                        break;
                      case 41:
                        exit = 0;
                        data1.set("_x", arg0);
                        break;
                      default:
                        exit = 2;
                        data1.set("z", arg1);
                        data1.set("_y", arg0);
                    }
                    break;
                }
                break;
            }
            break;
        }
        if (exit === null) {
          switch (arg1) {
            case 41:
              exit = 0;
              data1.set("_x", arg0);
              break;
            default:
              exit = 2;
              data1.set("z", arg1);
              data1.set("_y", arg0);
          }
        }
        switch (exit) {
          case 0:
            return (await Promise.all(["\n\
  "])).join("");
          case 1:
            return (await Promise.all([" Pass\n\
  "])).join("");
          case 2:
            return (await Promise.all([
              " ",
              acutis_escape(data1.get("z").toString()),
              "\n\
  ",
            ])).join("");
          default:
            return pattern_failure_error();
        }
      })(),
      (async function () {
        let data1 = new Map(data);
        let exit = null;
        let arg0 = [[10, 20], 99];
        let arg1 = 40;
        switch (arg0[0][0]) {
          case 10:
            switch (arg0[0][1]) {
              case 20:
                switch (arg0[1]) {
                  case 30:
                    switch (arg1) {
                      case 40:
                        exit = 1;
                        break;
                      case 41:
                        exit = 0;
                        data1.set("_x", arg0);
                        break;
                      default:
                        exit = 2;
                        data1.set("z", arg1);
                        data1.set("_y", arg0);
                    }
                    break;
                }
                break;
            }
            break;
        }
        if (exit === null) {
          switch (arg1) {
            case 41:
              exit = 0;
              data1.set("_x", arg0);
              break;
            default:
              exit = 2;
              data1.set("z", arg1);
              data1.set("_y", arg0);
          }
        }
        switch (exit) {
          case 0:
            return (await Promise.all(["\n\
  "])).join("");
          case 1:
            return (await Promise.all([" Fail\n\
  "])).join("");
          case 2:
            return (await Promise.all([
              " ",
              acutis_escape(data1.get("z").toString()),
              "\n\
  ",
            ])).join("");
          default:
            return pattern_failure_error();
        }
      })(),
      "String encoding\n\
  ---------------\n\
  \n\
  ðŸ˜‡ðŸ‘¨â€ðŸ’»ðŸ˜‡\n\
  \\\" \\ \\ \\\"\n\
  \n\
  External JavaScript template component: stringify arbitrary data\n\
  \n\
  ",
      (async function () {
        let arg0 = new Map([
          ["int_list", data.get("int_list")],
          ["nested_list", data.get("nested_list")],
          ["nested_nullable_list", data.get("nested_nullable_list")],
          ["null_string_dict", data.get("null_string_dict")],
          ["record", data.get("record")],
          ["tagged_record_bool", data.get("tagged_record_bool")],
          ["tagged_record_int", data.get("tagged_record_int")],
          ["tagged_record_open", data.get("tagged_record_open")],
          ["tagged_record_string", data.get("tagged_record_string")],
          ["unknown", data.get("unknown")],
        ]);
        return template_Stringify(arg0);
      })(),
      "\n\
  ",
    ])).join("");
  }
  

  $ cat > run.mjs << EOF
  >   import main from "./compiled.mjs";
  >   let result = await main({
  >     big_int: 100_000_000,
  >     big_float: 1234.56789,
  >     bool1: true,
  >     bool2: false,
  >     dangerous: "&\"'></\`=",
  >     record: { int_enum: 8, string_enum: "yes" },
  >     tagged_record_bool: { tag: false, a: "a" },
  >     null_string_dict: { a: "a", b: null },
  >     int_list: [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5],
  >     tagged_record_int: { tag: 1, tuple: [1.5, "snd", true] },
  >     tagged_record_string: {
  >       tag: "a",
  >       record_list: [{ name: "John", job: "librarian" }],
  >     },
  >     tagged_record_open: {
  >       tag: 999,
  >       b: "200",
  >     },
  >     unknown: new Date("2023-04-09T00:00:00.000Z"),
  >     nested_list: [
  >       [
  >         [1, 1, 1],
  >         [2, 2, 2],
  >       ],
  >       [[3, 3, 3]],
  >     ],
  >     nested_nullable_list: [null, true, false, null],
  >   });
  >   process.stdout.write(result);
  > EOF

  $ node run.mjs
  Formatters
  ----------
  
  %i    100000000
  %f    1234.56789
  %b    true
  %b    false
  
  Escaping
  --------
  
  Escaped     &amp;&quot;&apos;&gt;&lt;&#x2F;&#x60;&#x3D;
  Not escaped &"'></`=
  
  Matching
  --------
  
  8
  yes
  a
  1.5 snd true
  Another tag!
  
  
  Mapping
  -------
  
  a is a
  b is null.
  -5
  -4
  -3
  -2
  -1
  0
  1
  2
  3
  4
  5
  0 : -5
  1 : -4
  2 : -3
  3 : -2
  4 : -1
  5 : 0
  6 : 1
  7 : 2
  8 : 3
  9 : 4
  10 : 5
  1 1 1 2 2 2 3 3 3 
  
  Level 1 null
  Level 3 true
  Level 3 false
  Level 1 null
  
  
  Constructing async blocks
  -------------------------
  
   Nested block  Another nested block
  Component
  ---------
  
  Children prop
  123
  
  success
  
  Complicated pattern matching
  ----------------------------
  
   2 3
   Pass
   40
  String encoding
  ---------------
  
  ðŸ˜‡ðŸ‘¨â€ðŸ’»ðŸ˜‡
  \" \ \ \"
  
  External JavaScript template component: stringify arbitrary data
  
  {
    "int_list": [
      -5,
      -4,
      -3,
      -2,
      -1,
      0,
      1,
      2,
      3,
      4,
      5
    ],
    "nested_list": [
      [
        [
          1,
          1,
          1
        ],
        [
          2,
          2,
          2
        ]
      ],
      [
        [
          3,
          3,
          3
        ]
      ]
    ],
    "nested_nullable_list": [
      null,
      true,
      false,
      null
    ],
    "null_string_dict": {
      "a": "a",
      "b": null
    },
    "record": {
      "int_enum": 8,
      "string_enum": "yes"
    },
    "tagged_record_bool": {
      "tag": false,
      "a": "a"
    },
    "tagged_record_int": {
      "tag": 1,
      "tuple": [
        1.5,
        "snd",
        true
      ]
    },
    "tagged_record_open": {
      "tag": 999
    },
    "tagged_record_string": {
      "tag": "a",
      "record_list": [
        {
          "job": "librarian",
          "name": "John"
        }
      ]
    },
    "unknown": "2023-04-09T00:00:00.000Z"
  }

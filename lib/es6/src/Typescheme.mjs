// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "@rescript/std/lib/es6/belt_Array.js";
import * as Belt_MapInt from "@rescript/std/lib/es6/belt_MapInt.js";
import * as Belt_SetInt from "@rescript/std/lib/es6/belt_SetInt.js";
import * as Belt_MapString from "@rescript/std/lib/es6/belt_MapString.js";
import * as Belt_SetString from "@rescript/std/lib/es6/belt_SetString.js";

function string(a, row) {
  return {
          cases: {
            TAG: /* String */1,
            _0: Belt_SetString.fromArray(a)
          },
          row: row,
          extra: /* Extra_none */0
        };
}

function string_singleton(s, row) {
  return {
          cases: {
            TAG: /* String */1,
            _0: Belt_SetString.add(undefined, s)
          },
          row: row,
          extra: /* Extra_none */0
        };
}

function $$int(a, row) {
  return {
          cases: {
            TAG: /* Int */0,
            _0: Belt_SetInt.fromArray(a)
          },
          row: row,
          extra: /* Extra_none */0
        };
}

function int_singleton(i, row) {
  return {
          cases: {
            TAG: /* Int */0,
            _0: Belt_SetInt.add(undefined, i)
          },
          row: row,
          extra: /* Extra_none */0
        };
}

var false_and_true_cases = {
  TAG: /* Int */0,
  _0: Belt_SetInt.fromArray([
        0,
        1
      ])
};

var false_only = {
  TAG: /* Int */0,
  _0: Belt_SetInt.add(undefined, 0)
};

var true_only = {
  TAG: /* Int */0,
  _0: Belt_SetInt.add(undefined, 1)
};

function false_and_true(param) {
  return {
          cases: false_and_true_cases,
          row: /* Closed */0,
          extra: /* Extra_boolean */1
        };
}

function true_only$1(param) {
  return {
          cases: true_only,
          row: /* Closed */0,
          extra: /* Extra_boolean */1
        };
}

function false_only$1(param) {
  return {
          cases: false_only,
          row: /* Closed */0,
          extra: /* Extra_boolean */1
        };
}

function string$1(a, row) {
  return {
          cases: {
            TAG: /* String */1,
            _0: Belt_MapString.fromArray(a)
          },
          row: row,
          extra: /* Extra_none */0
        };
}

function $$int$1(a, row) {
  return {
          cases: {
            TAG: /* Int */0,
            _0: Belt_MapInt.fromArray(a)
          },
          row: row,
          extra: /* Extra_none */0
        };
}

function $$boolean(f, t, row) {
  return {
          cases: {
            TAG: /* Int */0,
            _0: Belt_MapInt.set(Belt_MapInt.set(undefined, 0, f), 1, t)
          },
          row: row,
          extra: /* Extra_boolean */1
        };
}

function internal_dict_keys(t, kys) {
  return {
          contents: {
            TAG: /* Dict */4,
            _0: t,
            _1: kys
          }
        };
}

function internal_record(m) {
  return {
          contents: {
            TAG: /* Record */3,
            _0: m
          }
        };
}

function copy(x) {
  if (typeof x === "number") {
    return x;
  }
  switch (x.TAG | 0) {
    case /* Nullable */0 :
        var contents = x._0.contents;
        return {
                TAG: /* Nullable */0,
                _0: {
                  contents: copy(contents)
                }
              };
    case /* List */1 :
        var contents$1 = x._0.contents;
        return {
                TAG: /* List */1,
                _0: {
                  contents: copy(contents$1)
                }
              };
    case /* Tuple */2 :
        return {
                TAG: /* Tuple */2,
                _0: Belt_Array.mapU(x._0, (function (param) {
                        var contents = param.contents;
                        return {
                                contents: copy(contents)
                              };
                      }))
              };
    case /* Record */3 :
        var contents$2 = x._0.contents;
        return {
                TAG: /* Record */3,
                _0: {
                  contents: internal_copy_record(contents$2)
                }
              };
    case /* Dict */4 :
        var contents$3 = x._0.contents;
        return {
                TAG: /* Dict */4,
                _0: {
                  contents: copy(contents$3)
                },
                _1: x._1
              };
    case /* Enum */5 :
        var match = x._0;
        var cases = match.cases;
        var row = match.row;
        return {
                TAG: /* Enum */5,
                _0: {
                  cases: cases,
                  row: row,
                  extra: match.extra
                }
              };
    case /* Union */6 :
        var match$1 = x._1;
        var cases$1 = match$1.cases;
        var row$1 = match$1.row;
        var cases$2;
        cases$2 = cases$1.TAG === /* Int */0 ? ({
              TAG: /* Int */0,
              _0: Belt_MapInt.mapU(cases$1._0, (function (param) {
                      var contents = param.contents;
                      return {
                              contents: internal_copy_record(contents)
                            };
                    }))
            }) : ({
              TAG: /* String */1,
              _0: Belt_MapString.mapU(cases$1._0, (function (param) {
                      var contents = param.contents;
                      return {
                              contents: internal_copy_record(contents)
                            };
                    }))
            });
        return {
                TAG: /* Union */6,
                _0: x._0,
                _1: {
                  cases: cases$2,
                  row: row$1,
                  extra: match$1.extra
                }
              };
    
  }
}

function internal_copy_record(m) {
  return Belt_MapString.mapU(m, (function (param) {
                var contents = param.contents;
                return {
                        contents: copy(contents)
                      };
              }));
}

function unknown(param) {
  return {
          contents: /* Unknown */0
        };
}

function $$int$2(param) {
  return {
          contents: /* Int */1
        };
}

function $$float(param) {
  return {
          contents: /* Float */2
        };
}

function string$2(param) {
  return {
          contents: /* String */3
        };
}

function echo(param) {
  return {
          contents: /* Echo */4
        };
}

function nullable(t) {
  return {
          contents: {
            TAG: /* Nullable */0,
            _0: t
          }
        };
}

function list(t) {
  return {
          contents: {
            TAG: /* List */1,
            _0: t
          }
        };
}

function tuple(a) {
  return {
          contents: {
            TAG: /* Tuple */2,
            _0: a
          }
        };
}

function record(a) {
  return {
          contents: {
            TAG: /* Record */3,
            _0: {
              contents: Belt_MapString.fromArray(a)
            }
          }
        };
}

function dict(t) {
  return {
          contents: {
            TAG: /* Dict */4,
            _0: t,
            _1: {
              contents: undefined
            }
          }
        };
}

function enum_int(a) {
  return {
          contents: {
            TAG: /* Enum */5,
            _0: $$int(a, /* Closed */0)
          }
        };
}

function enum_string(a) {
  return {
          contents: {
            TAG: /* Enum */5,
            _0: string(a, /* Closed */0)
          }
        };
}

function bool(param) {
  return {
          contents: {
            TAG: /* Enum */5,
            _0: {
              cases: false_and_true_cases,
              row: /* Closed */0,
              extra: /* Extra_boolean */1
            }
          }
        };
}

function union_int(k, a) {
  return {
          contents: {
            TAG: /* Union */6,
            _0: k,
            _1: $$int$1(Belt_Array.mapU(a, (function (param) {
                        return [
                                param[0],
                                {
                                  contents: Belt_MapString.fromArray(param[1])
                                }
                              ];
                      })), /* Closed */0)
          }
        };
}

function union_string(k, a) {
  return {
          contents: {
            TAG: /* Union */6,
            _0: k,
            _1: string$1(Belt_Array.mapU(a, (function (param) {
                        return [
                                param[0],
                                {
                                  contents: Belt_MapString.fromArray(param[1])
                                }
                              ];
                      })), /* Closed */0)
          }
        };
}

function union_boolean(k, f, t) {
  return {
          contents: {
            TAG: /* Union */6,
            _0: k,
            _1: $$boolean({
                  contents: Belt_MapString.fromArray(f)
                }, {
                  contents: Belt_MapString.fromArray(t)
                }, /* Closed */0)
          }
        };
}

var make = Belt_MapString.fromArray;

function bool_toString(i) {
  if (i !== 0) {
    return "true";
  } else {
    return "false";
  }
}

function toString(x) {
  var x$1 = x.contents;
  if (typeof x$1 === "number") {
    switch (x$1) {
      case /* Unknown */0 :
          return "_";
      case /* Int */1 :
          return "int";
      case /* Float */2 :
          return "float";
      case /* String */3 :
          return "string";
      case /* Echo */4 :
          return "echoable";
      
    }
  } else {
    switch (x$1.TAG | 0) {
      case /* Nullable */0 :
          return "?" + toString(x$1._0);
      case /* List */1 :
          return "[" + toString(x$1._0) + "]";
      case /* Tuple */2 :
          var x$2 = Belt_Array.joinWith(x$1._0, ", ", toString);
          return "(" + x$2 + ")";
      case /* Record */3 :
          var rows = record_rows_toString(Belt_MapString.toArray(x$1._0.contents));
          return "{" + rows + "}";
      case /* Dict */4 :
          return "<" + toString(x$1._0) + ">";
      case /* Enum */5 :
          var match = x$1._0;
          var cases = match.cases;
          var row = match.row;
          var s;
          if (cases.TAG === /* Int */0) {
            var cases$1 = cases._0;
            s = match.extra ? Belt_Array.joinWith(Belt_SetInt.toArray(cases$1), " | ", bool_toString) : Belt_Array.joinWithU(Belt_SetInt.toArray(cases$1), " | ", (function (i) {
                      return "@" + String(i);
                    }));
          } else {
            s = Belt_Array.joinWithU(Belt_SetString.toArray(cases._0), " | ", (function (s) {
                    return "@\"" + s + "\"";
                  }));
          }
          return s + (
                  row ? " | ..." : ""
                );
      case /* Union */6 :
          var match$1 = x$1._1;
          var key = x$1._0;
          var cases$2 = match$1.cases;
          var row$1 = match$1.row;
          var cases$3;
          if (cases$2.TAG === /* Int */0) {
            var m = cases$2._0;
            cases$3 = match$1.extra ? Belt_Array.mapU(Belt_MapInt.toArray(m), (function (param) {
                      return [
                              bool_toString(param[0]),
                              param[1]
                            ];
                    })) : Belt_Array.mapU(Belt_MapInt.toArray(m), (function (param) {
                      return [
                              String(param[0]),
                              param[1]
                            ];
                    }));
          } else {
            cases$3 = Belt_Array.mapU(Belt_MapString.toArray(cases$2._0), (function (param) {
                    return [
                            "\"" + param[0] + "\"",
                            param[1]
                          ];
                  }));
          }
          return Belt_Array.joinWithU(cases$3, " | ", (function (param) {
                        var rows = record_rows_toString(Belt_MapString.toArray(param[1].contents));
                        var rows$1 = rows === "" ? "" : ", " + rows;
                        return "{@\"" + key + "\": " + param[0] + rows$1 + "}";
                      })) + (
                  row$1 ? " | ..." : ""
                );
      
    }
  }
}

function record_rows_toString(a) {
  return Belt_Array.joinWithU(a, ", ", (function (param) {
                return "\"" + param[0] + "\": " + toString(param[1]);
              }));
}

function toString2(t) {
  return record_rows_toString(Belt_MapString.toArray(t));
}

var make$1 = Belt_MapString.fromArray;

function child(x) {
  return [
          x,
          {
            contents: /* Child */0
          }
        ];
}

function nullable$1(x) {
  return [
          x,
          {
            contents: /* NullableChild */1
          }
        ];
}

function equal(a, b) {
  return a.contents === b.contents;
}

function is_nullable(t) {
  return t.contents === /* NullableChild */1;
}

function toString$1(x) {
  var match = x.contents;
  if (match) {
    return "NullableChild";
  } else {
    return "Child";
  }
}

var Child = {
  make: make$1,
  child: child,
  nullable: nullable$1,
  equal: equal,
  is_nullable: is_nullable,
  toString: toString$1
};

var Variant = {};

var Enum = {
  string: string,
  string_singleton: string_singleton,
  $$int: $$int,
  int_singleton: int_singleton,
  false_and_true_cases: false_and_true_cases,
  false_and_true: false_and_true,
  false_only: false_only$1,
  true_only: true_only$1
};

var Union = {};

var int_ = $$int$2;

var float_ = $$float;

export {
  Variant ,
  Enum ,
  Union ,
  internal_dict_keys ,
  internal_record ,
  internal_copy_record ,
  unknown ,
  $$int$2 as $$int,
  int_ ,
  $$float ,
  float_ ,
  string$2 as string,
  echo ,
  nullable ,
  list ,
  tuple ,
  record ,
  dict ,
  enum_int ,
  enum_string ,
  bool ,
  union_int ,
  union_string ,
  union_boolean ,
  make ,
  toString ,
  toString2 ,
  Child ,
  
}
/* false_and_true_cases Not a pure module */

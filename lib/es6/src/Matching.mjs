// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_List from "@rescript/std/lib/es6/belt_List.js";
import * as Belt_Array from "@rescript/std/lib/es6/belt_Array.js";
import * as Belt_SetInt from "@rescript/std/lib/es6/belt_SetInt.js";
import * as Belt_MapString from "@rescript/std/lib/es6/belt_MapString.js";
import * as Belt_SetString from "@rescript/std/lib/es6/belt_SetString.js";
import * as Caml_exceptions from "@rescript/std/lib/es6/caml_exceptions.js";
import * as Data$AcutisLang from "./Data.mjs";
import * as Debug$AcutisLang from "./Debug.mjs";
import * as Belt_MutableQueue from "@rescript/std/lib/es6/belt_MutableQueue.js";
import * as Caml_js_exceptions from "@rescript/std/lib/es6/caml_js_exceptions.js";
import * as NonEmpty$AcutisLang from "./NonEmpty.mjs";
import * as Typechecker$AcutisLang from "./Typechecker.mjs";

var get = Belt_Array.getExn;

var map = Belt_Array.mapU;

function unsafe_key(i) {
  return i;
}

var Exit = {
  get: get,
  map: map,
  unsafe_key: unsafe_key
};

function reverseCases(_tail, _t) {
  while(true) {
    var t = _t;
    var tail = _tail;
    var tail_val = t.val;
    var tail_ifMatch = t.ifMatch;
    var tail$1 = {
      val: tail_val,
      ifMatch: tail_ifMatch,
      nextCase: tail
    };
    var t$1 = t.nextCase;
    if (t$1 === undefined) {
      return tail$1;
    }
    _t = t$1;
    _tail = tail$1;
    continue ;
  };
}

var MergeFail = /* @__PURE__ */Caml_exceptions.create("Matching-AcutisLang.MergeFail");

function mergeTestCasesAux(_init, _original, val, ifMatch, n) {
  while(true) {
    var original = _original;
    var init = _init;
    var cmp = Data$AcutisLang.Const.compare(val, original.val);
    if (cmp < 0) {
      var tail_nextCase = original;
      var tail = {
        val: val,
        ifMatch: ifMatch,
        nextCase: tail_nextCase
      };
      if (init !== undefined) {
        return reverseCases(tail, init);
      } else {
        return tail;
      }
    }
    if (cmp === 0) {
      try {
        var tail_val = original.val;
        var tail_ifMatch = merge(original.ifMatch, ifMatch, n);
        var tail_nextCase$1 = original.nextCase;
        var tail$1 = {
          val: tail_val,
          ifMatch: tail_ifMatch,
          nextCase: tail_nextCase$1
        };
        if (init !== undefined) {
          return reverseCases(tail$1, init);
        } else {
          return tail$1;
        }
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === MergeFail) {
          return ;
        }
        throw exn;
      }
    } else {
      var init_val = original.val;
      var init_ifMatch = original.ifMatch;
      var init$1 = {
        val: init_val,
        ifMatch: init_ifMatch,
        nextCase: init
      };
      var original$1 = original.nextCase;
      if (original$1 === undefined) {
        return reverseCases({
                    val: val,
                    ifMatch: ifMatch,
                    nextCase: undefined
                  }, init$1);
      }
      _original = original$1;
      _init = init$1;
      continue ;
    }
  };
}

function mergeTestCases(_original, _param, n, _success) {
  while(true) {
    var param = _param;
    var success = _success;
    var original = _original;
    var nextCase = param.nextCase;
    var result = mergeTestCasesAux(undefined, original, param.val, param.ifMatch, n);
    if (result !== undefined) {
      if (nextCase === undefined) {
        return result;
      }
      _success = true;
      _param = nextCase;
      _original = result;
      continue ;
    }
    if (nextCase === undefined) {
      if (success) {
        return original;
      } else {
        return ;
      }
    }
    _param = nextCase;
    continue ;
  };
}

function mergeTestCasesIntoWildcard(_init, wildcard, _t, n) {
  while(true) {
    var t = _t;
    var init = _init;
    var init$1;
    try {
      init$1 = {
        val: t.val,
        ifMatch: merge(wildcard, t.ifMatch, n),
        nextCase: init
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === MergeFail) {
        init$1 = init;
      } else {
        throw exn;
      }
    }
    var match = t.nextCase;
    if (match === undefined) {
      if (init$1 !== undefined) {
        return reverseCases(undefined, init$1);
      } else {
        return ;
      }
    }
    _t = match;
    _init = init$1;
    continue ;
  };
}

function expandWildcardIntoTestCases(_init, _param, wildcard, n) {
  while(true) {
    var param = _param;
    var init = _init;
    var nextCase = param.nextCase;
    var ifMatch = param.ifMatch;
    var val = param.val;
    var init$1;
    try {
      init$1 = {
        val: val,
        ifMatch: merge(ifMatch, wildcard, n),
        nextCase: init
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === MergeFail) {
        init$1 = {
          val: val,
          ifMatch: ifMatch,
          nextCase: init
        };
      } else {
        throw exn;
      }
    }
    if (nextCase === undefined) {
      return reverseCases(undefined, init$1);
    }
    _param = nextCase;
    _init = init$1;
    continue ;
  };
}

function expandWildcardAfterNest(a, na, wildcard, nb) {
  switch (a.TAG | 0) {
    case /* Switch */0 :
        var a$1 = a.wildcard;
        var wildcard$p = a$1 !== undefined ? expandWildcardAfterNest(a$1, na, wildcard, nb) : undefined;
        var _init;
        var _case = a.cases;
        while(true) {
          var $$case = _case;
          var init = _init;
          var ifMatch = expandWildcardAfterNest($$case.ifMatch, na, wildcard, nb);
          var init_val = $$case.val;
          var init$1 = {
            val: init_val,
            ifMatch: ifMatch,
            nextCase: init
          };
          var a$2 = $$case.nextCase;
          if (a$2 === undefined) {
            return {
                    TAG: /* Switch */0,
                    key: a.key,
                    ids: a.ids,
                    cases: reverseCases(undefined, init$1),
                    extra: a.extra,
                    wildcard: wildcard$p
                  };
          }
          _case = a$2;
          _init = init$1;
          continue ;
        };
    case /* Nest */1 :
        var child = a.child;
        var child$1;
        child$1 = child.TAG === /* IntKeys */0 ? ({
              TAG: /* IntKeys */0,
              _0: expandWildcardAfterNest(child._0, /* S */{
                    _0: na
                  }, wildcard, /* S */{
                    _0: nb
                  })
            }) : ({
              TAG: /* StringKeys */1,
              _0: expandWildcardAfterNest(child._0, /* S */{
                    _0: na
                  }, wildcard, /* S */{
                    _0: nb
                  })
            });
        return {
                TAG: /* Nest */1,
                key: a.key,
                ids: a.ids,
                child: child$1,
                wildcard: a.wildcard,
                extra: a.extra
              };
    case /* Construct */2 :
        var child$2 = a.nil;
        var child$3 = a.cons;
        return {
                TAG: /* Construct */2,
                key: a.key,
                ids: a.ids,
                nil: child$2 !== undefined ? expandWildcardAfterNest(child$2, na, wildcard, nb) : undefined,
                cons: child$3 !== undefined ? expandWildcardAfterNest(child$3, na, wildcard, nb) : undefined,
                extra: a.extra
              };
    case /* Wildcard */3 :
        return {
                TAG: /* Wildcard */3,
                key: a.key,
                ids: a.ids,
                child: expandWildcardAfterNest(a.child, na, wildcard, nb)
              };
    case /* End */4 :
        if (na) {
          var n = na._0;
          var a$3 = a._0;
          if (nb) {
            return {
                    TAG: /* End */4,
                    _0: expandWildcardAfterNest(a$3, n, wildcard, nb._0)
                  };
          }
          try {
            return {
                    TAG: /* End */4,
                    _0: merge(a$3, wildcard, n)
                  };
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.RE_EXN_ID === MergeFail) {
              return {
                      TAG: /* End */4,
                      _0: a$3
                    };
            }
            throw exn;
          }
        } else {
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "Matching.res",
                  296,
                  24
                ],
                Error: new Error()
              };
        }
    
  }
}

function mergeWildcardAfterNest(wildcard, na, b, nb) {
  switch (b.TAG | 0) {
    case /* Switch */0 :
        var b$1 = b.wildcard;
        var wildcard$p;
        if (b$1 !== undefined) {
          try {
            wildcard$p = mergeWildcardAfterNest(wildcard, na, b$1, nb);
          }
          catch (raw_exn){
            var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.RE_EXN_ID === MergeFail) {
              wildcard$p = undefined;
            } else {
              throw exn;
            }
          }
        } else {
          wildcard$p = undefined;
        }
        var _init;
        var _case = b.cases;
        while(true) {
          var $$case = _case;
          var init = _init;
          var init$1;
          try {
            var ifMatch = mergeWildcardAfterNest(wildcard, na, $$case.ifMatch, nb);
            init$1 = {
              val: $$case.val,
              ifMatch: ifMatch,
              nextCase: init
            };
          }
          catch (raw_exn$1){
            var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
            if (exn$1.RE_EXN_ID === MergeFail) {
              init$1 = init;
            } else {
              throw exn$1;
            }
          }
          var match = $$case.nextCase;
          if (match !== undefined) {
            _case = match;
            _init = init$1;
            continue ;
          }
          if (init$1 !== undefined) {
            return {
                    TAG: /* Switch */0,
                    key: b.key,
                    ids: b.ids,
                    cases: reverseCases(undefined, init$1),
                    extra: b.extra,
                    wildcard: wildcard$p
                  };
          }
          throw {
                RE_EXN_ID: MergeFail,
                Error: new Error()
              };
        };
    case /* Nest */1 :
        var child = b.child;
        var child$1;
        child$1 = child.TAG === /* IntKeys */0 ? ({
              TAG: /* IntKeys */0,
              _0: mergeWildcardAfterNest(wildcard, /* S */{
                    _0: na
                  }, child._0, /* S */{
                    _0: nb
                  })
            }) : ({
              TAG: /* StringKeys */1,
              _0: mergeWildcardAfterNest(wildcard, /* S */{
                    _0: na
                  }, child._0, /* S */{
                    _0: nb
                  })
            });
        return {
                TAG: /* Nest */1,
                key: b.key,
                ids: b.ids,
                child: child$1,
                wildcard: b.wildcard,
                extra: b.extra
              };
    case /* Construct */2 :
        var child$2 = b.nil;
        var nil;
        if (child$2 !== undefined) {
          try {
            nil = {
              TAG: /* Ok */0,
              _0: mergeWildcardAfterNest(wildcard, na, child$2, nb)
            };
          }
          catch (raw_exn$2){
            var exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
            if (exn$2.RE_EXN_ID === MergeFail) {
              nil = {
                TAG: /* Error */1,
                _0: undefined
              };
            } else {
              throw exn$2;
            }
          }
        } else {
          nil = {
            TAG: /* Ok */0,
            _0: undefined
          };
        }
        var child$3 = b.cons;
        var cons;
        if (child$3 !== undefined) {
          try {
            cons = {
              TAG: /* Ok */0,
              _0: mergeWildcardAfterNest(wildcard, na, child$3, nb)
            };
          }
          catch (raw_exn$3){
            var exn$3 = Caml_js_exceptions.internalToOCamlException(raw_exn$3);
            if (exn$3.RE_EXN_ID === MergeFail) {
              cons = {
                TAG: /* Error */1,
                _0: undefined
              };
            } else {
              throw exn$3;
            }
          }
        } else {
          cons = {
            TAG: /* Ok */0,
            _0: undefined
          };
        }
        var nil$1;
        var cons$1;
        if (nil.TAG === /* Ok */0) {
          var nil$2 = nil._0;
          if (nil$2 !== undefined || cons.TAG === /* Ok */0 || cons._0 !== undefined) {
            nil$1 = nil$2;
            cons$1 = cons._0;
          } else {
            throw {
                  RE_EXN_ID: MergeFail,
                  Error: new Error()
                };
          }
        } else {
          var nil$3 = nil._0;
          if (cons.TAG === /* Ok */0) {
            if (nil$3 !== undefined || cons._0 !== undefined) {
              nil$1 = nil$3;
              cons$1 = cons._0;
            } else {
              throw {
                    RE_EXN_ID: MergeFail,
                    Error: new Error()
                  };
            }
          } else {
            throw {
                  RE_EXN_ID: MergeFail,
                  Error: new Error()
                };
          }
        }
        return {
                TAG: /* Construct */2,
                key: b.key,
                ids: b.ids,
                nil: nil$1,
                cons: cons$1,
                extra: b.extra
              };
    case /* Wildcard */3 :
        return {
                TAG: /* Wildcard */3,
                key: b.key,
                ids: b.ids,
                child: mergeWildcardAfterNest(wildcard, na, b.child, nb)
              };
    case /* End */4 :
        var b$2 = b._0;
        if (na) {
          return {
                  TAG: /* End */4,
                  _0: mergeWildcardAfterNest(wildcard, na._0, b$2, nb._0)
                };
        } else {
          return {
                  TAG: /* End */4,
                  _0: merge(wildcard, b$2, nb._0)
                };
        }
    
  }
}

function merge(a, b, n) {
  switch (a.TAG | 0) {
    case /* Switch */0 :
        switch (b.TAG | 0) {
          case /* Switch */0 :
              var match = a.wildcard;
              var match$1 = b.wildcard;
              var wildcard = match !== undefined ? (
                  match$1 !== undefined ? merge(match, match$1, n) : match
                ) : (
                  match$1 !== undefined ? match$1 : undefined
                );
              var wildcard$1 = a.wildcard;
              var bcases;
              if (wildcard$1 !== undefined) {
                var cases = mergeTestCasesIntoWildcard(undefined, wildcard$1, b.cases, n);
                if (cases !== undefined) {
                  bcases = cases;
                } else {
                  throw {
                        RE_EXN_ID: MergeFail,
                        Error: new Error()
                      };
                }
              } else {
                bcases = b.cases;
              }
              var cases$1 = mergeTestCases(a.cases, bcases, n, false);
              var cases$2;
              if (cases$1 !== undefined) {
                cases$2 = cases$1;
              } else {
                throw {
                      RE_EXN_ID: MergeFail,
                      Error: new Error()
                    };
              }
              var wildcard$2 = b.wildcard;
              var cases$3 = wildcard$2 !== undefined ? expandWildcardIntoTestCases(undefined, cases$2, wildcard$2, n) : cases$2;
              var ids = Belt_SetInt.union(a.ids, b.ids);
              return {
                      TAG: /* Switch */0,
                      key: a.key,
                      ids: ids,
                      cases: cases$3,
                      extra: a.extra,
                      wildcard: wildcard
                    };
          case /* Wildcard */3 :
              var a$1 = a.wildcard;
              var wildcard$3 = a$1 !== undefined ? merge(a$1, b.child, n) : b.child;
              var cases$4 = expandWildcardIntoTestCases(undefined, a.cases, b.child, n);
              var ids$1 = Belt_SetInt.union(a.ids, b.ids);
              return {
                      TAG: /* Switch */0,
                      key: a.key,
                      ids: ids$1,
                      cases: cases$4,
                      extra: a.extra,
                      wildcard: wildcard$3
                    };
          case /* Nest */1 :
          case /* Construct */2 :
          case /* End */4 :
              break;
          
        }
        break;
    case /* Nest */1 :
        switch (b.TAG | 0) {
          case /* Nest */1 :
              var match$2 = a.wildcard;
              var match$3 = b.wildcard;
              var wildcard$4 = match$2 !== undefined ? (
                  match$3 !== undefined ? merge(match$2, match$3, n) : match$2
                ) : (
                  match$3 !== undefined ? match$3 : undefined
                );
              var match$4 = a.child;
              var match$5 = b.child;
              var child;
              if (match$4.TAG === /* IntKeys */0) {
                if (match$5.TAG === /* IntKeys */0) {
                  var child$1 = merge(match$4._0, match$5._0, /* S */{
                        _0: n
                      });
                  child = wildcard$4 !== undefined ? ({
                        TAG: /* IntKeys */0,
                        _0: mergeWildcardAfterNest(wildcard$4, /* Z */0, child$1, /* S */{
                              _0: n
                            })
                      }) : ({
                        TAG: /* IntKeys */0,
                        _0: child$1
                      });
                } else {
                  throw {
                        RE_EXN_ID: "Assert_failure",
                        _1: [
                          "Matching.res",
                          489,
                          13
                        ],
                        Error: new Error()
                      };
                }
              } else {
                if (match$5.TAG === /* IntKeys */0) {
                  throw {
                        RE_EXN_ID: "Assert_failure",
                        _1: [
                          "Matching.res",
                          489,
                          13
                        ],
                        Error: new Error()
                      };
                }
                var child$2 = merge(match$4._0, match$5._0, /* S */{
                      _0: n
                    });
                child = wildcard$4 !== undefined ? ({
                      TAG: /* StringKeys */1,
                      _0: mergeWildcardAfterNest(wildcard$4, /* Z */0, child$2, /* S */{
                            _0: n
                          })
                    }) : ({
                      TAG: /* StringKeys */1,
                      _0: child$2
                    });
              }
              var ids$2 = Belt_SetInt.union(a.ids, b.ids);
              return {
                      TAG: /* Nest */1,
                      key: a.key,
                      ids: ids$2,
                      child: child,
                      wildcard: wildcard$4,
                      extra: a.extra
                    };
          case /* Wildcard */3 :
              var child$3 = a.child;
              var child$4;
              child$4 = child$3.TAG === /* IntKeys */0 ? ({
                    TAG: /* IntKeys */0,
                    _0: expandWildcardAfterNest(child$3._0, /* S */{
                          _0: n
                        }, b.child, /* Z */0)
                  }) : ({
                    TAG: /* StringKeys */1,
                    _0: expandWildcardAfterNest(child$3._0, /* S */{
                          _0: n
                        }, b.child, /* Z */0)
                  });
              var a$2 = a.wildcard;
              var wildcard$5 = a$2 !== undefined ? merge(a$2, b.child, n) : b.child;
              var ids$3 = Belt_SetInt.union(a.ids, b.ids);
              return {
                      TAG: /* Nest */1,
                      key: a.key,
                      ids: ids$3,
                      child: child$4,
                      wildcard: wildcard$5,
                      extra: a.extra
                    };
          case /* Switch */0 :
          case /* Construct */2 :
          case /* End */4 :
              break;
          
        }
        break;
    case /* Construct */2 :
        switch (b.TAG | 0) {
          case /* Construct */2 :
              var match$6 = a.nil;
              var match$7 = b.nil;
              var nil = match$6 !== undefined ? (
                  match$7 !== undefined ? merge(match$6, match$7, n) : match$6
                ) : (
                  match$7 !== undefined ? match$7 : undefined
                );
              var match$8 = a.cons;
              var match$9 = b.cons;
              var cons = match$8 !== undefined ? (
                  match$9 !== undefined ? merge(match$8, match$9, n) : match$8
                ) : (
                  match$9 !== undefined ? match$9 : undefined
                );
              var ids$4 = Belt_SetInt.union(a.ids, b.ids);
              return {
                      TAG: /* Construct */2,
                      key: a.key,
                      ids: ids$4,
                      nil: nil,
                      cons: cons,
                      extra: a.extra
                    };
          case /* Wildcard */3 :
              var a$3 = a.nil;
              var nil$1;
              if (a$3 !== undefined) {
                try {
                  nil$1 = {
                    TAG: /* Ok */0,
                    _0: merge(a$3, b.child, n)
                  };
                }
                catch (raw_exn){
                  var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                  if (exn.RE_EXN_ID === MergeFail) {
                    nil$1 = {
                      TAG: /* Error */1,
                      _0: a$3
                    };
                  } else {
                    throw exn;
                  }
                }
              } else {
                nil$1 = {
                  TAG: /* Ok */0,
                  _0: b.child
                };
              }
              var a$4 = a.cons;
              var cons$1;
              if (a$4 !== undefined) {
                try {
                  cons$1 = {
                    TAG: /* Ok */0,
                    _0: merge(a$4, b, n)
                  };
                }
                catch (raw_exn$1){
                  var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                  if (exn$1.RE_EXN_ID === MergeFail) {
                    cons$1 = {
                      TAG: /* Error */1,
                      _0: a$4
                    };
                  } else {
                    throw exn$1;
                  }
                }
              } else {
                cons$1 = {
                  TAG: /* Ok */0,
                  _0: b
                };
              }
              var ids$5 = Belt_SetInt.union(a.ids, b.ids);
              var exit = 0;
              var nil$2;
              var cons$2;
              if (nil$1.TAG === /* Ok */0 || cons$1.TAG === /* Ok */0) {
                nil$2 = nil$1._0;
                cons$2 = cons$1._0;
                exit = 2;
              } else {
                throw {
                      RE_EXN_ID: MergeFail,
                      Error: new Error()
                    };
              }
              if (exit === 2) {
                return {
                        TAG: /* Construct */2,
                        key: a.key,
                        ids: ids$5,
                        nil: nil$2,
                        cons: cons$2,
                        extra: a.extra
                      };
              }
              break;
          case /* Switch */0 :
          case /* Nest */1 :
          case /* End */4 :
              break;
          
        }
        break;
    case /* Wildcard */3 :
        switch (b.TAG | 0) {
          case /* Switch */0 :
              var cases$5 = mergeTestCasesIntoWildcard(undefined, a.child, b.cases, n);
              var cases$6;
              if (cases$5 !== undefined) {
                cases$6 = cases$5;
              } else {
                throw {
                      RE_EXN_ID: MergeFail,
                      Error: new Error()
                    };
              }
              var b$1 = b.wildcard;
              var wildcard$6 = b$1 !== undefined ? merge(a.child, b$1, n) : a.child;
              var ids$6 = Belt_SetInt.union(a.ids, b.ids);
              return {
                      TAG: /* Switch */0,
                      key: b.key,
                      ids: ids$6,
                      cases: cases$6,
                      extra: b.extra,
                      wildcard: wildcard$6
                    };
          case /* Nest */1 :
              var b$2 = b.wildcard;
              var wildcard$7 = b$2 !== undefined ? merge(a.child, b$2, n) : a.child;
              var child$5 = b.child;
              var child$6;
              child$6 = child$5.TAG === /* IntKeys */0 ? ({
                    TAG: /* IntKeys */0,
                    _0: mergeWildcardAfterNest(a.child, /* Z */0, child$5._0, /* S */{
                          _0: n
                        })
                  }) : ({
                    TAG: /* StringKeys */1,
                    _0: mergeWildcardAfterNest(a.child, /* Z */0, child$5._0, /* S */{
                          _0: n
                        })
                  });
              var ids$7 = Belt_SetInt.union(a.ids, b.ids);
              return {
                      TAG: /* Nest */1,
                      key: b.key,
                      ids: ids$7,
                      child: child$6,
                      wildcard: wildcard$7,
                      extra: b.extra
                    };
          case /* Construct */2 :
              var b$3 = b.nil;
              var nil$3;
              if (b$3 !== undefined) {
                try {
                  nil$3 = {
                    TAG: /* Ok */0,
                    _0: merge(a.child, b$3, n)
                  };
                }
                catch (raw_exn$2){
                  var exn$2 = Caml_js_exceptions.internalToOCamlException(raw_exn$2);
                  if (exn$2.RE_EXN_ID === MergeFail) {
                    nil$3 = {
                      TAG: /* Error */1,
                      _0: undefined
                    };
                  } else {
                    throw exn$2;
                  }
                }
              } else {
                nil$3 = {
                  TAG: /* Ok */0,
                  _0: a.child
                };
              }
              var b$4 = b.cons;
              var cons$3;
              if (b$4 !== undefined) {
                try {
                  cons$3 = {
                    TAG: /* Ok */0,
                    _0: merge(a, b$4, n)
                  };
                }
                catch (raw_exn$3){
                  var exn$3 = Caml_js_exceptions.internalToOCamlException(raw_exn$3);
                  if (exn$3.RE_EXN_ID === MergeFail) {
                    cons$3 = {
                      TAG: /* Error */1,
                      _0: undefined
                    };
                  } else {
                    throw exn$3;
                  }
                }
              } else {
                cons$3 = {
                  TAG: /* Ok */0,
                  _0: a
                };
              }
              var ids$8 = Belt_SetInt.union(a.ids, b.ids);
              var exit$1 = 0;
              var nil$4;
              var cons$4;
              if (nil$3.TAG === /* Ok */0) {
                var nil$5 = nil$3._0;
                if (nil$5 !== undefined || cons$3.TAG === /* Ok */0 || cons$3._0 !== undefined) {
                  nil$4 = nil$5;
                  cons$4 = cons$3._0;
                  exit$1 = 2;
                } else {
                  throw {
                        RE_EXN_ID: MergeFail,
                        Error: new Error()
                      };
                }
              } else {
                var nil$6 = nil$3._0;
                if (cons$3.TAG === /* Ok */0) {
                  if (nil$6 !== undefined || cons$3._0 !== undefined) {
                    nil$4 = nil$6;
                    cons$4 = cons$3._0;
                    exit$1 = 2;
                  } else {
                    throw {
                          RE_EXN_ID: MergeFail,
                          Error: new Error()
                        };
                  }
                } else {
                  throw {
                        RE_EXN_ID: MergeFail,
                        Error: new Error()
                      };
                }
              }
              if (exit$1 === 2) {
                return {
                        TAG: /* Construct */2,
                        key: b.key,
                        ids: ids$8,
                        nil: nil$4,
                        cons: cons$4,
                        extra: b.extra
                      };
              }
              break;
          case /* Wildcard */3 :
              return {
                      TAG: /* Wildcard */3,
                      key: a.key,
                      ids: Belt_SetInt.union(a.ids, b.ids),
                      child: merge(a.child, b.child, n)
                    };
          case /* End */4 :
              break;
          
        }
        break;
    case /* End */4 :
        if (b.TAG === /* End */4) {
          if (n) {
            return {
                    TAG: /* End */4,
                    _0: merge(a._0, b._0, n._0)
                  };
          }
          throw {
                RE_EXN_ID: MergeFail,
                Error: new Error()
              };
        }
        break;
    
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Matching.res",
          575,
          6
        ],
        Error: new Error()
      };
}

function fromConst(key, val, ifMatch, $$enum) {
  var tmp;
  if ($$enum !== undefined) {
    var match = $$enum.row;
    tmp = match ? /* Extra_none */0 : /* Extra_enum_closed */1;
  } else {
    tmp = /* Extra_none */0;
  }
  return {
          TAG: /* Switch */0,
          key: key,
          ids: undefined,
          cases: {
            val: Data$AcutisLang.Const.fromTPat(val),
            ifMatch: ifMatch,
            nextCase: undefined
          },
          extra: tmp,
          wildcard: undefined
        };
}

function fromTPat(p, b, key, k) {
  switch (p.TAG | 0) {
    case /* TConst */0 :
        return fromConst(key, p._1, k(b), p._2);
    case /* TConstruct */1 :
        var cons = p._2;
        var kind = p._1;
        if (cons !== undefined) {
          return {
                  TAG: /* Construct */2,
                  key: key,
                  ids: undefined,
                  nil: undefined,
                  cons: fromTPat(cons, b, key, k),
                  extra: kind
                };
        } else {
          return {
                  TAG: /* Construct */2,
                  key: key,
                  ids: undefined,
                  nil: k(b),
                  cons: undefined,
                  extra: kind
                };
        }
    case /* TTuple */2 :
        var child = fromArray(p._1, b, 0, (function (b) {
                return {
                        TAG: /* End */4,
                        _0: k(b)
                      };
              }));
        return {
                TAG: /* Nest */1,
                key: key,
                ids: undefined,
                child: {
                  TAG: /* IntKeys */0,
                  _0: child
                },
                wildcard: undefined,
                extra: /* Tuple */0
              };
    case /* TRecord */3 :
        var tag = p._1;
        var dbg = p._0;
        var a = Belt_MapString.toArray(Belt_MapString.mergeU(p._2, p._3.contents, (function (_k, p, _ty) {
                    if (p !== undefined) {
                      return p;
                    } else {
                      return {
                              TAG: /* TAny */7,
                              _0: dbg
                            };
                    }
                  })));
        var child$1 = fromKeyValues(a, b, 0, (function (b) {
                return {
                        TAG: /* End */4,
                        _0: k(b)
                      };
              }));
        var match;
        if (tag !== undefined) {
          var union = tag[2];
          match = [
            fromConst(tag[0], tag[1], child$1, union),
            /* Union */{
              _0: union.extra
            }
          ];
        } else {
          match = [
            child$1,
            /* Record */2
          ];
        }
        return {
                TAG: /* Nest */1,
                key: key,
                ids: undefined,
                child: {
                  TAG: /* StringKeys */1,
                  _0: match[0]
                },
                wildcard: undefined,
                extra: match[1]
              };
    case /* TDict */4 :
        var dbg$1 = p._0;
        var kys = Belt_MapString.fromArray(Belt_Array.mapU(Belt_SetString.toArray(p._2.contents), (function (k) {
                    return [
                            k,
                            {
                              TAG: /* TAny */7,
                              _0: dbg$1
                            }
                          ];
                  })));
        var a$1 = Belt_MapString.toArray(Belt_MapString.mergeU(p._1, kys, (function (param, p, k) {
                    if (p !== undefined) {
                      return p;
                    } else if (k !== undefined) {
                      return k;
                    } else {
                      return ;
                    }
                  })));
        var child$2 = fromKeyValues(a$1, b, 0, (function (b) {
                return {
                        TAG: /* End */4,
                        _0: k(b)
                      };
              }));
        return {
                TAG: /* Nest */1,
                key: key,
                ids: undefined,
                child: {
                  TAG: /* StringKeys */1,
                  _0: child$2
                },
                wildcard: undefined,
                extra: /* Dict */1
              };
    case /* TVar */5 :
    case /* TOptionalVar */6 :
        break;
    case /* TAny */7 :
        return {
                TAG: /* Wildcard */3,
                key: key,
                ids: undefined,
                child: k(b)
              };
    
  }
  var id = Debug$AcutisLang.$$char(p._0);
  return {
          TAG: /* Wildcard */3,
          key: key,
          ids: Belt_SetInt.add(undefined, id),
          child: k(Belt_MapString.set(b, p._1, id))
        };
}

function fromArray(a, b, i, k) {
  var p = Belt_Array.get(a, i);
  if (p !== undefined) {
    return fromTPat(p, b, i, (function (b) {
                  return fromArray(a, b, i + 1 | 0, k);
                }));
  } else {
    return k(b);
  }
}

function fromKeyValues(a, b, i, k) {
  var match = Belt_Array.get(a, i);
  if (match !== undefined) {
    return fromTPat(match[1], b, match[0], (function (b) {
                  return fromKeyValues(a, b, i + 1 | 0, k);
                }));
  } else {
    return k(b);
  }
}

function fromArray$1(exit, a) {
  return fromArray(a, undefined, 0, (function (names) {
                return {
                        TAG: /* End */4,
                        _0: {
                          names: names,
                          exit: exit
                        }
                      };
              }));
}

function makeCase(hd, a, exit) {
  var _t = hd;
  var _i = 1;
  while(true) {
    var i = _i;
    var t = _t;
    var ps = NonEmpty$AcutisLang.get(a, i);
    if (ps === undefined) {
      return t;
    }
    var b = fromArray$1(exit, NonEmpty$AcutisLang.toArray(ps));
    var t$1;
    try {
      t$1 = merge(t, b, /* Z */0);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === MergeFail) {
        throw {
              RE_EXN_ID: Debug$AcutisLang.Exit,
              _1: Debug$AcutisLang.unusedCase(ps, Typechecker$AcutisLang.Pattern),
              Error: new Error()
            };
      }
      throw exn;
    }
    _i = i + 1 | 0;
    _t = t$1;
    continue ;
  };
}

function make(cases) {
  var exitq = Belt_MutableQueue.make(undefined);
  var hdcase = NonEmpty$AcutisLang.hd(cases);
  Belt_MutableQueue.add(exitq, hdcase.nodes);
  var exit = Belt_MutableQueue.size(exitq) - 1 | 0;
  var hdTree = fromArray$1(exit, NonEmpty$AcutisLang.toArray(NonEmpty$AcutisLang.hd(hdcase.pats)));
  var tree = makeCase(hdTree, hdcase.pats, exit);
  var _tree = tree;
  var _i = 1;
  while(true) {
    var i = _i;
    var tree$1 = _tree;
    var match = NonEmpty$AcutisLang.get(cases, i);
    if (match === undefined) {
      return {
              tree: tree$1,
              exits: Belt_MutableQueue.toArray(exitq)
            };
    }
    var pats = match.pats;
    Belt_MutableQueue.add(exitq, match.nodes);
    var exit$1 = Belt_MutableQueue.size(exitq) - 1 | 0;
    var hdTree$1 = fromArray$1(exit$1, NonEmpty$AcutisLang.toArray(NonEmpty$AcutisLang.hd(pats)));
    var tree$2;
    try {
      tree$2 = merge(tree$1, hdTree$1, /* Z */0);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === MergeFail) {
        throw {
              RE_EXN_ID: Debug$AcutisLang.Exit,
              _1: Debug$AcutisLang.unusedCase(NonEmpty$AcutisLang.hd(pats), Typechecker$AcutisLang.Pattern),
              Error: new Error()
            };
      }
      throw exn;
    }
    var tree$3 = makeCase(tree$2, pats, exit$1);
    _i = i + 1 | 0;
    _tree = tree$3;
    continue ;
  };
}

function toArray(l) {
  return Belt_Array.mapU(Belt_List.toArray(l), (function (param) {
                return param[1];
              }));
}

function toKeyValues(l) {
  return Belt_List.reduceU(l, undefined, (function (m, param) {
                return Belt_MapString.set(m, param[0], param[1]);
              }));
}

function toString(l) {
  return Belt_Array.joinWith(toArray(l), ", ", Typechecker$AcutisLang.Pattern.toString);
}

function key_str(s) {
  return s;
}

function key_int(param) {
  return "";
}

function exhaustive(key, param) {
  var pat = key === "" ? ({
        TAG: /* TAny */7,
        _0: Debug$AcutisLang.empty
      }) : ({
        TAG: /* TVar */5,
        _0: Debug$AcutisLang.empty,
        _1: key
      });
  return {
          flag: param.flag,
          pats: {
            hd: [
              key,
              pat
            ],
            tl: param.pats
          },
          next: param.next
        };
}

function check(tree, kf) {
  switch (tree.TAG | 0) {
    case /* Switch */0 :
        var wildcard = tree.wildcard;
        var cases = tree.cases;
        var key = tree.key;
        if (wildcard !== undefined) {
          return exhaustive(kf(key), check(wildcard, kf));
        }
        if (tree.extra) {
          var _param = cases;
          while(true) {
            var param = _param;
            var nextCase = param.nextCase;
            var match = check(param.ifMatch, kf);
            if (!match.flag) {
              return {
                      flag: /* Partial */0,
                      pats: {
                        hd: [
                          kf(key),
                          {
                            TAG: /* TConst */0,
                            _0: Debug$AcutisLang.empty,
                            _1: Data$AcutisLang.Const.toTPat(param.val),
                            _2: undefined
                          }
                        ],
                        tl: match.pats
                      },
                      next: match.next
                    };
            }
            if (nextCase === undefined) {
              return {
                      flag: /* Exhaustive */1,
                      pats: {
                        hd: [
                          kf(key),
                          {
                            TAG: /* TAny */7,
                            _0: Debug$AcutisLang.empty
                          }
                        ],
                        tl: match.pats
                      },
                      next: match.next
                    };
            }
            _param = nextCase;
            continue ;
          };
        }
        var match$1 = check(cases.ifMatch, kf);
        return {
                flag: /* Partial */0,
                pats: {
                  hd: [
                    kf(key),
                    {
                      TAG: /* TAny */7,
                      _0: Debug$AcutisLang.empty
                    }
                  ],
                  tl: match$1.pats
                },
                next: match$1.next
              };
    case /* Nest */1 :
        var extra = tree.extra;
        var wildcard$1 = tree.wildcard;
        var child = tree.child;
        var key$1 = tree.key;
        var result;
        result = child.TAG === /* IntKeys */0 ? check(child._0, key_int) : check(child._0, key_str);
        if (result.flag) {
          var next = result.next;
          if (extra !== 1) {
            return exhaustive(kf(key$1), check(next, kf));
          }
          if (wildcard$1 !== undefined) {
            return exhaustive(kf(key$1), check(wildcard$1, kf));
          }
          var match$2 = check(next, kf);
          return {
                  flag: /* Partial */0,
                  pats: {
                    hd: [
                      kf(key$1),
                      {
                        TAG: /* TAny */7,
                        _0: Debug$AcutisLang.empty
                      }
                    ],
                    tl: match$2.pats
                  },
                  next: match$2.next
                };
        }
        var pats = result.pats;
        if (wildcard$1 !== undefined) {
          return exhaustive(kf(key$1), check(wildcard$1, kf));
        }
        var nest;
        if (typeof extra === "number") {
          switch (extra) {
            case /* Tuple */0 :
                nest = {
                  TAG: /* TTuple */2,
                  _0: Debug$AcutisLang.empty,
                  _1: toArray(pats)
                };
                break;
            case /* Dict */1 :
                nest = {
                  TAG: /* TDict */4,
                  _0: Debug$AcutisLang.empty,
                  _1: toKeyValues(pats),
                  _2: {
                    contents: undefined
                  }
                };
                break;
            case /* Record */2 :
                nest = {
                  TAG: /* TRecord */3,
                  _0: Debug$AcutisLang.empty,
                  _1: undefined,
                  _2: toKeyValues(pats),
                  _3: {
                    contents: undefined
                  }
                };
                break;
            
          }
        } else if (pats) {
          var match$3 = pats.hd;
          var match$4 = match$3[1];
          nest = match$4.TAG === /* TConst */0 ? ({
                TAG: /* TRecord */3,
                _0: Debug$AcutisLang.empty,
                _1: [
                  match$3[0],
                  match$4._1,
                  {
                    cases: {
                      TAG: /* String */1,
                      _0: undefined
                    },
                    row: /* Closed */0,
                    extra: extra._0
                  }
                ],
                _2: toKeyValues(pats.tl),
                _3: {
                  contents: undefined
                }
              }) : ({
                TAG: /* TAny */7,
                _0: Debug$AcutisLang.empty
              });
        } else {
          nest = {
            TAG: /* TAny */7,
            _0: Debug$AcutisLang.empty
          };
        }
        var match$5 = check(result.next, kf);
        return {
                flag: /* Partial */0,
                pats: {
                  hd: [
                    kf(key$1),
                    nest
                  ],
                  tl: match$5.pats
                },
                next: match$5.next
              };
    case /* Construct */2 :
        var extra$1 = tree.extra;
        var cons = tree.cons;
        var nil = tree.nil;
        var key$2 = tree.key;
        if (nil !== undefined) {
          if (cons !== undefined) {
            var match$6 = check(nil, kf);
            if (!match$6.flag) {
              return {
                      flag: /* Partial */0,
                      pats: {
                        hd: [
                          kf(key$2),
                          {
                            TAG: /* TConstruct */1,
                            _0: Debug$AcutisLang.empty,
                            _1: extra$1,
                            _2: undefined
                          }
                        ],
                        tl: match$6.pats
                      },
                      next: match$6.next
                    };
            }
            var x = check(cons, kf);
            if (x.flag) {
              return x;
            }
            var pats$1 = x.pats;
            var pats$2;
            if (pats$1) {
              var match$7 = pats$1.hd;
              pats$2 = {
                hd: [
                  match$7[0],
                  {
                    TAG: /* TConstruct */1,
                    _0: Debug$AcutisLang.empty,
                    _1: extra$1,
                    _2: match$7[1]
                  }
                ],
                tl: pats$1.tl
              };
            } else {
              throw {
                    RE_EXN_ID: "Assert_failure",
                    _1: [
                      "Matching.res",
                      815,
                      19
                    ],
                    Error: new Error()
                  };
            }
            return {
                    flag: /* Partial */0,
                    pats: pats$2,
                    next: x.next
                  };
          }
          var match$8 = check(nil, kf);
          return {
                  flag: /* Partial */0,
                  pats: {
                    hd: [
                      kf(key$2),
                      {
                        TAG: /* TConstruct */1,
                        _0: Debug$AcutisLang.empty,
                        _1: extra$1,
                        _2: {
                          TAG: /* TAny */7,
                          _0: Debug$AcutisLang.empty
                        }
                      }
                    ],
                    tl: match$8.pats
                  },
                  next: match$8.next
                };
        }
        if (cons !== undefined) {
          var match$9 = check(cons, kf);
          var pats$3 = match$9.pats;
          var tmp;
          if (pats$3) {
            tmp = {
              hd: [
                kf(key$2),
                {
                  TAG: /* TConstruct */1,
                  _0: Debug$AcutisLang.empty,
                  _1: extra$1,
                  _2: undefined
                }
              ],
              tl: pats$3.tl
            };
          } else {
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "Matching.res",
                    793,
                    17
                  ],
                  Error: new Error()
                };
          }
          return {
                  flag: /* Partial */0,
                  pats: tmp,
                  next: match$9.next
                };
        }
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "Matching.res",
                825,
                24
              ],
              Error: new Error()
            };
    case /* Wildcard */3 :
        return exhaustive(kf(tree.key), check(tree.child, kf));
    case /* End */4 :
        return {
                flag: /* Exhaustive */1,
                pats: /* [] */0,
                next: tree._0
              };
    
  }
}

function partial_match_check(tree, debug) {
  var match = check(tree, key_int);
  if (match.flag) {
    return ;
  }
  throw {
        RE_EXN_ID: Debug$AcutisLang.Exit,
        _1: Debug$AcutisLang.partialMatch(debug, match.pats, toString),
        Error: new Error()
      };
}

export {
  Exit ,
  make ,
  partial_match_check ,
  
}
/* Data-AcutisLang Not a pure module */

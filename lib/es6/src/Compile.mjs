// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "@rescript/std/lib/es6/belt_Array.js";
import * as Belt_MapString from "@rescript/std/lib/es6/belt_MapString.js";
import * as Debug$AcutisLang from "./Debug.mjs";
import * as Lexer$AcutisLang from "./Lexer.mjs";
import * as Utils$AcutisLang from "./Utils.mjs";
import * as Parser$AcutisLang from "./Parser.mjs";
import * as Source$AcutisLang from "./Source.mjs";
import * as Belt_HashMapString from "@rescript/std/lib/es6/belt_HashMapString.js";
import * as Caml_js_exceptions from "@rescript/std/lib/es6/caml_js_exceptions.js";
import * as Matching$AcutisLang from "./Matching.mjs";
import * as Typechecker$AcutisLang from "./Typechecker.mjs";

function trimStart(string) {
  var _pos = 0;
  while(true) {
    var pos = _pos;
    var match = string.charAt(pos);
    switch (match) {
      case "\t" :
      case "\n" :
      case "\r" :
      case " " :
          _pos = pos + 1 | 0;
          continue ;
      default:
        return string.slice(pos);
    }
  };
}

function trimEnd(string) {
  var _pos = string.length;
  while(true) {
    var pos = _pos;
    var match = string.charAt(pos - 1 | 0);
    switch (match) {
      case "\t" :
      case "\n" :
      case "\r" :
      case " " :
          _pos = pos - 1 | 0;
          continue ;
      default:
        return string.slice(0, pos);
    }
  };
}

function echo(x) {
  switch (x.TAG | 0) {
    case /* EBinding */0 :
        return {
                TAG: /* OEBinding */0,
                _0: x._1,
                _1: x._2
              };
    case /* EChild */1 :
        return {
                TAG: /* OEChild */1,
                _0: x._1
              };
    case /* EString */2 :
        return {
                TAG: /* OEString */2,
                _0: Utils$AcutisLang.$$escape(x._2, x._1)
              };
    
  }
}

function nodes(a) {
  return Belt_Array.mapU(a, (function (x) {
                switch (x.TAG | 0) {
                  case /* TText */0 :
                      var s = x._0;
                      switch (x._1) {
                        case /* NoTrim */0 :
                            return {
                                    TAG: /* OText */0,
                                    _0: s
                                  };
                        case /* TrimStart */1 :
                            return {
                                    TAG: /* OText */0,
                                    _0: trimStart(s)
                                  };
                        case /* TrimEnd */2 :
                            return {
                                    TAG: /* OText */0,
                                    _0: trimEnd(s)
                                  };
                        case /* TrimBoth */3 :
                            return {
                                    TAG: /* OText */0,
                                    _0: trimStart(trimEnd(s))
                                  };
                        
                      }
                  case /* TEcho */1 :
                      return {
                              TAG: /* OEcho */1,
                              _0: Belt_Array.mapU(x._1, echo),
                              _1: echo(x._2)
                            };
                  case /* TMatch */2 :
                      var tree = Matching$AcutisLang.make(x._2);
                      Matching$AcutisLang.partial_match_check(tree.tree, x._0);
                      var tree_tree = tree.tree;
                      var tree_exits = Matching$AcutisLang.Exit.map(tree.exits, nodes);
                      var tree$1 = {
                        tree: tree_tree,
                        exits: tree_exits
                      };
                      return {
                              TAG: /* OMatch */2,
                              _0: x._1,
                              _1: tree$1
                            };
                  case /* TMapList */3 :
                      var tree$2 = Matching$AcutisLang.make(x._2);
                      Matching$AcutisLang.partial_match_check(tree$2.tree, x._0);
                      var tree_tree$1 = tree$2.tree;
                      var tree_exits$1 = Matching$AcutisLang.Exit.map(tree$2.exits, nodes);
                      var tree$3 = {
                        tree: tree_tree$1,
                        exits: tree_exits$1
                      };
                      return {
                              TAG: /* OMapList */3,
                              _0: x._1,
                              _1: tree$3
                            };
                  case /* TMapDict */4 :
                      var tree$4 = Matching$AcutisLang.make(x._2);
                      Matching$AcutisLang.partial_match_check(tree$4.tree, x._0);
                      var tree_tree$2 = tree$4.tree;
                      var tree_exits$2 = Matching$AcutisLang.Exit.map(tree$4.exits, nodes);
                      var tree$5 = {
                        tree: tree_tree$2,
                        exits: tree_exits$2
                      };
                      return {
                              TAG: /* OMapDict */4,
                              _0: x._1,
                              _1: tree$5
                            };
                  case /* TComponent */5 :
                      var children = Belt_MapString.mapU(x._3, (function (v) {
                              if (v.TAG === /* TChildName */0) {
                                return {
                                        TAG: /* OChildName */0,
                                        _0: v._0
                                      };
                              } else {
                                return {
                                        TAG: /* OChildBlock */1,
                                        _0: nodes(v._0)
                                      };
                              }
                            }));
                      return {
                              TAG: /* OComponent */5,
                              _0: x._0,
                              _1: x._1,
                              _2: x._2,
                              _3: children
                            };
                  
                }
              }));
}

function empty(param) {
  return {
          typed: Belt_HashMapString.make(0),
          optimized: Belt_HashMapString.make(0)
        };
}

function makeExn(a) {
  var size = a.length;
  var m = Belt_HashMapString.make(size);
  Belt_Array.forEachU(a, (function (src) {
          if (src.TAG === /* Acutis */0) {
            var name = src._0;
            if (Belt_HashMapString.has(m, name)) {
              throw {
                    RE_EXN_ID: Debug$AcutisLang.Exit,
                    _1: Debug$AcutisLang.duplicateCompName(name),
                    Error: new Error()
                  };
            }
            return Belt_HashMapString.set(m, name, Source$AcutisLang.src(name, Parser$AcutisLang.make(Lexer$AcutisLang.make(name, src._1))));
          }
          var name$1 = src._0;
          if (Belt_HashMapString.has(m, name$1)) {
            throw {
                  RE_EXN_ID: Debug$AcutisLang.Exit,
                  _1: Debug$AcutisLang.duplicateCompName(name$1),
                  Error: new Error()
                };
          }
          return Belt_HashMapString.set(m, name$1, Source$AcutisLang.fnU(name$1, src._1, src._2, src._3));
        }));
  var typed = Typechecker$AcutisLang.makeComponents(m);
  var optimized = Belt_HashMapString.make(size);
  Belt_HashMapString.forEachU(typed, (function (param, v) {
          if (v.TAG === /* Acutis */0) {
            var name = v._0;
            return Belt_HashMapString.set(optimized, name, Source$AcutisLang.src(name, nodes(v._1.nodes)));
          }
          var name$1 = v._0;
          return Belt_HashMapString.set(optimized, name$1, Source$AcutisLang.fnU(name$1, v._1, v._2, v._3));
        }));
  return {
          typed: typed,
          optimized: optimized
        };
}

function make(a) {
  try {
    return {
            NAME: "ok",
            VAL: makeExn(a)
          };
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    if (e.RE_EXN_ID === Debug$AcutisLang.Exit) {
      return {
              NAME: "errors",
              VAL: [e._1]
            };
    } else {
      return {
              NAME: "errors",
              VAL: [Debug$AcutisLang.uncaughtCompileError(e, "")]
            };
    }
  }
}

var Components = {
  empty: empty,
  makeExn: makeExn,
  make: make
};

function linkNodesExn(nodes, graph) {
  return Belt_Array.mapU(nodes, (function (node) {
                switch (node.TAG | 0) {
                  case /* OText */0 :
                  case /* OEcho */1 :
                      return node;
                  case /* OMatch */2 :
                      var t = node._1;
                      var exits = Matching$AcutisLang.Exit.map(t.exits, (function (n) {
                              return linkNodesExn(n, graph);
                            }));
                      return {
                              TAG: /* OMatch */2,
                              _0: node._0,
                              _1: {
                                tree: t.tree,
                                exits: exits
                              }
                            };
                  case /* OMapList */3 :
                      var t$1 = node._1;
                      var exits$1 = Matching$AcutisLang.Exit.map(t$1.exits, (function (n) {
                              return linkNodesExn(n, graph);
                            }));
                      return {
                              TAG: /* OMapList */3,
                              _0: node._0,
                              _1: {
                                tree: t$1.tree,
                                exits: exits$1
                              }
                            };
                  case /* OMapDict */4 :
                      var t$2 = node._1;
                      var exits$2 = Matching$AcutisLang.Exit.map(t$2.exits, (function (n) {
                              return linkNodesExn(n, graph);
                            }));
                      return {
                              TAG: /* OMapDict */4,
                              _0: node._0,
                              _1: {
                                tree: t$2.tree,
                                exits: exits$2
                              }
                            };
                  case /* OComponent */5 :
                      var debug = node._0;
                      var val = Utils$AcutisLang.Dagmap.get(graph, node._1, debug);
                      var children = Belt_MapString.mapU(node._3, (function (child) {
                              if (child.TAG === /* OChildName */0) {
                                return child;
                              } else {
                                return {
                                        TAG: /* OChildBlock */1,
                                        _0: linkNodesExn(child._0, graph)
                                      };
                              }
                            }));
                      return {
                              TAG: /* OComponent */5,
                              _0: debug,
                              _1: val,
                              _2: node._2,
                              _3: children
                            };
                  
                }
              }));
}

function linkSrc(g, src) {
  if (src.TAG === /* Acutis */0) {
    return {
            TAG: /* Acutis */0,
            _0: src._0,
            _1: linkNodesExn(src._1, g)
          };
  } else {
    return {
            TAG: /* Function */1,
            _0: src._0,
            _1: src._1,
            _2: src._3
          };
  }
}

function make$1(name, src, components) {
  try {
    var nodes$1 = Parser$AcutisLang.make(Lexer$AcutisLang.make(name, src));
    var ast = Typechecker$AcutisLang.make(nodes$1, components.typed);
    var g = Utils$AcutisLang.Dagmap.make(components.optimized, linkSrc);
    var nodes$2 = nodes(ast.nodes);
    return {
            NAME: "ok",
            VAL: {
              prop_types: ast.prop_types,
              nodes: linkNodesExn(nodes$2, g),
              name: name
            }
          };
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    if (e.RE_EXN_ID === Debug$AcutisLang.Exit) {
      return {
              NAME: "errors",
              VAL: [e._1]
            };
    } else {
      return {
              NAME: "errors",
              VAL: [Debug$AcutisLang.uncaughtCompileError(e, name)]
            };
    }
  }
}

export {
  Components ,
  make$1 as make,
  
}
/* Matching-AcutisLang Not a pure module */

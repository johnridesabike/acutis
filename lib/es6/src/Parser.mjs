// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_MapString from "@rescript/std/lib/es6/belt_MapString.js";
import * as Debug$AcutisLang from "./Debug.mjs";
import * as Lexer$AcutisLang from "./Lexer.mjs";
import * as Belt_MutableQueue from "@rescript/std/lib/es6/belt_MutableQueue.js";
import * as NonEmpty$AcutisLang from "./NonEmpty.mjs";

function debug(x) {
  return x._0;
}

function parseNode(t, tokens) {
  switch (t.TAG | 0) {
    case /* Tkn_String */2 :
        return {
                TAG: /* UString */2,
                _0: t._0,
                _1: t._1
              };
    case /* Tkn_Int */3 :
        return {
                TAG: /* UInt */3,
                _0: t._0,
                _1: t._1
              };
    case /* Tkn_Float */4 :
        return {
                TAG: /* UFloat */4,
                _0: t._0,
                _1: t._1
              };
    case /* Tkn_True */5 :
        return {
                TAG: /* UBool */1,
                _0: t._0,
                _1: 1
              };
    case /* Tkn_False */6 :
        return {
                TAG: /* UBool */1,
                _0: t._0,
                _1: 0
              };
    case /* Tkn_Null */7 :
        return {
                TAG: /* UNullable */0,
                _0: t._0,
                _1: undefined
              };
    case /* Tkn_OpenBracket */10 :
        var d = t._0;
        var t$1 = Lexer$AcutisLang.pop(tokens);
        if (t$1.TAG === /* Tkn_CloseBracket */11) {
          return {
                  TAG: /* UList */8,
                  _0: d,
                  _1: [],
                  _2: undefined
                };
        } else {
          var q = Belt_MutableQueue.make(undefined);
          Belt_MutableQueue.add(q, parseNode(t$1, tokens));
          var _param;
          while(true) {
            var t$2 = Lexer$AcutisLang.pop(tokens);
            switch (t$2.TAG | 0) {
              case /* Tkn_Comma */8 :
                  var t$3 = Lexer$AcutisLang.pop(tokens);
                  if (t$3.TAG === /* Tkn_Spread */18) {
                    var tail = parseNode(Lexer$AcutisLang.pop(tokens), tokens);
                    var t$4 = Lexer$AcutisLang.pop(tokens);
                    if (t$4.TAG === /* Tkn_CloseBracket */11) {
                      return {
                              TAG: /* UList */8,
                              _0: d,
                              _1: Belt_MutableQueue.toArray(q),
                              _2: tail
                            };
                    }
                    throw {
                          RE_EXN_ID: Debug$AcutisLang.Exit,
                          _1: Debug$AcutisLang.unexpectedToken(t$4, Lexer$AcutisLang.Token),
                          Error: new Error()
                        };
                  }
                  Belt_MutableQueue.add(q, parseNode(t$3, tokens));
                  _param = undefined;
                  continue ;
              case /* Tkn_CloseBracket */11 :
                  return {
                          TAG: /* UList */8,
                          _0: d,
                          _1: Belt_MutableQueue.toArray(q),
                          _2: undefined
                        };
              default:
                throw {
                      RE_EXN_ID: Debug$AcutisLang.Exit,
                      _1: Debug$AcutisLang.unexpectedToken(t$2, Lexer$AcutisLang.Token),
                      Error: new Error()
                    };
            }
          };
        }
    case /* Tkn_OpenBrace */12 :
        var d$1 = t._0;
        var t$5 = Lexer$AcutisLang.pop(tokens);
        if (t$5.TAG === /* Tkn_CloseBrace */13) {
          return {
                  TAG: /* URecord */10,
                  _0: d$1,
                  _1: undefined,
                  _2: undefined
                };
        } else {
          var match = parseKeyValueRecord(t$5, tokens, undefined, undefined);
          var _tag = match[0];
          var _m = match[1];
          while(true) {
            var m = _m;
            var tag = _tag;
            var t$6 = Lexer$AcutisLang.pop(tokens);
            switch (t$6.TAG | 0) {
              case /* Tkn_Comma */8 :
                  var t$7 = Lexer$AcutisLang.pop(tokens);
                  var match$1 = parseKeyValueRecord(t$7, tokens, tag, m);
                  var m$1 = match$1[1];
                  var tag$1 = match$1[0];
                  if (tag$1 !== undefined && Belt_MapString.has(m$1, tag$1[0])) {
                    throw {
                          RE_EXN_ID: Debug$AcutisLang.Exit,
                          _1: Debug$AcutisLang.tooManyFields(t$7, Lexer$AcutisLang.Token),
                          Error: new Error()
                        };
                  }
                  _m = m$1;
                  _tag = tag$1;
                  continue ;
              case /* Tkn_CloseBrace */13 :
                  return {
                          TAG: /* URecord */10,
                          _0: d$1,
                          _1: tag,
                          _2: m
                        };
              default:
                throw {
                      RE_EXN_ID: Debug$AcutisLang.Exit,
                      _1: Debug$AcutisLang.unexpectedToken(t$6, Lexer$AcutisLang.Token),
                      Error: new Error()
                    };
            }
          };
        }
    case /* Tkn_OpenParen */14 :
        var d$2 = t._0;
        var t$8 = Lexer$AcutisLang.pop(tokens);
        if (t$8.TAG === /* Tkn_CloseParen */15) {
          return {
                  TAG: /* UTuple */5,
                  _0: d$2,
                  _1: []
                };
        } else {
          var q$1 = Belt_MutableQueue.make(undefined);
          Belt_MutableQueue.add(q$1, parseNode(t$8, tokens));
          var _param$1;
          while(true) {
            var t$9 = Lexer$AcutisLang.pop(tokens);
            switch (t$9.TAG | 0) {
              case /* Tkn_Comma */8 :
                  Belt_MutableQueue.add(q$1, parseNode(Lexer$AcutisLang.pop(tokens), tokens));
                  _param$1 = undefined;
                  continue ;
              case /* Tkn_CloseParen */15 :
                  return {
                          TAG: /* UTuple */5,
                          _0: d$2,
                          _1: Belt_MutableQueue.toArray(q$1)
                        };
              default:
                throw {
                      RE_EXN_ID: Debug$AcutisLang.Exit,
                      _1: Debug$AcutisLang.unexpectedToken(t$9, Lexer$AcutisLang.Token),
                      Error: new Error()
                    };
            }
          };
        }
    case /* Tkn_OpenPointyBracket */16 :
        var d$3 = t._0;
        var t$10 = Lexer$AcutisLang.pop(tokens);
        if (t$10.TAG === /* Tkn_ClosePointyBracket */17) {
          return {
                  TAG: /* UDict */9,
                  _0: d$3,
                  _1: undefined
                };
        } else {
          var m$2 = parseKeyValueDict(t$10, tokens, undefined);
          var _m$1 = m$2;
          while(true) {
            var m$3 = _m$1;
            var t$11 = Lexer$AcutisLang.pop(tokens);
            switch (t$11.TAG | 0) {
              case /* Tkn_Comma */8 :
                  _m$1 = parseKeyValueDict(Lexer$AcutisLang.pop(tokens), tokens, m$3);
                  continue ;
              case /* Tkn_ClosePointyBracket */17 :
                  return {
                          TAG: /* UDict */9,
                          _0: d$3,
                          _1: m$3
                        };
              default:
                throw {
                      RE_EXN_ID: Debug$AcutisLang.Exit,
                      _1: Debug$AcutisLang.unexpectedToken(t$11, Lexer$AcutisLang.Token),
                      Error: new Error()
                    };
            }
          };
        }
    case /* Tkn_Identifier */23 :
        return {
                TAG: /* UBinding */11,
                _0: t._0,
                _1: t._1
              };
    case /* Tkn_Bang */27 :
        return {
                TAG: /* UNullable */0,
                _0: t._0,
                _1: parseNode(Lexer$AcutisLang.pop(tokens), tokens)
              };
    case /* Tkn_At */28 :
        var t$12 = Lexer$AcutisLang.pop(tokens);
        switch (t$12.TAG | 0) {
          case /* Tkn_String */2 :
              return {
                      TAG: /* UStringEnum */6,
                      _0: t$12._0,
                      _1: t$12._1
                    };
          case /* Tkn_Int */3 :
              return {
                      TAG: /* UIntEnum */7,
                      _0: t$12._0,
                      _1: t$12._1
                    };
          default:
            throw {
                  RE_EXN_ID: Debug$AcutisLang.Exit,
                  _1: Debug$AcutisLang.unexpectedToken(t$12, Lexer$AcutisLang.Token),
                  Error: new Error()
                };
        }
    default:
      throw {
            RE_EXN_ID: Debug$AcutisLang.Exit,
            _1: Debug$AcutisLang.unexpectedToken(t, Lexer$AcutisLang.Token),
            Error: new Error()
          };
  }
}

function parseKeyValueAux(t, tokens, m) {
  switch (t.TAG | 0) {
    case /* Tkn_String */2 :
        var key = t._1;
        if (Belt_MapString.has(m, key)) {
          throw {
                RE_EXN_ID: Debug$AcutisLang.Exit,
                _1: Debug$AcutisLang.tooManyFields(t, Lexer$AcutisLang.Token),
                Error: new Error()
              };
        }
        var t$1 = Lexer$AcutisLang.pop(tokens);
        if (t$1.TAG === /* Tkn_Colon */9) {
          return [
                  key,
                  parseNode(Lexer$AcutisLang.pop(tokens), tokens)
                ];
        }
        throw {
              RE_EXN_ID: Debug$AcutisLang.Exit,
              _1: Debug$AcutisLang.unexpectedToken(t$1, Lexer$AcutisLang.Token),
              Error: new Error()
            };
    case /* Tkn_Identifier */23 :
        var key$1 = t._1;
        if (Belt_MapString.has(m, key$1)) {
          throw {
                RE_EXN_ID: Debug$AcutisLang.Exit,
                _1: Debug$AcutisLang.tooManyFields(t, Lexer$AcutisLang.Token),
                Error: new Error()
              };
        }
        var match = Lexer$AcutisLang.peek(tokens);
        if (match.TAG !== /* Tkn_Colon */9) {
          return [
                  key$1,
                  {
                    TAG: /* UBinding */11,
                    _0: t._0,
                    _1: key$1
                  }
                ];
        }
        Lexer$AcutisLang.pop(tokens);
        return [
                key$1,
                parseNode(Lexer$AcutisLang.pop(tokens), tokens)
              ];
    default:
      throw {
            RE_EXN_ID: Debug$AcutisLang.Exit,
            _1: Debug$AcutisLang.unexpectedToken(t, Lexer$AcutisLang.Token),
            Error: new Error()
          };
  }
}

function parseKeyValueRecord(t, tokens, tag, m) {
  if (t.TAG !== /* Tkn_At */28) {
    return [
            tag,
            parseKeyValueDict(t, tokens, m)
          ];
  }
  if (tag !== undefined) {
    throw {
          RE_EXN_ID: Debug$AcutisLang.Exit,
          _1: Debug$AcutisLang.tooManyTags(t._0),
          Error: new Error()
        };
  }
  return [
          parseKeyValueAux(Lexer$AcutisLang.pop(tokens), tokens, m),
          m
        ];
}

function parseKeyValueDict(t, tokens, m) {
  var match = parseKeyValueAux(t, tokens, m);
  return Belt_MapString.set(m, match[0], match[1]);
}

function make(tokens) {
  var head = parseNode(Lexer$AcutisLang.pop(tokens), tokens);
  var q = Belt_MutableQueue.make(undefined);
  var _param;
  while(true) {
    var match = Lexer$AcutisLang.peek(tokens);
    if (match.TAG !== /* Tkn_Comma */8) {
      return NonEmpty$AcutisLang.fromQueue(head, q);
    }
    Lexer$AcutisLang.pop(tokens);
    Belt_MutableQueue.add(q, parseNode(Lexer$AcutisLang.pop(tokens), tokens));
    _param = undefined;
    continue ;
  };
}

function parseEchoAux(t, esc) {
  switch (t.TAG | 0) {
    case /* Tkn_String */2 :
        return {
                TAG: /* EString */2,
                _0: t._0,
                _1: t._1,
                _2: esc
              };
    case /* Tkn_Identifier */23 :
        return {
                TAG: /* EBinding */0,
                _0: t._0,
                _1: t._1,
                _2: esc
              };
    default:
      throw {
            RE_EXN_ID: Debug$AcutisLang.Exit,
            _1: Debug$AcutisLang.unexpectedToken(t, Lexer$AcutisLang.Token),
            Error: new Error()
          };
  }
}

function parseEcho(tokens) {
  var t = Lexer$AcutisLang.pop(tokens);
  switch (t.TAG | 0) {
    case /* Tkn_ComponentName */19 :
        return {
                TAG: /* EChild */1,
                _0: t._0,
                _1: t._1
              };
    case /* Tkn_Ampersand */26 :
        return parseEchoAux(Lexer$AcutisLang.pop(tokens), /* NoEscape */0);
    default:
      return parseEchoAux(t, /* Escape */1);
  }
}

function parseEchoes(tokens) {
  var head = parseEcho(tokens);
  var q = Belt_MutableQueue.make(undefined);
  var _last = head;
  while(true) {
    var last = _last;
    var t = Lexer$AcutisLang.pop(tokens);
    switch (t.TAG | 0) {
      case /* Tkn_Text */0 :
      case /* Tkn_Tilde */24 :
          return {
                  nextT: t,
                  data: [
                    Belt_MutableQueue.toArray(q),
                    last
                  ]
                };
      case /* Tkn_Question */25 :
          Belt_MutableQueue.add(q, last);
          _last = parseEcho(tokens);
          continue ;
      default:
        throw {
              RE_EXN_ID: Debug$AcutisLang.Exit,
              _1: Debug$AcutisLang.unexpectedToken(t, Lexer$AcutisLang.Token),
              Error: new Error()
            };
    }
  };
}

function endOfMatchMap(t) {
  switch (t.TAG | 0) {
    case /* Tkn_Slash */20 :
        return true;
    case /* Tkn_Identifier */23 :
        if (t._1 === "with") {
          return true;
        } else {
          return false;
        }
    default:
      return false;
  }
}

function endOfFile(t) {
  if (t.TAG === /* Tkn_EndOfFile */30) {
    return true;
  } else {
    return false;
  }
}

function slash(t) {
  if (t.TAG === /* Tkn_Slash */20) {
    return true;
  } else {
    return false;
  }
}

function parse(t, tokens, until) {
  var q = Belt_MutableQueue.make(undefined);
  var _t = t;
  while(true) {
    var t$1 = _t;
    if (until(t$1)) {
      return {
              nextT: t$1,
              data: Belt_MutableQueue.toArray(q)
            };
    }
    switch (t$1.TAG | 0) {
      case /* Tkn_Text */0 :
          var x = t$1._1;
          var t$2 = Lexer$AcutisLang.pop(tokens);
          if (t$2.TAG === /* Tkn_Tilde */24) {
            Belt_MutableQueue.add(q, {
                  TAG: /* UText */0,
                  _0: x,
                  _1: /* TrimEnd */2
                });
            _t = Lexer$AcutisLang.pop(tokens);
            continue ;
          }
          Belt_MutableQueue.add(q, {
                TAG: /* UText */0,
                _0: x,
                _1: /* NoTrim */0
              });
          _t = t$2;
          continue ;
      case /* Tkn_Comment */1 :
          _t = Lexer$AcutisLang.pop(tokens);
          continue ;
      case /* Tkn_ComponentName */19 :
          Belt_MutableQueue.add(q, parseComponent(t$1._0, t$1._1, tokens));
          _t = Lexer$AcutisLang.pop(tokens);
          continue ;
      case /* Tkn_Identifier */23 :
          var d = t$1._0;
          switch (t$1._1) {
            case "map" :
                var pattern = parseNode(Lexer$AcutisLang.pop(tokens), tokens);
                var withs = parseWithBlocks(tokens, "map");
                Belt_MutableQueue.add(q, {
                      TAG: /* UMapList */3,
                      _0: d,
                      _1: pattern,
                      _2: withs
                    });
                _t = Lexer$AcutisLang.pop(tokens);
                continue ;
            case "map_dict" :
                var pattern$1 = parseNode(Lexer$AcutisLang.pop(tokens), tokens);
                var withs$1 = parseWithBlocks(tokens, "map_dict");
                Belt_MutableQueue.add(q, {
                      TAG: /* UMapDict */4,
                      _0: d,
                      _1: pattern$1,
                      _2: withs$1
                    });
                _t = Lexer$AcutisLang.pop(tokens);
                continue ;
            case "match" :
                var identifiers = make(tokens);
                var withs$2 = parseWithBlocks(tokens, "match");
                Belt_MutableQueue.add(q, {
                      TAG: /* UMatch */2,
                      _0: d,
                      _1: identifiers,
                      _2: withs$2
                    });
                _t = Lexer$AcutisLang.pop(tokens);
                continue ;
            default:
              throw {
                    RE_EXN_ID: Debug$AcutisLang.Exit,
                    _1: Debug$AcutisLang.unexpectedToken(t$1, Lexer$AcutisLang.Token),
                    Error: new Error()
                  };
          }
      case /* Tkn_Tilde */24 :
          var t$3 = Lexer$AcutisLang.pop(tokens);
          if (t$3.TAG === /* Tkn_Text */0) {
            var x$1 = t$3._1;
            var t$4 = Lexer$AcutisLang.pop(tokens);
            if (t$4.TAG === /* Tkn_Tilde */24) {
              Belt_MutableQueue.add(q, {
                    TAG: /* UText */0,
                    _0: x$1,
                    _1: /* TrimBoth */3
                  });
              _t = Lexer$AcutisLang.pop(tokens);
              continue ;
            }
            Belt_MutableQueue.add(q, {
                  TAG: /* UText */0,
                  _0: x$1,
                  _1: /* TrimStart */1
                });
            _t = t$4;
            continue ;
          }
          throw {
                RE_EXN_ID: Debug$AcutisLang.Exit,
                _1: Debug$AcutisLang.unexpectedToken(t$3, Lexer$AcutisLang.Token),
                Error: new Error()
              };
      case /* Tkn_Echo */29 :
          var match = parseEchoes(tokens);
          var match$1 = match.data;
          Belt_MutableQueue.add(q, {
                TAG: /* UEcho */1,
                _0: t$1._0,
                _1: match$1[0],
                _2: match$1[1]
              });
          _t = match.nextT;
          continue ;
      default:
        throw {
              RE_EXN_ID: Debug$AcutisLang.Exit,
              _1: Debug$AcutisLang.unexpectedToken(t$1, Lexer$AcutisLang.Token),
              Error: new Error()
            };
    }
  };
}

function parseWithBlock(tokens) {
  var head = make(tokens);
  var q = Belt_MutableQueue.make(undefined);
  var _param;
  while(true) {
    var t = Lexer$AcutisLang.pop(tokens);
    if (t.TAG === /* Tkn_Identifier */23 && t._1 === "with") {
      Belt_MutableQueue.add(q, make(tokens));
      _param = undefined;
      continue ;
    }
    var match = parse(t, tokens, endOfMatchMap);
    return {
            nextT: match.nextT,
            data: {
              patterns: NonEmpty$AcutisLang.fromQueue(head, q),
              nodes: match.data
            }
          };
  };
}

function parseWithBlocks(tokens, block) {
  var t = Lexer$AcutisLang.pop(tokens);
  if (t.TAG === /* Tkn_Identifier */23) {
    if (t._1 === "with") {
      var match = parseWithBlock(tokens);
      var head = match.data;
      var q = Belt_MutableQueue.make(undefined);
      var _t = match.nextT;
      while(true) {
        var t$1 = _t;
        if (t$1.TAG === /* Tkn_Slash */20) {
          var t$2 = Lexer$AcutisLang.pop(tokens);
          if (t$2.TAG === /* Tkn_Identifier */23) {
            if (t$2._1 === block) {
              return NonEmpty$AcutisLang.fromQueue(head, q);
            }
            throw {
                  RE_EXN_ID: Debug$AcutisLang.Exit,
                  _1: Debug$AcutisLang.unexpectedToken(t$2, Lexer$AcutisLang.Token),
                  Error: new Error()
                };
          }
          throw {
                RE_EXN_ID: Debug$AcutisLang.Exit,
                _1: Debug$AcutisLang.unexpectedToken(t$2, Lexer$AcutisLang.Token),
                Error: new Error()
              };
        }
        var match$1 = parseWithBlock(tokens);
        Belt_MutableQueue.add(q, match$1.data);
        _t = match$1.nextT;
        continue ;
      };
    }
    throw {
          RE_EXN_ID: Debug$AcutisLang.Exit,
          _1: Debug$AcutisLang.unexpectedToken(t, Lexer$AcutisLang.Token),
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: Debug$AcutisLang.Exit,
        _1: Debug$AcutisLang.unexpectedToken(t, Lexer$AcutisLang.Token),
        Error: new Error()
      };
}

function parseComponent(debug, name, tokens) {
  var match = parseProps(tokens);
  var match$1 = match.data;
  var children = match$1[1];
  var props = match$1[0];
  var nextT = match.nextT;
  if (nextT.TAG === /* Tkn_Slash */20) {
    return {
            TAG: /* UComponent */5,
            _0: debug,
            _1: name,
            _2: props,
            _3: children
          };
  }
  var match$2 = parse(nextT, tokens, slash);
  var t = Lexer$AcutisLang.pop(tokens);
  if (t.TAG === /* Tkn_ComponentName */19) {
    if (name === t._1) {
      var children$1 = Belt_MapString.set(children, "Children", {
            TAG: /* UChildBlock */1,
            _0: t._0,
            _1: match$2.data
          });
      return {
              TAG: /* UComponent */5,
              _0: debug,
              _1: name,
              _2: props,
              _3: children$1
            };
    }
    throw {
          RE_EXN_ID: Debug$AcutisLang.Exit,
          _1: Debug$AcutisLang.unexpectedToken(t, Lexer$AcutisLang.Token),
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: Debug$AcutisLang.Exit,
        _1: Debug$AcutisLang.unexpectedToken(t, Lexer$AcutisLang.Token),
        Error: new Error()
      };
}

function parseProps(tokens) {
  var _t = Lexer$AcutisLang.pop(tokens);
  var _props;
  var _children;
  while(true) {
    var children = _children;
    var props = _props;
    var t = _t;
    switch (t.TAG | 0) {
      case /* Tkn_ComponentName */19 :
          var name = t._1;
          var t$1 = Lexer$AcutisLang.pop(tokens);
          if (t$1.TAG === /* Tkn_Equals */22) {
            var t$2 = Lexer$AcutisLang.pop(tokens);
            switch (t$2.TAG | 0) {
              case /* Tkn_ComponentName */19 :
                  var children$1 = Belt_MapString.set(children, name, {
                        TAG: /* UChildName */0,
                        _0: t$2._0,
                        _1: t$2._1
                      });
                  _children = children$1;
                  _t = Lexer$AcutisLang.pop(tokens);
                  continue ;
              case /* Tkn_Block */21 :
                  var match = parse(Lexer$AcutisLang.pop(tokens), tokens, slash);
                  var d = Lexer$AcutisLang.pop(tokens);
                  if (d.TAG === /* Tkn_Block */21) {
                    var children$2 = Belt_MapString.set(children, name, {
                          TAG: /* UChildBlock */1,
                          _0: d._0,
                          _1: match.data
                        });
                    _children = children$2;
                    _t = Lexer$AcutisLang.pop(tokens);
                    continue ;
                  }
                  throw {
                        RE_EXN_ID: Debug$AcutisLang.Exit,
                        _1: Debug$AcutisLang.unexpectedToken(d, Lexer$AcutisLang.Token),
                        Error: new Error()
                      };
              default:
                throw {
                      RE_EXN_ID: Debug$AcutisLang.Exit,
                      _1: Debug$AcutisLang.unexpectedToken(t$2, Lexer$AcutisLang.Token),
                      Error: new Error()
                    };
            }
          } else {
            var children$3 = Belt_MapString.set(children, name, {
                  TAG: /* UChildName */0,
                  _0: t._0,
                  _1: name
                });
            _children = children$3;
            _t = t$1;
            continue ;
          }
      case /* Tkn_Identifier */23 :
          var key = t._1;
          var t$3 = Lexer$AcutisLang.pop(tokens);
          if (t$3.TAG === /* Tkn_Equals */22) {
            var prop = parseNode(Lexer$AcutisLang.pop(tokens), tokens);
            var props$1 = Belt_MapString.set(props, key, prop);
            _props = props$1;
            _t = Lexer$AcutisLang.pop(tokens);
            continue ;
          }
          var props$2 = Belt_MapString.set(props, key, {
                TAG: /* UBinding */11,
                _0: t._0,
                _1: key
              });
          _props = props$2;
          _t = t$3;
          continue ;
      default:
        return {
                nextT: t,
                data: [
                  props,
                  children
                ]
              };
    }
  };
}

function make$1(tokens) {
  return parse(Lexer$AcutisLang.pop(tokens), tokens, endOfFile).data;
}

var Pattern = {
  debug: debug,
  make: make
};

export {
  Pattern ,
  make$1 as make,
  
}
/* No side effect */

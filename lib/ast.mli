(**************************************************************************)
(*                                                                        *)
(*                   Copyright (c) 2022 John Jackson.                     *)
(*                                                                        *)
(*  This Source Code Form is subject to the terms of the Mozilla Public   *)
(*  License, v. 2.0. If a copy of the MPL was not distributed with this   *)
(*  file, You can obtain one at http://mozilla.org/MPL/2.0/.              *)
(*                                                                        *)
(**************************************************************************)

(** Define the untyped abstract syntax tree to be generated by the {!Parser}. *)

type loc = Lexing.position * Lexing.position
(** This type is equivalent to Menhir's [$loc] keyword. *)

val loc_dummy : loc

type 'a assoc = (loc * string * 'a) list
type 'a assoc_nonempty = (loc * string * 'a) Nonempty.t

type tag =
  | Tag_int of loc * int
  | Tag_bool of loc * int
  | Tag_string of loc * string

type 'a value = Tag of tag | Value of 'a
type 'a record = 'a value assoc_nonempty
type row = loc * [ `Closed | `Open ]

type ty =
  | Ty_named of loc * string
  | Ty_nullable of ty
  | Ty_list of ty
  | Ty_dict of ty
  | Ty_enum_int of (loc * int) Nonempty.t * row
  | Ty_enum_bool of (loc * int) Nonempty.t
  | Ty_enum_string of (loc * string) Nonempty.t * row
  | Ty_record of (loc * ty record) Nonempty.t * row
  | Ty_tuple of ty list

type prop = { loc : loc; name : string; ty : ty }
type interface = prop list
type trim = No_trim | Trim
type escape = No_escape | Escape
type echo_format = Fmt_string | Fmt_int | Fmt_float | Fmt_bool

(** The echo syntax is essentially a subset of the pattern syntax, one which
    only allows strings, variables, and record field access. *)

type echo =
  | Echo_var of loc * string
  | Echo_string of loc * string
  | Echo_field of echo * string

type pat =
  | Var of loc * string
  | Bool of loc * int
  | Int of loc * int
  | Float of loc * float
  | String of loc * string
  | Nullable of loc * pat option
  | Enum_string of loc * string
  | Enum_int of loc * int
  | List of loc * pat list * pat option
  | Tuple of loc * pat list
  | Record of loc * pat record
  | Dict of loc * pat assoc
  | Block of loc * t
  | Field of loc * pat * string

and node =
  | Text of string * trim * trim
  | Echo of (echo_format * echo) list * echo_format * echo * escape
  | Match of loc * pat Nonempty.t * case Nonempty.t
  | Map_list of loc * pat * case Nonempty.t
  | Map_dict of loc * pat * case Nonempty.t
  | Component of loc * string * string * pat assoc
  | Interface of loc * interface
  | Comment of string

and case = { pats : (loc * pat Nonempty.t) Nonempty.t; nodes : t }
and t = node list

val dummy_var : pat
(** A variable that is always ignored. *)

module Ty_repr : sig
  val loc : loc -> Pp.Ty_repr.t
  val echo_format : echo_format -> Pp.Ty_repr.t
  val escape : escape -> Pp.Ty_repr.t
  val t : t -> Pp.Ty_repr.t
end

val pp_tag : Format.formatter -> tag -> unit
val pp_pat : Format.formatter -> pat -> unit

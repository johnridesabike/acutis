(**************************************************************************)
(*                                                                        *)
(*                   Copyright (c) 2022 John Jackson.                     *)
(*                                                                        *)
(*  This Source Code Form is subject to the terms of the Mozilla Public   *)
(*  License, v. 2.0. If a copy of the MPL was not distributed with this   *)
(*  file, You can obtain one at http://mozilla.org/MPL/2.0/.              *)
(*                                                                        *)
(**************************************************************************)

(** Define the untyped abstract syntax tree to be generated by the {!Parser}.
 *)

module Dict : sig
  (** This is a {!Map.String} which enforces that keys cannot change after
      they're set. *)

  type 'a t

  val empty : _ t
  val add : Loc.t -> string -> 'a -> 'a t -> 'a t
  val singleton : string -> 'a -> 'a t
  val to_map : 'a t -> 'a Map.String.t
end

module Record : sig
  type tag =
    | Tag_int of Loc.t * int
    | Tag_bool of Loc.t * int
    | Tag_string of Loc.t * string

  val pp_tag : Format.formatter -> tag -> unit

  type 'a t = Untagged of 'a Dict.t | Tagged of string * tag * 'a Dict.t

  val add :
    Loc.t -> [ `Tag of string * tag | `Notag of string * 'a ] -> 'a t -> 'a t

  val singleton : [ `Tag of string * tag | `Notag of string * 'a ] -> 'a t
end

module Interface : sig
  type ty =
    | Named of Loc.t * string
    | Nullable of ty
    | List of ty
    | Dict of ty
    | Enum_int of int Nonempty.t * Typescheme.Variant.row
    | Enum_bool of int Nonempty.t
    | Enum_string of string Nonempty.t * Typescheme.Variant.row
    | Record of (Loc.t * ty Record.t) Nonempty.t * Typescheme.Variant.row
    | Tuple of ty list

  type t =
    | Type of Loc.t * string * ty
    | Child of Loc.t * string
    | Child_nullable of Loc.t * string
end

module Pattern : sig
  type t =
    | Var of Loc.t * string
    | Bool of Loc.t * int
    | Int of Loc.t * int
    | Float of Loc.t * float
    | String of Loc.t * string
    | Nullable of Loc.t * t option
    | Enum_string of Loc.t * string
    | Enum_int of Loc.t * int
    | List of Loc.t * t list * t option
    | Tuple of Loc.t * t list
    | Record of Loc.t * t Record.t
    | Dict of Loc.t * t Dict.t
end

type trim = No_trim | Trim
type escape = No_escape | Escape

type echo =
  | Ech_var of Loc.t * string * escape
  | Ech_component of Loc.t * string
  | Ech_string of Loc.t * string

type node =
  | Text of string * trim * trim
  | Echo of echo list * echo
  | Match of Loc.t * Pattern.t Nonempty.t * case Nonempty.t
  | Map_list of Loc.t * Pattern.t * case Nonempty.t
  | Map_dict of Loc.t * Pattern.t * case Nonempty.t
  | Component of Loc.t * string * string * Pattern.t Dict.t * child Dict.t
  | Interface of Loc.t * Interface.t list

and case = { pats : (Loc.t * Pattern.t Nonempty.t) Nonempty.t; nodes : t }
and child = Child_name of Loc.t * string | Child_block of t
and t = node list

val equal : t -> t -> bool
val pp : Format.formatter -> t -> unit

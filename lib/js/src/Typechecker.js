// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("@rescript/std/lib/js/curry.js");
var Belt_Array = require("@rescript/std/lib/js/belt_Array.js");
var Belt_MapInt = require("@rescript/std/lib/js/belt_MapInt.js");
var Belt_SetInt = require("@rescript/std/lib/js/belt_SetInt.js");
var Caml_option = require("@rescript/std/lib/js/caml_option.js");
var Belt_MapString = require("@rescript/std/lib/js/belt_MapString.js");
var Belt_SetString = require("@rescript/std/lib/js/belt_SetString.js");
var Debug$AcutisLang = require("./Debug.js");
var Utils$AcutisLang = require("./Utils.js");
var Belt_MutableQueue = require("@rescript/std/lib/js/belt_MutableQueue.js");
var Parser$AcutisLang = require("./Parser.js");
var Source$AcutisLang = require("./Source.js");
var NonEmpty$AcutisLang = require("./NonEmpty.js");
var Typescheme$AcutisLang = require("./Typescheme.js");

function unify_enum_cases(a, b, aty, bty, param, debug) {
  if (a.TAG === /* Int */0) {
    if (b.TAG === /* Int */0) {
      return {
              TAG: /* Int */0,
              _0: Belt_SetInt.union(a._0, b._0)
            };
    }
    
  } else if (b.TAG !== /* Int */0) {
    return {
            TAG: /* String */1,
            _0: Belt_SetString.union(a._0, b._0)
          };
  }
  throw {
        RE_EXN_ID: Debug$AcutisLang.Exit,
        _1: Debug$AcutisLang.typeMismatch(debug, aty, bty, Typescheme$AcutisLang.toString),
        Error: new Error()
      };
}

function subset_enum_cases(a, b, aty, bty, param, debug) {
  var success;
  success = a.TAG === /* Int */0 ? (
      b.TAG === /* Int */0 ? Belt_SetInt.subset(b._0, a._0) : false
    ) : (
      b.TAG === /* Int */0 ? false : Belt_SetString.subset(b._0, a._0)
    );
  if (success) {
    return ;
  }
  throw {
        RE_EXN_ID: Debug$AcutisLang.Exit,
        _1: Debug$AcutisLang.typeMismatch(debug, aty, bty, Typescheme$AcutisLang.toString),
        Error: new Error()
      };
}

function unify_variant(a, b, aty, bty, mode, debug, unify_cases, subset_cases) {
  switch (mode) {
    case /* Destructure_expand */0 :
        var match = a.row;
        var match$1 = b.row;
        if (match || match$1) {
          a.row = /* Open */1;
        } else {
          a.row = /* Closed */0;
        }
        a.cases = Curry._6(unify_cases, a.cases, b.cases, aty, bty, mode, debug);
        return ;
    case /* Construct_literal */1 :
        var match$2 = a.row;
        if (match$2) {
          a.cases = Curry._6(unify_cases, a.cases, b.cases, aty, bty, mode, debug);
          return ;
        } else {
          return Curry._6(subset_cases, a.cases, b.cases, aty, bty, mode, debug);
        }
    case /* Construct_var */2 :
        var match$3 = a.row;
        var match$4 = b.row;
        if (match$3) {
          if (!match$4) {
            a.cases = Curry._6(unify_cases, a.cases, b.cases, aty, bty, mode, debug);
            return ;
          }
          var cases = Curry._6(unify_cases, a.cases, b.cases, aty, bty, mode, debug);
          a.cases = cases;
          b.cases = cases;
          return ;
        }
        if (match$4) {
          throw {
                RE_EXN_ID: Debug$AcutisLang.Exit,
                _1: Debug$AcutisLang.typeMismatch(debug, aty, bty, Typescheme$AcutisLang.toString),
                Error: new Error()
              };
        }
        return Curry._6(subset_cases, a.cases, b.cases, aty, bty, mode, debug);
    
  }
}

function unify(_aty, _bty, mode, debug) {
  while(true) {
    var bty = _bty;
    var aty = _aty;
    var match = aty.contents;
    var match$1 = bty.contents;
    var exit = 0;
    if (typeof match === "number") {
      switch (match) {
        case /* Unknown */0 :
            aty.contents = match$1;
            return ;
        case /* Int */1 :
            if (typeof match$1 === "number") {
              if (match$1 === 1) {
                return ;
              }
              if (match$1 === 0) {
                bty.contents = match;
                return ;
              }
              exit = 2;
            } else {
              exit = 2;
            }
            break;
        case /* Float */2 :
            if (typeof match$1 === "number" && match$1 < 3) {
              switch (match$1) {
                case /* Unknown */0 :
                    bty.contents = match;
                    return ;
                case /* Int */1 :
                    exit = 2;
                    break;
                case /* Float */2 :
                    return ;
                
              }
            } else {
              exit = 2;
            }
            break;
        case /* String */3 :
            if (typeof match$1 === "number") {
              if (match$1 === 3) {
                return ;
              }
              if (match$1 === 0) {
                bty.contents = match;
                return ;
              }
              exit = 2;
            } else {
              exit = 2;
            }
            break;
        case /* Echo */4 :
            if (typeof match$1 === "number") {
              switch (match$1) {
                case /* Unknown */0 :
                    bty.contents = match;
                    return ;
                case /* Int */1 :
                case /* Float */2 :
                case /* String */3 :
                case /* Echo */4 :
                    aty.contents = match$1;
                    return ;
                
              }
            } else if (match$1.TAG === /* Enum */5) {
              aty.contents = match$1;
              return ;
            }
            break;
        
      }
    } else {
      switch (match.TAG | 0) {
        case /* Nullable */0 :
            if (typeof match$1 === "number") {
              if (match$1 === /* Unknown */0) {
                bty.contents = match;
                return ;
              }
              
            } else if (match$1.TAG === /* Nullable */0) {
              _bty = match$1._0;
              _aty = match._0;
              continue ;
            }
            break;
        case /* List */1 :
            if (typeof match$1 === "number") {
              if (match$1 === /* Unknown */0) {
                bty.contents = match;
                return ;
              }
              
            } else if (match$1.TAG === /* List */1) {
              _bty = match$1._0;
              _aty = match._0;
              continue ;
            }
            break;
        case /* Tuple */2 :
            var t1 = match._0;
            if (typeof match$1 === "number") {
              if (match$1 === /* Unknown */0) {
                bty.contents = match;
                return ;
              }
              
            } else if (match$1.TAG === /* Tuple */2) {
              var t2 = match$1._0;
              var s1 = t1.length;
              var s2 = t2.length;
              if (s1 === s2) {
                Belt_Array.zipByU(t1, t2, (function (a, b) {
                        return unify(a, b, mode, debug);
                      }));
                return ;
              }
              throw {
                    RE_EXN_ID: Debug$AcutisLang.Exit,
                    _1: Debug$AcutisLang.tupleSizeMismatch(debug, s1, s2),
                    Error: new Error()
                  };
            }
            break;
        case /* Record */3 :
            if (typeof match$1 === "number") {
              if (match$1 === /* Unknown */0) {
                bty.contents = match;
                return ;
              }
              
            } else if (match$1.TAG === /* Record */3) {
              return unify_record(match._0, match$1._0, aty, bty, mode, debug);
            }
            break;
        case /* Dict */4 :
            var ks1 = match._1;
            if (typeof match$1 === "number") {
              if (match$1 === /* Unknown */0) {
                bty.contents = match;
                return ;
              }
              
            } else if (match$1.TAG === /* Dict */4) {
              var ks2 = match$1._1;
              var ks$p = Belt_SetString.union(ks1.contents, ks2.contents);
              ks1.contents = ks$p;
              ks2.contents = ks$p;
              _bty = match$1._0;
              _aty = match._0;
              continue ;
            }
            break;
        case /* Enum */5 :
            if (typeof match$1 === "number") {
              if (match$1 === /* Unknown */0) {
                bty.contents = match;
                return ;
              }
              exit = 2;
            } else {
              if (match$1.TAG === /* Enum */5) {
                return unify_variant(match._0, match$1._0, aty, bty, mode, debug, unify_enum_cases, subset_enum_cases);
              }
              exit = 2;
            }
            break;
        case /* Union */6 :
            if (typeof match$1 === "number") {
              if (match$1 === /* Unknown */0) {
                bty.contents = match;
                return ;
              }
              
            } else if (match$1.TAG === /* Union */6 && match._0 === match$1._0) {
              return unify_variant(match._1, match$1._1, aty, bty, mode, debug, unify_union_cases, subset_union_cases);
            }
            break;
        
      }
    }
    if (exit === 2 && typeof match$1 === "number" && match$1 >= 4) {
      bty.contents = match;
      return ;
    }
    throw {
          RE_EXN_ID: Debug$AcutisLang.Exit,
          _1: Debug$AcutisLang.typeMismatch(debug, aty, bty, Typescheme$AcutisLang.toString),
          Error: new Error()
        };
  };
}

function unify_union_cases(a, b, aty, bty, mode, debug) {
  var f = function (param, a, b) {
    if (a !== undefined) {
      if (b !== undefined) {
        unify_record(a, b, aty, bty, mode, debug);
        return a;
      } else {
        return a;
      }
    } else if (b !== undefined) {
      return b;
    } else {
      return ;
    }
  };
  if (a.TAG === /* Int */0) {
    if (b.TAG === /* Int */0) {
      return {
              TAG: /* Int */0,
              _0: Belt_MapInt.mergeU(a._0, b._0, f)
            };
    }
    
  } else if (b.TAG !== /* Int */0) {
    return {
            TAG: /* String */1,
            _0: Belt_MapString.mergeU(a._0, b._0, f)
          };
  }
  throw {
        RE_EXN_ID: Debug$AcutisLang.Exit,
        _1: Debug$AcutisLang.typeMismatch(debug, aty, bty, Typescheme$AcutisLang.toString),
        Error: new Error()
      };
}

function subset_union_cases(a, b, aty, bty, mode, debug) {
  var f = function (param, a, b) {
    if (a !== undefined) {
      if (b !== undefined) {
        unify_record(a, b, aty, bty, mode, debug);
        return a;
      } else {
        return a;
      }
    }
    if (b === undefined) {
      return ;
    }
    throw {
          RE_EXN_ID: Debug$AcutisLang.Exit,
          _1: Debug$AcutisLang.typeMismatch(debug, aty, bty, Typescheme$AcutisLang.toString),
          Error: new Error()
        };
  };
  if (a.TAG === /* Int */0) {
    if (b.TAG === /* Int */0) {
      Belt_MapInt.mergeU(a._0, b._0, f);
      return ;
    }
    
  } else if (b.TAG !== /* Int */0) {
    Belt_MapString.mergeU(a._0, b._0, f);
    return ;
  }
  throw {
        RE_EXN_ID: Debug$AcutisLang.Exit,
        _1: Debug$AcutisLang.typeMismatch(debug, aty, bty, Typescheme$AcutisLang.toString),
        Error: new Error()
      };
}

function unify_record(a, b, aty, bty, mode, debug) {
  switch (mode) {
    case /* Destructure_expand */0 :
        a.contents = Belt_MapString.mergeU(a.contents, b.contents, (function (param, v1, v2) {
                if (v1 !== undefined) {
                  if (v2 !== undefined) {
                    unify(v1, v2, mode, debug);
                    return v1;
                  } else {
                    return v1;
                  }
                } else if (v2 !== undefined) {
                  return v2;
                } else {
                  return ;
                }
              }));
        return ;
    case /* Construct_literal */1 :
        var r = Belt_MapString.mergeU(a.contents, b.contents, (function (param, v1, v2) {
                if (v1 !== undefined && v2 !== undefined) {
                  unify(v1, v2, mode, debug);
                  return v1;
                }
                
              }));
        if (Belt_MapString.isEmpty(r)) {
          throw {
                RE_EXN_ID: Debug$AcutisLang.Exit,
                _1: Debug$AcutisLang.cantNarrowType(debug, aty, bty, Typescheme$AcutisLang.toString),
                Error: new Error()
              };
        }
        a.contents = r;
        return ;
    case /* Construct_var */2 :
        b.contents = Belt_MapString.mergeU(a.contents, b.contents, (function (param, v1, v2) {
                if (v1 !== undefined) {
                  if (v2 !== undefined) {
                    unify(v1, v2, mode, debug);
                    return v2;
                  } else {
                    return v1;
                  }
                } else if (v2 !== undefined) {
                  return v2;
                } else {
                  return ;
                }
              }));
        return ;
    
  }
}

function open_rows_bool_union_aux(ty) {
  if (ty !== undefined) {
    Belt_MapString.forEachU(ty.contents, (function (param, v) {
            return open_rows(v);
          }));
    return ty;
  } else {
    return {
            contents: undefined
          };
  }
}

function open_rows(_ty) {
  while(true) {
    var ty = _ty;
    var ty$1 = ty.contents;
    if (typeof ty$1 === "number") {
      return ;
    }
    switch (ty$1.TAG | 0) {
      case /* Tuple */2 :
          return Belt_Array.forEach(ty$1._0, open_rows);
      case /* Record */3 :
          return Belt_MapString.forEachU(ty$1._0.contents, (function (param, v) {
                        return open_rows(v);
                      }));
      case /* Nullable */0 :
      case /* List */1 :
      case /* Dict */4 :
          _ty = ty$1._0;
          continue ;
      case /* Enum */5 :
          var ty$2 = ty$1._0;
          var match = ty$2.extra;
          if (match) {
            ty$2.cases = Typescheme$AcutisLang.Enum.false_and_true_cases;
          } else {
            ty$2.row = /* Open */1;
          }
          return ;
      case /* Union */6 :
          var ty$3 = ty$1._1;
          var match$1 = ty$3.extra;
          var match$2 = ty$3.cases;
          if (match$1 && match$2.TAG === /* Int */0) {
            ty$3.cases = {
              TAG: /* Int */0,
              _0: Belt_MapInt.updateU(Belt_MapInt.updateU(match$2._0, 0, open_rows_bool_union_aux), 1, open_rows_bool_union_aux)
            };
            return ;
          }
          if (match$2.TAG === /* Int */0) {
            Belt_MapInt.forEachU(match$2._0, (function (param, v) {
                    return Belt_MapString.forEachU(v.contents, (function (param, v) {
                                  return open_rows(v);
                                }));
                  }));
            ty$3.row = /* Open */1;
            return ;
          }
          Belt_MapString.forEachU(match$2._0, (function (param, v) {
                  return Belt_MapString.forEachU(v.contents, (function (param, v) {
                                return open_rows(v);
                              }));
                }));
          ty$3.row = /* Open */1;
          return ;
          break;
      
    }
  };
}

function make_enum_aux(tag, extra, row, tyvars, debug) {
  switch (tag.TAG | 0) {
    case /* TString */0 :
        return {
                cases: {
                  TAG: /* String */1,
                  _0: Belt_MapString.set(undefined, tag._0, tyvars)
                },
                row: row,
                extra: extra
              };
    case /* TInt */1 :
        return {
                cases: {
                  TAG: /* Int */0,
                  _0: Belt_MapInt.set(undefined, tag._0, tyvars)
                },
                row: row,
                extra: extra
              };
    case /* TFloat */2 :
        throw {
              RE_EXN_ID: Debug$AcutisLang.Exit,
              _1: Debug$AcutisLang.badUnionTag(debug),
              Error: new Error()
            };
    
  }
}

function make(pat, ty, f, mode) {
  switch (pat.TAG | 0) {
    case /* UNullable */0 :
        var pat$1 = pat._1;
        var dbg = pat._0;
        var ty$1 = ty.contents;
        var tyvar;
        tyvar = typeof ty$1 === "number" || ty$1.TAG !== /* Nullable */0 ? Typescheme$AcutisLang.unknown(undefined) : ty$1._0;
        var pat$2 = pat$1 !== undefined ? ({
              TAG: /* TTuple */2,
              _0: dbg,
              _1: [make(pat$1, tyvar, f, mode)]
            }) : undefined;
        unify(ty, Typescheme$AcutisLang.nullable(tyvar), mode, dbg);
        return {
                TAG: /* TConstruct */1,
                _0: dbg,
                _1: /* TNullable */1,
                _2: pat$2
              };
    case /* UBool */1 :
        var b = pat._1;
        var dbg$1 = pat._0;
        var new_enum = mode !== 0 ? Typescheme$AcutisLang.Enum.false_and_true(undefined) : (
            b !== 0 ? Typescheme$AcutisLang.Enum.true_only(undefined) : Typescheme$AcutisLang.Enum.false_only(undefined)
          );
        var new_ty = {
          contents: {
            TAG: /* Enum */5,
            _0: new_enum
          }
        };
        var $$enum = ty.contents;
        var $$enum$1;
        $$enum$1 = typeof $$enum === "number" || $$enum.TAG !== /* Enum */5 ? new_enum : $$enum._0;
        unify(ty, new_ty, mode, dbg$1);
        return {
                TAG: /* TConst */0,
                _0: dbg$1,
                _1: {
                  TAG: /* TInt */1,
                  _0: b
                },
                _2: $$enum$1
              };
    case /* UString */2 :
        var dbg$2 = pat._0;
        unify(ty, Typescheme$AcutisLang.string(undefined), mode, dbg$2);
        return {
                TAG: /* TConst */0,
                _0: dbg$2,
                _1: {
                  TAG: /* TString */0,
                  _0: pat._1
                },
                _2: undefined
              };
    case /* UInt */3 :
        var dbg$3 = pat._0;
        unify(ty, Typescheme$AcutisLang.$$int(undefined), mode, dbg$3);
        return {
                TAG: /* TConst */0,
                _0: dbg$3,
                _1: {
                  TAG: /* TInt */1,
                  _0: pat._1
                },
                _2: undefined
              };
    case /* UFloat */4 :
        var dbg$4 = pat._0;
        unify(ty, Typescheme$AcutisLang.$$float(undefined), mode, dbg$4);
        return {
                TAG: /* TConst */0,
                _0: dbg$4,
                _1: {
                  TAG: /* TFloat */2,
                  _0: pat._1
                },
                _2: undefined
              };
    case /* UTuple */5 :
        var a = pat._1;
        var dbg$5 = pat._0;
        var new_tyvars = Belt_Array.mapU(a, (function (param) {
                return Typescheme$AcutisLang.unknown(undefined);
              }));
        var tys = ty.contents;
        var tyvars;
        tyvars = typeof tys === "number" || tys.TAG !== /* Tuple */2 ? new_tyvars : tys._0;
        unify(ty, Typescheme$AcutisLang.tuple(tyvars), mode, dbg$5);
        return {
                TAG: /* TTuple */2,
                _0: dbg$5,
                _1: Belt_Array.zipByU(a, tyvars, (function (pat, ty) {
                        return make(pat, ty, f, mode);
                      }))
              };
    case /* UStringEnum */6 :
        var s = pat._1;
        var dbg$6 = pat._0;
        var new_enum$1 = mode !== 0 ? Typescheme$AcutisLang.Enum.string_singleton(s, /* Open */1) : Typescheme$AcutisLang.Enum.string_singleton(s, /* Closed */0);
        var new_ty$1 = {
          contents: {
            TAG: /* Enum */5,
            _0: new_enum$1
          }
        };
        var $$enum$2 = ty.contents;
        var $$enum$3;
        $$enum$3 = typeof $$enum$2 === "number" || $$enum$2.TAG !== /* Enum */5 ? new_enum$1 : $$enum$2._0;
        unify(ty, new_ty$1, mode, dbg$6);
        return {
                TAG: /* TConst */0,
                _0: dbg$6,
                _1: {
                  TAG: /* TString */0,
                  _0: s
                },
                _2: $$enum$3
              };
    case /* UIntEnum */7 :
        var i = pat._1;
        var dbg$7 = pat._0;
        var new_enum$2 = mode !== 0 ? Typescheme$AcutisLang.Enum.int_singleton(i, /* Open */1) : Typescheme$AcutisLang.Enum.int_singleton(i, /* Closed */0);
        var new_ty$2 = {
          contents: {
            TAG: /* Enum */5,
            _0: new_enum$2
          }
        };
        var $$enum$4 = ty.contents;
        var $$enum$5;
        $$enum$5 = typeof $$enum$4 === "number" || $$enum$4.TAG !== /* Enum */5 ? new_enum$2 : $$enum$4._0;
        unify(ty, new_ty$2, mode, dbg$7);
        return {
                TAG: /* TConst */0,
                _0: dbg$7,
                _1: {
                  TAG: /* TInt */1,
                  _0: i
                },
                _2: $$enum$5
              };
    case /* UList */8 :
        var tail = pat._2;
        var dbg$8 = pat._0;
        var ty$2 = ty.contents;
        var tyvar$1;
        tyvar$1 = typeof ty$2 === "number" || ty$2.TAG !== /* List */1 ? Typescheme$AcutisLang.unknown(undefined) : ty$2._0;
        unify(ty, Typescheme$AcutisLang.list(tyvar$1), mode, dbg$8);
        var tl = tail !== undefined ? make(tail, ty, f, mode) : ({
              TAG: /* TConstruct */1,
              _0: dbg$8,
              _1: /* TList */0,
              _2: undefined
            });
        return make_list(tl, f, pat._1, 0, tyvar$1, mode);
    case /* UDict */9 :
        var dbg$9 = pat._0;
        var new_kys = {
          contents: undefined
        };
        var match = ty.contents;
        var match$1;
        match$1 = typeof match === "number" || match.TAG !== /* Dict */4 ? [
            Typescheme$AcutisLang.unknown(undefined),
            new_kys
          ] : [
            match._0,
            match._1
          ];
        var tyvar$2 = match$1[0];
        unify(ty, Typescheme$AcutisLang.internal_dict_keys(tyvar$2, new_kys), mode, dbg$9);
        var d = Belt_MapString.mapU(pat._1, (function (pat) {
                return make(pat, tyvar$2, f, mode);
              }));
        return {
                TAG: /* TDict */4,
                _0: dbg$9,
                _1: d,
                _2: match$1[1]
              };
    case /* URecord */10 :
        var match$2 = pat._1;
        var dbg$10 = pat._0;
        if (match$2 !== undefined) {
          var m = pat._2;
          var k = match$2[0];
          var new_tyvars$1 = {
            contents: Belt_MapString.mapU(m, (function (param) {
                    return Typescheme$AcutisLang.unknown(undefined);
                  }))
          };
          var new_tag_ty = Typescheme$AcutisLang.unknown(undefined);
          var row = mode !== 0 ? /* Open */1 : /* Closed */0;
          var match$3 = make(match$2[1], new_tag_ty, f, mode);
          var match$4;
          if (match$3.TAG === /* TConst */0) {
            var match$5 = match$3._2;
            var tag = match$3._1;
            match$4 = match$5 !== undefined ? [
                tag,
                match$5.extra
              ] : [
                tag,
                /* Extra_none */0
              ];
          } else {
            throw {
                  RE_EXN_ID: Debug$AcutisLang.Exit,
                  _1: Debug$AcutisLang.badUnionTag(dbg$10),
                  Error: new Error()
                };
          }
          var tag$1 = match$4[0];
          var match$6 = ty.contents;
          var tyvars$1;
          if (typeof match$6 === "number" || match$6.TAG !== /* Union */6) {
            tyvars$1 = new_tyvars$1;
          } else {
            var $$enum$6 = match$6._1;
            var tyvars$2;
            switch (tag$1.TAG | 0) {
              case /* TString */0 :
                  var cases = $$enum$6.cases;
                  tyvars$2 = cases.TAG === /* Int */0 ? undefined : Belt_MapString.get(cases._0, tag$1._0);
                  break;
              case /* TInt */1 :
                  var cases$1 = $$enum$6.cases;
                  tyvars$2 = cases$1.TAG === /* Int */0 ? Belt_MapInt.get(cases$1._0, tag$1._0) : undefined;
                  break;
              case /* TFloat */2 :
                  tyvars$2 = undefined;
                  break;
              
            }
            tyvars$1 = tyvars$2 !== undefined ? tyvars$2 : new_tyvars$1;
          }
          var new_enum$3 = make_enum_aux(tag$1, match$4[1], row, new_tyvars$1, dbg$10);
          unify(ty, {
                contents: {
                  TAG: /* Union */6,
                  _0: k,
                  _1: new_enum$3
                }
              }, mode, dbg$10);
          var r = make_record(m, tyvars$1.contents, f, dbg$10, mode);
          return {
                  TAG: /* TRecord */3,
                  _0: dbg$10,
                  _1: [
                    k,
                    tag$1,
                    new_enum$3
                  ],
                  _2: r,
                  _3: tyvars$1
                };
        }
        var m$1 = pat._2;
        var new_tyvars$2 = {
          contents: Belt_MapString.mapU(m$1, (function (param) {
                  return Typescheme$AcutisLang.unknown(undefined);
                }))
        };
        var tys$1 = ty.contents;
        var tyvars$3;
        tyvars$3 = typeof tys$1 === "number" || tys$1.TAG !== /* Record */3 ? new_tyvars$2 : tys$1._0;
        unify(ty, Typescheme$AcutisLang.internal_record(new_tyvars$2), mode, dbg$10);
        var r$1 = make_record(m$1, tyvars$3.contents, f, dbg$10, mode);
        return {
                TAG: /* TRecord */3,
                _0: dbg$10,
                _1: undefined,
                _2: r$1,
                _3: tyvars$3
              };
    case /* UBinding */11 :
        var b$1 = pat._1;
        var dbg$11 = pat._0;
        if (b$1 === "_") {
          if (mode !== 0) {
            throw {
                  RE_EXN_ID: Debug$AcutisLang.Exit,
                  _1: Debug$AcutisLang.underscoreInConstruct(dbg$11),
                  Error: new Error()
                };
          }
          open_rows(ty);
          return {
                  TAG: /* TAny */7,
                  _0: dbg$11
                };
        }
        if (mode !== 0) {
          
        } else {
          open_rows(ty);
        }
        f(b$1, ty, dbg$11);
        return {
                TAG: /* TVar */5,
                _0: dbg$11,
                _1: b$1
              };
    
  }
}

function make_list(tl, f, a, i, ty, mode) {
  var p = Belt_Array.get(a, i);
  if (p === undefined) {
    return tl;
  }
  var dbg = Parser$AcutisLang.Pattern.debug(p);
  var hd = make(p, ty, f, mode);
  var tl$1 = make_list(tl, f, a, i + 1 | 0, ty, mode);
  return {
          TAG: /* TConstruct */1,
          _0: dbg,
          _1: /* TList */0,
          _2: {
            TAG: /* TTuple */2,
            _0: dbg,
            _1: [
              hd,
              tl$1
            ]
          }
        };
}

function make_record(m, tyvars, f, dbg, mode) {
  if (mode !== 0) {
    return Belt_MapString.mergeU(m, tyvars, (function (k, pat, ty) {
                  if (pat !== undefined) {
                    if (ty !== undefined) {
                      return make(pat, ty, f, mode);
                    } else {
                      return ;
                    }
                  }
                  if (ty === undefined) {
                    return ;
                  }
                  throw {
                        RE_EXN_ID: Debug$AcutisLang.Exit,
                        _1: Debug$AcutisLang.missingRecordField(dbg, k, ty, Typescheme$AcutisLang.toString),
                        Error: new Error()
                      };
                }));
  } else {
    return Belt_MapString.mergeU(m, tyvars, (function (param, pat, ty) {
                  if (pat !== undefined) {
                    if (ty !== undefined) {
                      return make(pat, ty, f, mode);
                    } else {
                      return make(pat, Typescheme$AcutisLang.unknown(undefined), f, mode);
                    }
                  } else if (ty !== undefined) {
                    return {
                            TAG: /* TAny */7,
                            _0: dbg
                          };
                  } else {
                    return ;
                  }
                }));
  }
}

function toStringConst(x, e) {
  switch (x.TAG | 0) {
    case /* TString */0 :
        var s = x._0;
        if (e !== undefined) {
          return "@\"" + s + "\"";
        } else {
          return "\"" + s + "\"";
        }
    case /* TInt */1 :
        var i = x._0;
        if (e !== undefined) {
          if (e.extra) {
            if (i !== 0) {
              return "true";
            } else {
              return "false";
            }
          } else {
            return "@" + String(i);
          }
        } else {
          return String(i);
        }
    case /* TFloat */2 :
        return String(x._0);
    
  }
}

function keyValuesToString(k, v) {
  if (v === k) {
    return v;
  } else {
    return k + ": " + v;
  }
}

function toString(x) {
  switch (x.TAG | 0) {
    case /* TConst */0 :
        return toStringConst(x._1, x._2);
    case /* TConstruct */1 :
        if (x._1) {
          var x$1 = x._2;
          if (x$1 !== undefined) {
            return "!" + toString(x$1);
          } else {
            return "null";
          }
        }
        var l = x._2;
        if (l === undefined) {
          return "[]";
        }
        var _s = "[";
        var _sep = "";
        var _l = l;
        while(true) {
          var l$1 = _l;
          var sep = _sep;
          var s = _s;
          if (l$1.TAG === /* TTuple */2) {
            var match = l$1._1;
            if (match.length === 2) {
              var hd = match[0];
              var tl = match[1];
              if (tl.TAG !== /* TConstruct */1) {
                return s + sep + toString(hd) + ",..." + toString(tl) + "]";
              }
              var tl$1 = tl._2;
              if (tl$1 === undefined) {
                return s + sep + toString(hd) + "]";
              }
              _l = tl$1;
              _sep = ", ";
              _s = s + sep + toString(hd);
              continue ;
            }
            
          }
          return s + sep + "..." + toString(l$1) + "]";
        };
    case /* TTuple */2 :
        return "(" + Belt_Array.joinWith(x._1, ", ", toString) + ")";
    case /* TRecord */3 :
        var uniontag = x._1;
        var s$1 = Belt_Array.joinWith(Belt_MapString.toArray(x._2), ", ", (function (param) {
                return keyValuesToString(param[0], toString(param[1]));
              }));
        if (uniontag === undefined) {
          return "{" + s$1 + "}";
        }
        var v = uniontag[1];
        var k = uniontag[0];
        var tag;
        var exit = 0;
        var exit$1 = 0;
        switch (v.TAG | 0) {
          case /* TInt */1 :
              if (v._0 !== 0) {
                exit$1 = 2;
              } else if (uniontag[2].extra) {
                tag = "@\"" + k + "\": false";
              } else {
                exit = 1;
              }
              break;
          case /* TString */0 :
          case /* TFloat */2 :
              exit$1 = 2;
              break;
          
        }
        if (exit$1 === 2) {
          if (uniontag[2].extra) {
            tag = "@\"" + k + "\": true";
          } else {
            exit = 1;
          }
        }
        if (exit === 1) {
          tag = "@\"" + k + "\": " + toStringConst(v, undefined);
        }
        var sep$1 = s$1 === "" ? "" : ", ";
        return "{" + tag + sep$1 + s$1 + "}";
        break;
    case /* TDict */4 :
        var a = Belt_MapString.toArray(x._1);
        return "<" + Belt_Array.joinWith(a, ", ", (function (param) {
                      return keyValuesToString(param[0], toString(param[1]));
                    })) + ">";
    case /* TVar */5 :
    case /* TOptionalVar */6 :
        return x._1;
    case /* TAny */7 :
        return "_";
    
  }
}

function debug(t) {
  return t._0;
}

function unify_child(a, b, debug) {
  if (Typescheme$AcutisLang.Child.equal(a, b)) {
    return ;
  }
  throw {
        RE_EXN_ID: Debug$AcutisLang.Exit,
        _1: Debug$AcutisLang.childTypeMismatch(debug, a, b, Typescheme$AcutisLang.Child.toString),
        Error: new Error()
      };
}

function make$1(root) {
  return {
          global: {
            contents: undefined
          },
          scope: undefined,
          children: {
            contents: undefined
          },
          root: root
        };
}

function get(scope, $$global, k) {
  var x = Belt_MapString.get(scope, k);
  if (x !== undefined) {
    return x;
  } else {
    return Belt_MapString.get($$global.contents, k);
  }
}

function update(param) {
  var scope = param.scope;
  var $$global = param.global;
  return function (k, v, debug) {
    var v$p = get(scope, $$global, k);
    if (v$p !== undefined) {
      return unify(v, v$p, /* Construct_var */2, debug);
    } else {
      $$global.contents = Belt_MapString.set($$global.contents, k, v);
      return ;
    }
  };
}

function updateChild(param, param$1, debug) {
  var v = param$1[1];
  var children = param.children;
  if (param.root === "Root") {
    throw {
          RE_EXN_ID: Debug$AcutisLang.Exit,
          _1: Debug$AcutisLang.childNotAllowedInRoot(debug),
          Error: new Error()
        };
  }
  children.contents = Belt_MapString.updateU(children.contents, param$1[0], (function (v$p) {
          if (v$p !== undefined) {
            unify_child(v, Caml_option.valFromOption(v$p), debug);
            return v$p;
          } else {
            return Caml_option.some(v);
          }
        }));
  
}

function addScope(ctx, bindings_all) {
  var bindings_all$1 = Belt_MutableQueue.mapU(bindings_all, (function (q) {
          return Belt_MutableQueue.reduceU(q, undefined, (function (newscope, param) {
                        var dbg = param[2];
                        var k = param[0];
                        if (Belt_MapString.has(newscope, k)) {
                          throw {
                                RE_EXN_ID: Debug$AcutisLang.Exit,
                                _1: Debug$AcutisLang.nameBoundMultipleTimes(dbg, k),
                                Error: new Error()
                              };
                        }
                        return Belt_MapString.set(newscope, k, [
                                    param[1],
                                    dbg
                                  ]);
                      }));
        }));
  var hd = Belt_MutableQueue.pop(bindings_all$1);
  if (hd === undefined) {
    return ctx;
  }
  var newscope = Belt_MutableQueue.reduceU(bindings_all$1, Caml_option.valFromOption(hd), (function (acc, m) {
          return Belt_MapString.mergeU(acc, m, (function (k, a, b) {
                        if (a !== undefined) {
                          if (b !== undefined) {
                            unify(a[0], b[0], /* Construct_literal */1, b[1]);
                            return a;
                          }
                          throw {
                                RE_EXN_ID: Debug$AcutisLang.Exit,
                                _1: Debug$AcutisLang.variableMissingInPattern(a[1], k),
                                Error: new Error()
                              };
                        }
                        if (b === undefined) {
                          return ;
                        }
                        throw {
                              RE_EXN_ID: Debug$AcutisLang.Exit,
                              _1: Debug$AcutisLang.variableMissingInPattern(b[1], k),
                              Error: new Error()
                            };
                      }));
        }));
  var scope = Belt_MapString.mergeU(ctx.scope, newscope, (function (param, a, b) {
          if (a !== undefined) {
            if (b !== undefined) {
              return b[0];
            } else {
              return a;
            }
          } else if (b !== undefined) {
            return b[0];
          } else {
            return ;
          }
        }));
  return {
          global: ctx.global,
          scope: scope,
          children: ctx.children,
          root: ctx.root
        };
}

function unifyMatchCases(bindingArray, tys, ctx) {
  if (NonEmpty$AcutisLang.size(bindingArray) === NonEmpty$AcutisLang.size(tys)) {
    return NonEmpty$AcutisLang.map(NonEmpty$AcutisLang.zip(bindingArray, tys), (function (param) {
                  return make(param[0], param[1], update(ctx), /* Construct_literal */1);
                }));
  }
  var debug = Parser$AcutisLang.Pattern.debug(NonEmpty$AcutisLang.hd(bindingArray));
  throw {
        RE_EXN_ID: Debug$AcutisLang.Exit,
        _1: Debug$AcutisLang.patternNumberMismatch(debug),
        Error: new Error()
      };
}

function unifyEchoes(nullables, $$default, ctx) {
  var _i = 0;
  while(true) {
    var i = _i;
    var match = Belt_Array.get(nullables, i);
    if (match !== undefined) {
      switch (match.TAG | 0) {
        case /* EBinding */0 :
            update(ctx)(match._1, Typescheme$AcutisLang.nullable(Typescheme$AcutisLang.echo(undefined)), match._0);
            _i = i + 1 | 0;
            continue ;
        case /* EChild */1 :
            updateChild(ctx, Typescheme$AcutisLang.Child.nullable(match._1), match._0);
            _i = i + 1 | 0;
            continue ;
        case /* EString */2 :
            throw {
                  RE_EXN_ID: Debug$AcutisLang.Exit,
                  _1: Debug$AcutisLang.nonNullableEchoLiteral(match._0),
                  Error: new Error()
                };
        
      }
    } else {
      switch ($$default.TAG | 0) {
        case /* EBinding */0 :
            return update(ctx)($$default._1, Typescheme$AcutisLang.echo(undefined), $$default._0);
        case /* EChild */1 :
            return updateChild(ctx, Typescheme$AcutisLang.Child.child($$default._1), $$default._0);
        case /* EString */2 :
            return ;
        
      }
    }
  };
}

function getTypes(x) {
  if (x.TAG !== /* Acutis */0) {
    return [
            x._1,
            x._2
          ];
  }
  var match = x._1;
  return [
          match.prop_types,
          match.child_types
        ];
}

function addDefaultWildcardToCases(cases) {
  return NonEmpty$AcutisLang.map(cases, (function ($$case) {
                return {
                        patterns: NonEmpty$AcutisLang.map($$case.patterns, (function (pattern) {
                                var match = NonEmpty$AcutisLang.toArray(pattern);
                                if (match.length !== 1) {
                                  return pattern;
                                }
                                var hd = match[0];
                                return NonEmpty$AcutisLang.two(hd, {
                                            TAG: /* UBinding */11,
                                            _0: Parser$AcutisLang.Pattern.debug(hd),
                                            _1: "_"
                                          });
                              })),
                        nodes: $$case.nodes
                      };
              }));
}

function unifyMap(ty, key, param, pattern, ctx, debug) {
  var match = NonEmpty$AcutisLang.toArray(param[0]);
  if (match.length !== 2) {
    throw {
          RE_EXN_ID: Debug$AcutisLang.Exit,
          _1: Debug$AcutisLang.mapPatternSizeMismatch(debug),
          Error: new Error()
        };
  }
  var hd = match[0];
  var tl = match[1];
  unify(key(), tl, /* Construct_literal */1, debug);
  var hd_ty = ty(hd);
  var pattern$1 = make(pattern, hd_ty, update(ctx), /* Construct_literal */1);
  return [
          pattern$1,
          param[1]
        ];
}

function makeCases(cases, ctx, g) {
  var tys = NonEmpty$AcutisLang.map(NonEmpty$AcutisLang.hd(NonEmpty$AcutisLang.hd(cases).patterns), (function (param) {
          return Typescheme$AcutisLang.unknown(undefined);
        }));
  var size = NonEmpty$AcutisLang.size(tys);
  var cases$1 = NonEmpty$AcutisLang.map(NonEmpty$AcutisLang.map(cases, (function (param) {
              var bindings_all = Belt_MutableQueue.make(undefined);
              var pats = NonEmpty$AcutisLang.map(param.patterns, (function (ps) {
                      var bindings = Belt_MutableQueue.make(undefined);
                      Belt_MutableQueue.add(bindings_all, bindings);
                      var f = function (k, v, debug) {
                        return Belt_MutableQueue.add(bindings, [
                                    k,
                                    v,
                                    debug
                                  ]);
                      };
                      if (NonEmpty$AcutisLang.size(ps) === size) {
                        return NonEmpty$AcutisLang.zipBy(ps, tys, (function (p, ty) {
                                      return make(p, ty, f, /* Destructure_expand */0);
                                    }));
                      }
                      var debug = Parser$AcutisLang.Pattern.debug(NonEmpty$AcutisLang.hd(ps));
                      throw {
                            RE_EXN_ID: Debug$AcutisLang.Exit,
                            _1: Debug$AcutisLang.patternNumberMismatch(debug),
                            Error: new Error()
                          };
                    }));
              var ctx$1 = addScope(ctx, bindings_all);
              return [
                      pats,
                      param.nodes,
                      ctx$1
                    ];
            })), (function (param) {
          return {
                  pats: param[0],
                  nodes: makeNodes(param[1], param[2], g)
                };
        }));
  return [
          tys,
          cases$1
        ];
}

function makeNodes(nodes, ctx, g) {
  return Belt_Array.mapU(nodes, (function (node) {
                switch (node.TAG | 0) {
                  case /* UText */0 :
                      return {
                              TAG: /* TText */0,
                              _0: node._0,
                              _1: node._1
                            };
                  case /* UEcho */1 :
                      var $$default = node._2;
                      var nullables = node._1;
                      unifyEchoes(nullables, $$default, ctx);
                      return {
                              TAG: /* TEcho */1,
                              _0: node._0,
                              _1: nullables,
                              _2: $$default
                            };
                  case /* UMatch */2 :
                      var match = makeCases(node._2, ctx, g);
                      var patterns = unifyMatchCases(node._1, match[0], ctx);
                      return {
                              TAG: /* TMatch */2,
                              _0: node._0,
                              _1: patterns,
                              _2: match[1]
                            };
                  case /* UMapList */3 :
                      var debug = node._0;
                      var ty = Typescheme$AcutisLang.list;
                      var key = function () {
                        return Typescheme$AcutisLang.$$int(undefined);
                      };
                      var cases = makeCases(addDefaultWildcardToCases(node._2), ctx, g);
                      var match$1 = unifyMap(ty, key, cases, node._1, ctx, debug);
                      return {
                              TAG: /* TMapList */3,
                              _0: debug,
                              _1: match$1[0],
                              _2: match$1[1]
                            };
                  case /* UMapDict */4 :
                      var debug$1 = node._0;
                      var ty$1 = Typescheme$AcutisLang.dict;
                      var key$1 = function () {
                        return Typescheme$AcutisLang.string(undefined);
                      };
                      var cases$1 = makeCases(addDefaultWildcardToCases(node._2), ctx, g);
                      var match$2 = unifyMap(ty$1, key$1, cases$1, node._1, ctx, debug$1);
                      return {
                              TAG: /* TMapDict */4,
                              _0: debug$1,
                              _1: match$2[0],
                              _2: match$2[1]
                            };
                  case /* UComponent */5 :
                      var comp = node._1;
                      var debug$2 = node._0;
                      var match$3 = getTypes(Utils$AcutisLang.Dagmap.get(g, comp, debug$2));
                      var propTypes = Typescheme$AcutisLang.internal_copy_record(match$3[0]);
                      var props = make_record(Belt_MapString.mergeU(node._2, propTypes, (function (param, prop, ty) {
                                  if (prop !== undefined) {
                                    return prop;
                                  }
                                  if (ty === undefined) {
                                    return prop;
                                  }
                                  var match = ty.contents;
                                  if (typeof match === "number" || match.TAG !== /* Nullable */0) {
                                    return prop;
                                  } else {
                                    return {
                                            TAG: /* UNullable */0,
                                            _0: debug$2,
                                            _1: undefined
                                          };
                                  }
                                })), propTypes, update(ctx), debug$2, /* Construct_literal */1);
                      var children = Belt_MapString.mergeU(node._3, match$3[1], (function (k, c, ty) {
                              if (c !== undefined) {
                                if (ty !== undefined) {
                                  if (c.TAG !== /* UChildName */0) {
                                    return {
                                            TAG: /* TChildBlock */1,
                                            _0: makeNodes(c._1, ctx, g)
                                          };
                                  }
                                  var c$1 = c._1;
                                  updateChild(ctx, [
                                        c$1,
                                        Caml_option.valFromOption(ty)
                                      ], c._0);
                                  return {
                                          TAG: /* TChildName */0,
                                          _0: c$1
                                        };
                                }
                                throw {
                                      RE_EXN_ID: Debug$AcutisLang.Exit,
                                      _1: Debug$AcutisLang.extraChild(debug$2, comp, k),
                                      Error: new Error()
                                    };
                              }
                              if (ty === undefined) {
                                return ;
                              }
                              if (Typescheme$AcutisLang.Child.is_nullable(Caml_option.valFromOption(ty))) {
                                return ;
                              }
                              throw {
                                    RE_EXN_ID: Debug$AcutisLang.Exit,
                                    _1: Debug$AcutisLang.missingChild(debug$2, comp, k),
                                    Error: new Error()
                                  };
                            }));
                      return {
                              TAG: /* TComponent */5,
                              _0: debug$2,
                              _1: comp,
                              _2: props,
                              _3: children
                            };
                  
                }
              }));
}

function make$2(ast, g, root) {
  var ctx = make$1(root);
  var nodes = makeNodes(ast, ctx, g);
  return {
          nodes: nodes,
          prop_types: ctx.global.contents,
          child_types: ctx.children.contents
        };
}

function makeSrc(g, x) {
  if (x.TAG === /* Acutis */0) {
    return Source$AcutisLang.src(x._0, make$2(x._1, g, "Component"));
  } else {
    return Source$AcutisLang.fnU(x._0, x._1, x._2, x._3);
  }
}

function makeComponents(a) {
  return Utils$AcutisLang.Dagmap.linkAll(Utils$AcutisLang.Dagmap.make(a, makeSrc));
}

function make$3(ast, components) {
  return make$2(ast, Utils$AcutisLang.Dagmap.prelinked(components), "Root");
}

var Pattern = {
  toString: toString,
  debug: debug
};

exports.Pattern = Pattern;
exports.makeComponents = makeComponents;
exports.make = make$3;
/* Typescheme-AcutisLang Not a pure module */

// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("@rescript/std/lib/js/curry.js");
var Js_json = require("@rescript/std/lib/js/js_json.js");
var Belt_List = require("@rescript/std/lib/js/belt_List.js");
var Belt_Array = require("@rescript/std/lib/js/belt_Array.js");
var Caml_option = require("@rescript/std/lib/js/caml_option.js");
var Caml_exceptions = require("@rescript/std/lib/js/caml_exceptions.js");
var NonEmpty$AcutisLang = require("./NonEmpty.js");

function make(name, $$char) {
  return {
          name: name,
          char: $$char
        };
}

function $$char(t) {
  return t.char;
}

var Exit = /* @__PURE__ */Caml_exceptions.create("Debug-AcutisLang.Exit");

function illegalIdentifier(t, identifier) {
  return {
          message: "\"" + identifier + "\" is an illegal identifier name.",
          kind: "Syntax",
          location: t,
          stack: [],
          exn: undefined
        };
}

function invalidCharacter(t, character) {
  return {
          message: "Invalid character: \"" + character + "\".",
          kind: "Syntax",
          location: t,
          stack: [],
          exn: undefined
        };
}

function unexpectedCharacter(t, character, expected) {
  return {
          message: "Unexpected character: \"" + character + "\". Expected: \"" + expected + "\".",
          kind: "Syntax",
          location: t,
          stack: [],
          exn: undefined
        };
}

function unexpectedEof(t) {
  return {
          message: "Unexpected end of file.",
          kind: "Syntax",
          location: t,
          stack: [],
          exn: undefined
        };
}

function unknownEscapeSequence(t, $$char) {
  return {
          message: "Unknown escape sequence: " + $$char + ".",
          kind: "Syntax",
          location: t,
          stack: [],
          exn: undefined
        };
}

function unterminatedComment(t) {
  return {
          message: "Unterminated comment.",
          kind: "Syntax",
          location: t,
          stack: [],
          exn: undefined
        };
}

function unterminatedString(t) {
  return {
          message: "Unterminated string.",
          kind: "Syntax",
          location: t,
          stack: [],
          exn: undefined
        };
}

function unexpectedToken(token, M) {
  return {
          message: "Unexpected token: \"" + Curry._1(M.toString, token) + "\".",
          kind: "Parse",
          location: Curry._1(M.debug, token),
          stack: [],
          exn: undefined
        };
}

function tooManyFields(token, M) {
  return {
          message: "This field was already used: \"" + Curry._1(M.toString, token) + "\".",
          kind: "Parse",
          location: Curry._1(M.debug, token),
          stack: [],
          exn: undefined
        };
}

function tooManyTags(t) {
  return {
          message: "This union has too many tagged fields.",
          kind: "Parse",
          location: t,
          stack: [],
          exn: undefined
        };
}

function badUnionTag(t) {
  return {
          message: "Only integer, string, and boolean literals may be used as union tags.",
          kind: "Type",
          location: t,
          stack: [],
          exn: undefined
        };
}

function cantNarrowType(t, a, b, f) {
  return {
          message: "These types have no subset:\n" + Curry._1(f, a) + "\n" + Curry._1(f, b),
          kind: "Type",
          location: t,
          stack: [],
          exn: undefined
        };
}

function childNotAllowedInRoot(t) {
  return {
          message: "Children are not allowed in root templates, only in components.",
          kind: "Type",
          location: t,
          stack: [],
          exn: undefined
        };
}

function childTypeMismatch(t, a, b, f) {
  return {
          message: "This pattern is type " + Curry._1(f, b) + "} but expected type " + Curry._1(f, a) + ".",
          kind: "Type",
          location: t,
          stack: [],
          exn: undefined
        };
}

function extraChild(t, comp, child) {
  return {
          message: "This call of component \"" + comp + "\" includes unexpected child \"" + child + ".\"",
          kind: "Type",
          location: t,
          stack: [],
          exn: undefined
        };
}

function mapPatternSizeMismatch(t) {
  return {
          message: "Map blocks can only have two patterns per \"with\" clause: the item and the index.",
          kind: "Type",
          location: t,
          stack: [],
          exn: undefined
        };
}

function missingChild(t, comp, child) {
  return {
          message: "This call of component \"" + comp + "\" is missing child \"" + child + ".\"",
          kind: "Type",
          location: t,
          stack: [],
          exn: undefined
        };
}

function missingRecordField(t, field, ty, f) {
  return {
          message: "This record is missing field \"" + field + "\" of type " + Curry._1(f, ty) + ".",
          kind: "Type",
          location: t,
          stack: [],
          exn: undefined
        };
}

function nameBoundMultipleTimes(t, binding) {
  return {
          message: "\"" + binding + "\" is bound multiple times in this pattern.",
          kind: "Type",
          location: t,
          stack: [],
          exn: undefined
        };
}

function nonNullableEchoLiteral(t) {
  return {
          message: "String, int, or float literals are not nullable and therefore allowed before a ? operator.",
          kind: "Type",
          location: t,
          stack: [],
          exn: undefined
        };
}

function patternNumberMismatch(t) {
  return {
          message: "The number of patterns here is incorrect.",
          kind: "Type",
          location: t,
          stack: [],
          exn: undefined
        };
}

function tupleSizeMismatch(t, a, b) {
  return {
          message: "This is a " + String(a) + "-tuple but expected a " + String(b) + "-tuple.",
          kind: "Type",
          location: t,
          stack: [],
          exn: undefined
        };
}

function typeMismatch(t, a, b, f) {
  return {
          message: "This pattern is type " + Curry._1(f, b) + " but expected type " + Curry._1(f, a) + ".",
          kind: "Type",
          location: t,
          stack: [],
          exn: undefined
        };
}

function underscoreInConstruct(t) {
  return {
          message: "\"_\" isn't a valid name.",
          kind: "Type",
          location: t,
          stack: [],
          exn: undefined
        };
}

function variableMissingInPattern(t, v) {
  return {
          message: "Binding \"" + v + "\" must occur in both instances of this pattern.",
          kind: "Type",
          location: t,
          stack: [],
          exn: undefined
        };
}

function partialMatch(t, pat, f) {
  return {
          message: "This pattern-matching is not exhaustive.\nHere is an example of a case that is not matched:\n" + Curry._1(f, pat),
          kind: "Matching",
          location: t,
          stack: [],
          exn: undefined
        };
}

function unusedCase(pats, M) {
  var hd = NonEmpty$AcutisLang.hd(pats);
  var t = Curry._1(M.debug, hd);
  var pat = Belt_Array.joinWith(NonEmpty$AcutisLang.toArray(pats), ", ", M.toString);
  return {
          message: "This match case is unused:\n" + pat,
          kind: "Matching",
          location: t,
          stack: [],
          exn: undefined
        };
}

function duplicateCompName(name) {
  return {
          message: "The template component name \"" + name + "\" was used twice. Every component needs a unique name.",
          kind: "Compile",
          location: undefined,
          stack: [],
          exn: undefined
        };
}

function uncaughtCompileError(e, name) {
  return {
          message: "An exception was thrown while compiling template \"" + name + ".\" This is probably due to malformed input.",
          kind: "Compile",
          location: undefined,
          stack: [],
          exn: Caml_option.some(e)
        };
}

function customError(message) {
  return {
          message: "A template function raised this error:\n" + message,
          kind: "Render",
          location: undefined,
          stack: [],
          exn: undefined
        };
}

function json(j) {
  var match = Js_json.classify(j);
  if (typeof match === "number") {
    switch (match) {
      case /* JSONFalse */0 :
          return "JSON false";
      case /* JSONTrue */1 :
          return "JSON true";
      case /* JSONNull */2 :
          return "JSON null";
      
    }
  } else {
    switch (match.TAG | 0) {
      case /* JSONString */0 :
          return "JSON string";
      case /* JSONNumber */1 :
          return "JSON number";
      case /* JSONObject */2 :
          return "JSON object";
      case /* JSONArray */3 :
          return "JSON array";
      
    }
  }
}

function decodeError(stack, a, b, f) {
  var a$1 = Curry._1(f, a);
  var b$1 = json(b);
  return {
          message: "This input is type \"" + b$1 + "\", which does not match the template's required type, " + a$1 + ".",
          kind: "Render",
          location: undefined,
          stack: Belt_Array.reverse(Belt_List.toArray(stack)),
          exn: undefined
        };
}

function decodeErrorMissingKey(stack, k) {
  return {
          message: "Input is missing JSON object key \"" + k + "\" which is required.",
          kind: "Render",
          location: undefined,
          stack: Belt_Array.reverse(Belt_List.toArray(stack)),
          exn: undefined
        };
}

function uncaughtComponentError(t, name, stack, e) {
  return {
          message: "Template component \"" + name + "\" threw an exception.",
          kind: "Render",
          location: t,
          stack: Belt_List.toArray(stack),
          exn: Caml_option.some(e)
        };
}

function cyclicDependency(t, stack) {
  var stack$1 = Belt_Array.joinWith(Belt_Array.reverse(Belt_List.toArray(stack)), " -> ", (function (s) {
          return s;
        }));
  return {
          message: "Cyclic dependency detected:\n" + stack$1,
          kind: "Compile",
          location: t,
          stack: [],
          exn: undefined
        };
}

function missingComponent(t, a) {
  var s = t.name;
  var name$p = s === "" ? "<root>" : s;
  return {
          message: "Template component \"" + a + "\" is missing, which is required by \"" + name$p + ".\"",
          kind: "Compile",
          location: t,
          stack: [],
          exn: undefined
        };
}

var empty = {
  name: "",
  char: 0
};

exports.empty = empty;
exports.make = make;
exports.$$char = $$char;
exports.Exit = Exit;
exports.illegalIdentifier = illegalIdentifier;
exports.invalidCharacter = invalidCharacter;
exports.unexpectedCharacter = unexpectedCharacter;
exports.unexpectedEof = unexpectedEof;
exports.unknownEscapeSequence = unknownEscapeSequence;
exports.unterminatedComment = unterminatedComment;
exports.unterminatedString = unterminatedString;
exports.unexpectedToken = unexpectedToken;
exports.tooManyFields = tooManyFields;
exports.tooManyTags = tooManyTags;
exports.badUnionTag = badUnionTag;
exports.cantNarrowType = cantNarrowType;
exports.childNotAllowedInRoot = childNotAllowedInRoot;
exports.childTypeMismatch = childTypeMismatch;
exports.extraChild = extraChild;
exports.mapPatternSizeMismatch = mapPatternSizeMismatch;
exports.missingChild = missingChild;
exports.missingRecordField = missingRecordField;
exports.nameBoundMultipleTimes = nameBoundMultipleTimes;
exports.nonNullableEchoLiteral = nonNullableEchoLiteral;
exports.patternNumberMismatch = patternNumberMismatch;
exports.tupleSizeMismatch = tupleSizeMismatch;
exports.typeMismatch = typeMismatch;
exports.underscoreInConstruct = underscoreInConstruct;
exports.variableMissingInPattern = variableMissingInPattern;
exports.partialMatch = partialMatch;
exports.unusedCase = unusedCase;
exports.duplicateCompName = duplicateCompName;
exports.uncaughtCompileError = uncaughtCompileError;
exports.customError = customError;
exports.decodeError = decodeError;
exports.decodeErrorMissingKey = decodeErrorMissingKey;
exports.uncaughtComponentError = uncaughtComponentError;
exports.cyclicDependency = cyclicDependency;
exports.missingComponent = missingComponent;
/* No side effect */

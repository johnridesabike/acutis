// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Belt_List = require("@rescript/std/lib/js/belt_List.js");
var Belt_Array = require("@rescript/std/lib/js/belt_Array.js");
var Caml_option = require("@rescript/std/lib/js/caml_option.js");
var Debug$AcutisLang = require("./Debug.js");
var Belt_HashMapString = require("@rescript/std/lib/js/belt_HashMapString.js");

function $$escape(c) {
  switch (c) {
    case "\"" :
        return "&quot;";
    case "&" :
        return "&amp;";
    case "'" :
        return "&apos;";
    case "/" :
        return "&#x2F;";
    case "<" :
        return "&lt;";
    case "=" :
        return "&#x3D;";
    case ">" :
        return "&gt;";
    case "`" :
        return "&#x60;";
    default:
      return c;
  }
}

function $$escape$1(esc, str) {
  if (esc) {
    var _pos = 0;
    var _result = "";
    while(true) {
      var result = _result;
      var pos = _pos;
      var c = str.charAt(pos);
      if (c === "") {
        return result;
      }
      _result = result + $$escape(c);
      _pos = pos + 1 | 0;
      continue ;
    };
  } else {
    return str;
  }
}

function string_equal(a, b) {
  return a === b;
}

function id(param, a) {
  return a;
}

function make(m, f) {
  return {
          queue: Belt_HashMapString.keysToArray(m),
          notlinked: Belt_HashMapString.copy(m),
          linked: Belt_HashMapString.make(Belt_HashMapString.size(m)),
          stack: /* [] */0,
          f: f
        };
}

function prelinked(m) {
  return {
          queue: [],
          notlinked: Belt_HashMapString.make(0),
          linked: m,
          stack: /* [] */0,
          f: id
        };
}

function get(g, key, debug) {
  var x = Belt_HashMapString.get(g.linked, key);
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  }
  var stack_1 = g.stack;
  var stack = {
    hd: key,
    tl: stack_1
  };
  var x$1 = Belt_HashMapString.get(g.notlinked, key);
  if (x$1 !== undefined) {
    Belt_HashMapString.remove(g.notlinked, key);
    var x$2 = g.f({
          queue: g.queue,
          notlinked: g.notlinked,
          linked: g.linked,
          stack: stack,
          f: g.f
        }, Caml_option.valFromOption(x$1));
    Belt_HashMapString.set(g.linked, key, x$2);
    return x$2;
  }
  if (Belt_List.hasU(g.stack, key, string_equal)) {
    throw {
          RE_EXN_ID: Debug$AcutisLang.Exit,
          _1: Debug$AcutisLang.cyclicDependency(debug, stack),
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: Debug$AcutisLang.Exit,
        _1: Debug$AcutisLang.missingComponent(debug, key),
        Error: new Error()
      };
}

function linkAll(g) {
  Belt_Array.forEachU(g.queue, (function (key) {
          var v = Belt_HashMapString.get(g.notlinked, key);
          if (v === undefined) {
            return ;
          }
          Belt_HashMapString.remove(g.notlinked, key);
          var v$1 = g.f({
                queue: g.queue,
                notlinked: g.notlinked,
                linked: g.linked,
                stack: {
                  hd: key,
                  tl: g.stack
                },
                f: g.f
              }, Caml_option.valFromOption(v));
          return Belt_HashMapString.set(g.linked, key, v$1);
        }));
  return g.linked;
}

var Dagmap = {
  make: make,
  prelinked: prelinked,
  get: get,
  linkAll: linkAll
};

exports.$$escape = $$escape$1;
exports.Dagmap = Dagmap;
/* No side effect */

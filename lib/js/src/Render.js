// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("@rescript/std/lib/js/curry.js");
var Js_exn = require("@rescript/std/lib/js/js_exn.js");
var Belt_Array = require("@rescript/std/lib/js/belt_Array.js");
var Belt_MapInt = require("@rescript/std/lib/js/belt_MapInt.js");
var Belt_SetInt = require("@rescript/std/lib/js/belt_SetInt.js");
var Caml_option = require("@rescript/std/lib/js/caml_option.js");
var Belt_MapString = require("@rescript/std/lib/js/belt_MapString.js");
var Data$AcutisLang = require("./Data.js");
var Debug$AcutisLang = require("./Debug.js");
var Utils$AcutisLang = require("./Utils.js");
var Belt_MutableQueue = require("@rescript/std/lib/js/belt_MutableQueue.js");
var Result$AcutisLang = require("./Result.js");
var Caml_js_exceptions = require("@rescript/std/lib/js/caml_js_exceptions.js");
var Matching$AcutisLang = require("./Matching.js");
var NonEmpty$AcutisLang = require("./NonEmpty.js");

function testCase(wildcard, val, _case) {
  while(true) {
    var $$case = _case;
    if (Data$AcutisLang.Const.equal(val, $$case.val)) {
      return $$case.ifMatch;
    }
    var $$case$1 = $$case.nextCase;
    if ($$case$1 === undefined) {
      return wildcard;
    }
    _case = $$case$1;
    continue ;
  };
}

function bindNames(map, ids, val) {
  return Belt_SetInt.reduceU(ids, map, (function (map, id) {
                return Belt_MapInt.set(map, id, val);
              }));
}

var arrayGet = Belt_Array.get;

var mapStringGet = Belt_MapString.get;

var nonemptyGet = NonEmpty$AcutisLang.get;

function make_match(_tree, args, get, _vars) {
  while(true) {
    var vars = _vars;
    var tree = _tree;
    switch (tree.TAG | 0) {
      case /* Switch */0 :
          var val = get(args, tree.key);
          if (val === undefined) {
            return ;
          }
          var val$1 = Caml_option.valFromOption(val);
          var vars$1 = bindNames(vars, tree.ids, val$1);
          var val$2 = Data$AcutisLang.constantExn(val$1);
          var tree$1 = testCase(tree.wildcard, val$2, tree.cases);
          if (tree$1 === undefined) {
            return ;
          }
          _vars = vars$1;
          _tree = tree$1;
          continue ;
      case /* Nest */1 :
          var wildcard = tree.wildcard;
          var child = tree.child;
          var val$3 = get(args, tree.key);
          if (val$3 === undefined) {
            return ;
          }
          var val$4 = Caml_option.valFromOption(val$3);
          var vars$2 = bindNames(vars, tree.ids, val$4);
          var result;
          if (child.TAG === /* IntKeys */0) {
            var tuple = Data$AcutisLang.tupleExn(val$4);
            result = make_match(child._0, tuple, arrayGet, vars$2);
          } else {
            var dict = Data$AcutisLang.dictExn(val$4);
            result = make_match(child._0, dict, mapStringGet, vars$2);
          }
          if (result !== undefined) {
            _vars = result[0];
            _tree = result[1];
            continue ;
          }
          if (wildcard === undefined) {
            return ;
          }
          _vars = vars$2;
          _tree = wildcard;
          continue ;
      case /* Construct */2 :
          var val$5 = get(args, tree.key);
          if (val$5 === undefined) {
            return ;
          }
          var val$6 = Caml_option.valFromOption(val$5);
          var vars$3 = bindNames(vars, tree.ids, val$6);
          var child$1 = Data$AcutisLang.isNull(val$6) ? tree.nil : tree.cons;
          if (child$1 === undefined) {
            return ;
          }
          _vars = vars$3;
          _tree = child$1;
          continue ;
      case /* Wildcard */3 :
          var val$7 = get(args, tree.key);
          if (val$7 === undefined) {
            return ;
          }
          var vars$4 = bindNames(vars, tree.ids, Caml_option.valFromOption(val$7));
          _vars = vars$4;
          _tree = tree.child;
          continue ;
      case /* End */4 :
          return [
                  vars,
                  tree._0
                ];
      
    }
  };
}

function make_match$1(param, args) {
  var match = make_match(param.tree, args, nonemptyGet, undefined);
  if (match === undefined) {
    return ;
  }
  var match$1 = match[1];
  var vars = match[0];
  var bindings = Belt_MapString.mapU(match$1.names, (function (id) {
          return Belt_MapInt.getExn(vars, id);
        }));
  return [
          bindings,
          Matching$AcutisLang.Exit.get(param.exits, match$1.exit)
        ];
}

function echoNullable(x, props, children, $$return) {
  switch (x.TAG | 0) {
    case /* OEBinding */0 :
        var x$1 = Belt_MapString.get(props, x._0);
        if (x$1 !== undefined) {
          var x$2 = Data$AcutisLang.nullableExn(Caml_option.valFromOption(x$1));
          if (x$2 !== undefined) {
            return Caml_option.some($$return(Utils$AcutisLang.$$escape(x._1, Data$AcutisLang.toString(Caml_option.valFromOption(x$2)))));
          } else {
            return ;
          }
        }
        throw {
              RE_EXN_ID: "Assert_failure",
              _1: [
                "Render.res",
                129,
                14
              ],
              Error: new Error()
            };
    case /* OEChild */1 :
        return Belt_MapString.get(children, x._0);
    case /* OEString */2 :
        return Caml_option.some($$return(x._0));
    
  }
}

function echo(nullables, $$default, props, children, $$return) {
  var _i = 0;
  while(true) {
    var i = _i;
    var x = Belt_Array.get(nullables, i);
    if (x === undefined) {
      switch ($$default.TAG | 0) {
        case /* OEBinding */0 :
            var x$1 = Belt_MapString.get(props, $$default._0);
            if (x$1 !== undefined) {
              return $$return(Utils$AcutisLang.$$escape($$default._1, Data$AcutisLang.toString(Caml_option.valFromOption(x$1))));
            }
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "Render.res",
                    110,
                    14
                  ],
                  Error: new Error()
                };
        case /* OEChild */1 :
            var x$2 = Belt_MapString.get(children, $$default._0);
            if (x$2 !== undefined) {
              return Caml_option.valFromOption(x$2);
            }
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "Render.res",
                    114,
                    14
                  ],
                  Error: new Error()
                };
        case /* OEString */2 :
            return $$return($$default._0);
        
      }
    }
    var x$3 = echoNullable(x, props, children, $$return);
    if (x$3 !== undefined) {
      return Caml_option.valFromOption(x$3);
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function mapMerge(d1, d2) {
  return Belt_MapString.mergeU(d1, d2, (function (param, v1, v2) {
                if (v1 !== undefined) {
                  if (v2 !== undefined) {
                    return v2;
                  } else {
                    return v1;
                  }
                } else if (v2 !== undefined) {
                  return v2;
                } else {
                  return ;
                }
              }));
}

function mapToDict(m) {
  var d = {};
  Belt_MapString.forEachU(m, (function (k, v) {
          d[k] = v;
          
        }));
  return d;
}

function make(nodes, props, children, env, stack) {
  var queue = Belt_MutableQueue.make(undefined);
  Belt_Array.forEachU(nodes, (function (node) {
          switch (node.TAG | 0) {
            case /* OText */0 :
                return Belt_MutableQueue.add(queue, env.$$return(node._0));
            case /* OEcho */1 :
                return Belt_MutableQueue.add(queue, echo(node._0, node._1, props, children, env.$$return));
            case /* OMatch */2 :
                var args = NonEmpty$AcutisLang.map(node._0, (function (x) {
                        return Data$AcutisLang.fromPattern(x, props);
                      }));
                var match = make_match$1(node._1, args);
                if (match !== undefined) {
                  var props$1 = mapMerge(props, match[0]);
                  var result = make(match[1], props$1, children, env, stack);
                  return Belt_MutableQueue.transfer(result, queue);
                }
                throw {
                      RE_EXN_ID: "Assert_failure",
                      _1: [
                        "Render.res",
                        181,
                        18
                      ],
                      Error: new Error()
                    };
            case /* OMapList */3 :
                var dectree = node._1;
                var l = Data$AcutisLang.fromPattern(node._0, props);
                return Data$AcutisLang.forEachListExn(l, (function (index, args) {
                              var match = make_match$1(dectree, NonEmpty$AcutisLang.two(args, index));
                              if (match !== undefined) {
                                var props$2 = mapMerge(props, match[0]);
                                var result = make(match[1], props$2, children, env, stack);
                                return Belt_MutableQueue.transfer(result, queue);
                              }
                              throw {
                                    RE_EXN_ID: "Assert_failure",
                                    _1: [
                                      "Render.res",
                                      191,
                                      20
                                    ],
                                    Error: new Error()
                                  };
                            }));
            case /* OMapDict */4 :
                var dectree$1 = node._1;
                var l$1 = Data$AcutisLang.fromPattern(node._0, props);
                return Data$AcutisLang.forEachDictExn(l$1, (function (index, args) {
                              var match = make_match$1(dectree$1, NonEmpty$AcutisLang.two(args, index));
                              if (match !== undefined) {
                                var props$2 = mapMerge(props, match[0]);
                                var result = make(match[1], props$2, children, env, stack);
                                return Belt_MutableQueue.transfer(result, queue);
                              }
                              throw {
                                    RE_EXN_ID: "Assert_failure",
                                    _1: [
                                      "Render.res",
                                      202,
                                      20
                                    ],
                                    Error: new Error()
                                  };
                            }));
            case /* OComponent */5 :
                var val = node._1;
                var debug = node._0;
                var compChildren = Belt_MapString.mapU(node._3, (function (child) {
                        if (child.TAG === /* OChildName */0) {
                          return Belt_MapString.getExn(children, child._0);
                        }
                        var result = make(child._0, props, children, env, stack);
                        return env.render(result);
                      }));
                var compProps = Belt_MapString.mapU(node._2, (function (data) {
                        return Data$AcutisLang.fromPattern(data, props);
                      }));
                var result$1;
                if (val.TAG === /* Acutis */0) {
                  result$1 = env.render(make(val._1, compProps, compChildren, env, {
                            hd: val._0,
                            tl: stack
                          }));
                } else {
                  var f = val._2;
                  var propTypes = val._1;
                  var name = val._0;
                  result$1 = env.try_((function () {
                          return f(env, Data$AcutisLang.toJson(compProps, propTypes), mapToDict(compChildren));
                        }), (function (e) {
                          return env.error_internal([Debug$AcutisLang.uncaughtComponentError(debug, name, stack, e)]);
                        }));
                }
                return Belt_MutableQueue.add(queue, result$1);
            
          }
        }));
  return queue;
}

function make$1(env, param, props) {
  try {
    var props$1 = Data$AcutisLang.make(props, param.prop_types);
    return env.render(make(param.nodes, props$1, undefined, env, {
                    hd: param.name,
                    tl: /* [] */0
                  }));
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    if (e.RE_EXN_ID === Debug$AcutisLang.Exit) {
      return env.error_internal([e._1]);
    }
    if (e.RE_EXN_ID === Js_exn.$$Error) {
      throw e._1;
    }
    throw e;
  }
}

function render(forEach, x) {
  var result = {
    contents: ""
  };
  var errors = Belt_MutableQueue.make(undefined);
  forEach(x, (function (x) {
          if (x.NAME === "ok") {
            result.contents = result.contents + x.VAL;
            return ;
          } else {
            return Belt_MutableQueue.transfer(Belt_MutableQueue.fromArray(x.VAL), errors);
          }
        }));
  if (Belt_MutableQueue.isEmpty(errors)) {
    return {
            NAME: "ok",
            VAL: result.contents
          };
  } else {
    return {
            NAME: "errors",
            VAL: Belt_MutableQueue.toArray(errors)
          };
  }
}

function $$return(s) {
  return {
          NAME: "ok",
          VAL: s
        };
}

function error(s) {
  return {
          NAME: "errors",
          VAL: [Debug$AcutisLang.customError(s)]
        };
}

function error_internal(x) {
  return {
          NAME: "errors",
          VAL: x
        };
}

function render$1(q) {
  return render(Belt_MutableQueue.forEachU, q);
}

function try_(f, $$catch) {
  try {
    return f();
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    return $$catch(e);
  }
}

var map = Result$AcutisLang.map;

var flatmap = Result$AcutisLang.flatMap;

var Sync = {
  $$return: $$return,
  return_: $$return,
  error: error,
  error_internal: error_internal,
  render: render$1,
  try_: try_,
  map: map,
  flatmap: flatmap
};

function sync(param, param$1) {
  return make$1(Sync, param, param$1);
}

function $$return$1(s) {
  return Promise.resolve({
              NAME: "ok",
              VAL: s
            });
}

function error$1(s) {
  return Promise.resolve({
              NAME: "errors",
              VAL: [Debug$AcutisLang.customError(s)]
            });
}

function error_internal$1(x) {
  return Promise.resolve({
              NAME: "errors",
              VAL: x
            });
}

function render_array(a) {
  return Promise.resolve(render(Belt_Array.forEachU, a));
}

function render$2(q) {
  return Promise.all(Belt_MutableQueue.toArray(q)).then(render_array);
}

function try_$1(f, $$catch) {
  return f().catch(function (e) {
              return $$catch(e);
            });
}

function map$1(child, f) {
  return child.then(function (child) {
              return Promise.resolve(Result$AcutisLang.map(child, f));
            });
}

function flatmap$1(child, f) {
  return child.then(function (child) {
              if (child.NAME === "ok") {
                return Curry._1(f, child.VAL);
              } else {
                return Promise.resolve(child);
              }
            });
}

var partial_arg = {
  $$return: $$return$1,
  return_: $$return$1,
  error: error$1,
  error_internal: error_internal$1,
  render: render$2,
  try_: try_$1,
  map: map$1,
  flatmap: flatmap$1
};

function async(param, param$1) {
  return make$1(partial_arg, param, param$1);
}

var Async = {
  $$return: $$return$1,
  return_: $$return$1,
  error: error$1,
  error_internal: error_internal$1,
  render: render$2,
  try_: try_$1,
  map: map$1,
  flatmap: flatmap$1
};

exports.make = make$1;
exports.Sync = Sync;
exports.sync = sync;
exports.Async = Async;
exports.async = async;
/* Data-AcutisLang Not a pure module */

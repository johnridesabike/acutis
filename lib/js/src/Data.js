// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml = require("@rescript/std/lib/js/caml.js");
var Js_dict = require("@rescript/std/lib/js/js_dict.js");
var Js_json = require("@rescript/std/lib/js/js_json.js");
var Js_types = require("@rescript/std/lib/js/js_types.js");
var Belt_Array = require("@rescript/std/lib/js/belt_Array.js");
var Belt_MapInt = require("@rescript/std/lib/js/belt_MapInt.js");
var Belt_SetInt = require("@rescript/std/lib/js/belt_SetInt.js");
var Caml_option = require("@rescript/std/lib/js/caml_option.js");
var Belt_MapString = require("@rescript/std/lib/js/belt_MapString.js");
var Belt_SetString = require("@rescript/std/lib/js/belt_SetString.js");
var Debug$AcutisLang = require("./Debug.js");
var Belt_MutableQueue = require("@rescript/std/lib/js/belt_MutableQueue.js");
var Typescheme$AcutisLang = require("./Typescheme.js");

function fromTPat(x) {
  switch (x.TAG | 0) {
    case /* TString */0 :
        return {
                TAG: /* PString */1,
                _0: x._0
              };
    case /* TInt */1 :
        return {
                TAG: /* PInt */0,
                _0: x._0
              };
    case /* TFloat */2 :
        return {
                TAG: /* PFloat */2,
                _0: x._0
              };
    
  }
}

function toTPat(x) {
  switch (x.TAG | 0) {
    case /* PInt */0 :
        return {
                TAG: /* TInt */1,
                _0: x._0
              };
    case /* PString */1 :
        return {
                TAG: /* TString */0,
                _0: x._0
              };
    case /* PFloat */2 :
        return {
                TAG: /* TFloat */2,
                _0: x._0
              };
    
  }
}

function equal(a, b) {
  switch (a.TAG | 0) {
    case /* PInt */0 :
        switch (b.TAG | 0) {
          case /* PInt */0 :
              return a._0 === b._0;
          case /* PString */1 :
          case /* PFloat */2 :
              break;
          
        }
        break;
    case /* PString */1 :
        switch (b.TAG | 0) {
          case /* PString */1 :
              return a._0 === b._0;
          case /* PInt */0 :
          case /* PFloat */2 :
              break;
          
        }
        break;
    case /* PFloat */2 :
        switch (b.TAG | 0) {
          case /* PInt */0 :
          case /* PString */1 :
              break;
          case /* PFloat */2 :
              return a._0 === b._0;
          
        }
        break;
    
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Data.res",
          47,
          11
        ],
        Error: new Error()
      };
}

function compare(a, b) {
  switch (a.TAG | 0) {
    case /* PInt */0 :
        switch (b.TAG | 0) {
          case /* PInt */0 :
              return Caml.caml_int_compare(a._0, b._0);
          case /* PString */1 :
          case /* PFloat */2 :
              break;
          
        }
        break;
    case /* PString */1 :
        switch (b.TAG | 0) {
          case /* PString */1 :
              return Caml.caml_string_compare(a._0, b._0);
          case /* PInt */0 :
          case /* PFloat */2 :
              break;
          
        }
        break;
    case /* PFloat */2 :
        switch (b.TAG | 0) {
          case /* PInt */0 :
          case /* PString */1 :
              break;
          case /* PFloat */2 :
              return Caml.caml_float_compare(a._0, b._0);
          
        }
        break;
    
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Data.res",
          55,
          11
        ],
        Error: new Error()
      };
}

function toString(t, extra) {
  switch (t.TAG | 0) {
    case /* PInt */0 :
        var i = t._0;
        if (extra) {
          if (i !== 0) {
            return "true";
          } else {
            return "false";
          }
        } else {
          return String(i);
        }
    case /* PString */1 :
        return t._0;
    case /* PFloat */2 :
        return String(t._0);
    
  }
}

var Const = {
  fromTPat: fromTPat,
  toTPat: toTPat,
  equal: equal,
  compare: compare,
  toString: toString
};

function string(stack, j, ty, cases) {
  var s = Js_json.decodeString(j);
  if (s !== undefined) {
    if (cases === undefined) {
      return {
              TAG: /* PConst */3,
              _0: {
                TAG: /* PString */1,
                _0: s
              },
              _1: /* Extra_none */0
            };
    }
    if (Belt_SetString.has(Caml_option.valFromOption(cases), s)) {
      return {
              TAG: /* PConst */3,
              _0: {
                TAG: /* PString */1,
                _0: s
              },
              _1: /* Extra_none */0
            };
    }
    throw {
          RE_EXN_ID: Debug$AcutisLang.Exit,
          _1: Debug$AcutisLang.decodeError(stack, ty, j, Typescheme$AcutisLang.toString),
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: Debug$AcutisLang.Exit,
        _1: Debug$AcutisLang.decodeError(stack, ty, j, Typescheme$AcutisLang.toString),
        Error: new Error()
      };
}

function $$int(stack, j, ty, cases) {
  var i = Js_json.decodeNumber(j);
  if (i !== undefined) {
    var i$1 = i | 0;
    if (cases === undefined) {
      return {
              TAG: /* PConst */3,
              _0: {
                TAG: /* PInt */0,
                _0: i$1
              },
              _1: /* Extra_none */0
            };
    }
    if (Belt_SetInt.has(Caml_option.valFromOption(cases), i$1)) {
      return {
              TAG: /* PConst */3,
              _0: {
                TAG: /* PInt */0,
                _0: i$1
              },
              _1: /* Extra_none */0
            };
    }
    throw {
          RE_EXN_ID: Debug$AcutisLang.Exit,
          _1: Debug$AcutisLang.decodeError(stack, ty, j, Typescheme$AcutisLang.toString),
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: Debug$AcutisLang.Exit,
        _1: Debug$AcutisLang.decodeError(stack, ty, j, Typescheme$AcutisLang.toString),
        Error: new Error()
      };
}

function recordAux(stack, j, tys) {
  return Belt_MapString.mapWithKeyU(tys, (function (k, ty) {
                var match = Js_dict.get(j, k);
                var match$1 = ty.contents;
                if (match !== undefined) {
                  return make({
                              hd: "key: " + k,
                              tl: stack
                            }, Caml_option.valFromOption(match), ty);
                }
                if (typeof match$1 === "number") {
                  if (match$1 === /* Unknown */0 && match === undefined) {
                    return /* PNull */0;
                  }
                  
                } else if (match$1.TAG === /* Nullable */0 && match === undefined) {
                  return /* PNull */0;
                }
                throw {
                      RE_EXN_ID: Debug$AcutisLang.Exit,
                      _1: Debug$AcutisLang.decodeErrorMissingKey(stack, k),
                      Error: new Error()
                    };
              }));
}

function make(stack, j, ty) {
  var ty$1 = ty.contents;
  if (typeof ty$1 === "number") {
    switch (ty$1) {
      case /* Unknown */0 :
          return {
                  TAG: /* PUnknown */0,
                  _0: j
                };
      case /* Int */1 :
          return $$int(stack, j, ty, undefined);
      case /* Float */2 :
          var f = Js_json.decodeNumber(j);
          if (f !== undefined) {
            return {
                    TAG: /* PConst */3,
                    _0: {
                      TAG: /* PFloat */2,
                      _0: f
                    },
                    _1: /* Extra_none */0
                  };
          }
          throw {
                RE_EXN_ID: Debug$AcutisLang.Exit,
                _1: Debug$AcutisLang.decodeError(stack, Typescheme$AcutisLang.$$float(undefined), j, Typescheme$AcutisLang.toString),
                Error: new Error()
              };
      case /* String */3 :
          return string(stack, j, ty, undefined);
      case /* Echo */4 :
          var s = Js_json.classify(j);
          if (typeof s === "number") {
            switch (s) {
              case /* JSONFalse */0 :
                  return {
                          TAG: /* PConst */3,
                          _0: {
                            TAG: /* PInt */0,
                            _0: 0
                          },
                          _1: /* Extra_boolean */1
                        };
              case /* JSONTrue */1 :
                  return {
                          TAG: /* PConst */3,
                          _0: {
                            TAG: /* PInt */0,
                            _0: 1
                          },
                          _1: /* Extra_boolean */1
                        };
              default:
                
            }
          } else {
            switch (s.TAG | 0) {
              case /* JSONString */0 :
                  return {
                          TAG: /* PConst */3,
                          _0: {
                            TAG: /* PString */1,
                            _0: s._0
                          },
                          _1: /* Extra_none */0
                        };
              case /* JSONNumber */1 :
                  return {
                          TAG: /* PConst */3,
                          _0: {
                            TAG: /* PFloat */2,
                            _0: s._0
                          },
                          _1: /* Extra_none */0
                        };
              default:
                
            }
          }
          throw {
                RE_EXN_ID: Debug$AcutisLang.Exit,
                _1: Debug$AcutisLang.decodeError(stack, Typescheme$AcutisLang.echo(undefined), j, Typescheme$AcutisLang.toString),
                Error: new Error()
              };
      
    }
  } else {
    switch (ty$1.TAG | 0) {
      case /* Nullable */0 :
          var ty$2 = ty$1._0;
          if (Js_types.test(j, /* Null */1) || Js_types.test(j, /* Undefined */0)) {
            return /* PNull */0;
          }
          var x = make({
                hd: "nullable",
                tl: stack
              }, j, ty$2);
          return {
                  TAG: /* PArray */1,
                  _0: [x]
                };
      case /* List */1 :
          var ty$3 = ty$1._0;
          var a = Js_json.decodeArray(j);
          if (a !== undefined) {
            var l = /* PNull */0;
            for(var i = a.length - 1 | 0; i >= 0; --i){
              var x$1 = a[i];
              l = {
                TAG: /* PArray */1,
                _0: [
                  make({
                        hd: "index: " + String(i),
                        tl: stack
                      }, x$1, ty$3),
                  l
                ]
              };
            }
            return l;
          }
          throw {
                RE_EXN_ID: Debug$AcutisLang.Exit,
                _1: Debug$AcutisLang.decodeError(stack, Typescheme$AcutisLang.list(ty$3), j, Typescheme$AcutisLang.toString),
                Error: new Error()
              };
      case /* Tuple */2 :
          var tys = ty$1._0;
          var arr = Js_json.decodeArray(j);
          if (arr !== undefined) {
            var arr$1 = Belt_Array.mapWithIndexU(Belt_Array.zip(arr, tys), (function (i, param) {
                    return make({
                                hd: "index: " + String(i),
                                tl: stack
                              }, param[0], param[1]);
                  }));
            return {
                    TAG: /* PArray */1,
                    _0: arr$1
                  };
          }
          throw {
                RE_EXN_ID: Debug$AcutisLang.Exit,
                _1: Debug$AcutisLang.decodeError(stack, Typescheme$AcutisLang.tuple(tys), j, Typescheme$AcutisLang.toString),
                Error: new Error()
              };
      case /* Record */3 :
          var map = ty$1._0;
          var obj = Js_json.decodeObject(j);
          if (obj !== undefined) {
            return {
                    TAG: /* PDict */2,
                    _0: recordAux(stack, Caml_option.valFromOption(obj), map.contents)
                  };
          }
          throw {
                RE_EXN_ID: Debug$AcutisLang.Exit,
                _1: Debug$AcutisLang.decodeError(stack, ty, j, Typescheme$AcutisLang.toString),
                Error: new Error()
              };
      case /* Dict */4 :
          var ty$4 = ty$1._0;
          var obj$1 = Js_json.decodeObject(j);
          if (obj$1 !== undefined) {
            var keys = Js_dict.entries(Caml_option.valFromOption(obj$1));
            var dict = Belt_Array.mapU(keys, (function (param) {
                    var k = param[0];
                    return [
                            k,
                            make({
                                  hd: "key: " + k,
                                  tl: stack
                                }, param[1], ty$4)
                          ];
                  }));
            return {
                    TAG: /* PDict */2,
                    _0: Belt_MapString.fromArray(dict)
                  };
          }
          throw {
                RE_EXN_ID: Debug$AcutisLang.Exit,
                _1: Debug$AcutisLang.decodeError(stack, Typescheme$AcutisLang.dict(ty$4), j, Typescheme$AcutisLang.toString),
                Error: new Error()
              };
      case /* Enum */5 :
          var match = ty$1._0;
          var cases = match.cases;
          if (cases.TAG === /* Int */0) {
            var cases$1 = cases._0;
            var match$1 = match.row;
            if (match.extra) {
              var match$2 = Js_json.decodeBoolean(j);
              var i$1;
              if (match$2 !== undefined) {
                i$1 = match$2 ? 1 : 0;
              } else {
                throw {
                      RE_EXN_ID: Debug$AcutisLang.Exit,
                      _1: Debug$AcutisLang.decodeError(stack, ty, j, Typescheme$AcutisLang.toString),
                      Error: new Error()
                    };
              }
              if (Belt_SetInt.has(cases$1, i$1)) {
                return {
                        TAG: /* PConst */3,
                        _0: {
                          TAG: /* PInt */0,
                          _0: i$1
                        },
                        _1: /* Extra_boolean */1
                      };
              }
              throw {
                    RE_EXN_ID: Debug$AcutisLang.Exit,
                    _1: Debug$AcutisLang.decodeError(stack, ty, j, Typescheme$AcutisLang.toString),
                    Error: new Error()
                  };
            } else if (match$1) {
              return $$int(stack, j, ty, undefined);
            } else {
              return $$int(stack, j, ty, Caml_option.some(cases$1));
            }
          }
          var match$3 = match.row;
          if (match$3) {
            return string(stack, j, ty, undefined);
          } else {
            return string(stack, j, ty, Caml_option.some(cases._0));
          }
      case /* Union */6 :
          var match$4 = ty$1._1;
          var cases$2 = match$4.cases;
          var key = ty$1._0;
          var extra = match$4.extra;
          var fail = function (param) {
            throw {
                  RE_EXN_ID: Debug$AcutisLang.Exit,
                  _1: Debug$AcutisLang.decodeError(stack, ty, j, Typescheme$AcutisLang.toString),
                  Error: new Error()
                };
          };
          var obj$2 = Js_json.decodeObject(j);
          if (obj$2 === undefined) {
            return fail(undefined);
          }
          var obj$3 = Caml_option.valFromOption(obj$2);
          var tag = Js_dict.get(obj$3, key);
          if (tag === undefined) {
            return fail(undefined);
          }
          var match$5 = Js_json.classify(Caml_option.valFromOption(tag));
          var match$6;
          if (typeof match$5 === "number") {
            switch (match$5) {
              case /* JSONFalse */0 :
                  match$6 = cases$2.TAG === /* Int */0 && extra ? [
                      {
                        TAG: /* PConst */3,
                        _0: {
                          TAG: /* PInt */0,
                          _0: 0
                        },
                        _1: extra
                      },
                      Belt_MapInt.get(cases$2._0, 0)
                    ] : fail(undefined);
                  break;
              case /* JSONTrue */1 :
                  match$6 = cases$2.TAG === /* Int */0 && extra ? [
                      {
                        TAG: /* PConst */3,
                        _0: {
                          TAG: /* PInt */0,
                          _0: 1
                        },
                        _1: extra
                      },
                      Belt_MapInt.get(cases$2._0, 1)
                    ] : fail(undefined);
                  break;
              default:
                match$6 = fail(undefined);
            }
          } else {
            switch (match$5.TAG | 0) {
              case /* JSONString */0 :
                  var tag$1 = match$5._0;
                  match$6 = cases$2.TAG === /* Int */0 ? fail(undefined) : [
                      {
                        TAG: /* PConst */3,
                        _0: {
                          TAG: /* PString */1,
                          _0: tag$1
                        },
                        _1: extra
                      },
                      Belt_MapString.get(cases$2._0, tag$1)
                    ];
                  break;
              case /* JSONNumber */1 :
                  if (cases$2.TAG === /* Int */0 && !extra) {
                    var tag$2 = match$5._0 | 0;
                    match$6 = [
                      {
                        TAG: /* PConst */3,
                        _0: {
                          TAG: /* PInt */0,
                          _0: tag$2
                        },
                        _1: extra
                      },
                      Belt_MapInt.get(cases$2._0, tag$2)
                    ];
                  } else {
                    match$6 = fail(undefined);
                  }
                  break;
              default:
                match$6 = fail(undefined);
            }
          }
          var map$1 = match$6[1];
          if (map$1 === undefined) {
            return fail(undefined);
          }
          var r = recordAux(stack, obj$3, map$1.contents);
          return {
                  TAG: /* PDict */2,
                  _0: Belt_MapString.set(r, key, match$6[0])
                };
      
    }
  }
}

function make$1(j, ty) {
  return recordAux(/* [] */0, j, ty);
}

function constantExn(t) {
  if (typeof t === "number") {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Data.res",
            272,
            9
          ],
          Error: new Error()
        };
  }
  if (t.TAG === /* PConst */3) {
    return t._0;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Data.res",
          272,
          9
        ],
        Error: new Error()
      };
}

function tupleExn(t) {
  if (typeof t === "number") {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Data.res",
            278,
            9
          ],
          Error: new Error()
        };
  }
  if (t.TAG === /* PArray */1) {
    return t._0;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Data.res",
          278,
          9
        ],
        Error: new Error()
      };
}

function dictExn(t) {
  if (typeof t === "number") {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Data.res",
            284,
            9
          ],
          Error: new Error()
        };
  }
  if (t.TAG === /* PDict */2) {
    return t._0;
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Data.res",
          284,
          9
        ],
        Error: new Error()
      };
}

function isNull(t) {
  return t === /* PNull */0;
}

function nullableExn(t) {
  if (typeof t === "number") {
    return ;
  }
  if (t.TAG === /* PArray */1) {
    var match = t._0;
    if (match.length !== 1) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "Data.res",
              293,
              9
            ],
            Error: new Error()
          };
    }
    return match[0];
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Data.res",
          293,
          9
        ],
        Error: new Error()
      };
}

function fromPattern(_x, props) {
  while(true) {
    var x = _x;
    var exit = 0;
    var x$1;
    switch (x.TAG | 0) {
      case /* TConst */0 :
          var match = x._2;
          var x$2 = x._1;
          if (match !== undefined && match.extra) {
            return {
                    TAG: /* PConst */3,
                    _0: fromTPat(x$2),
                    _1: /* Extra_boolean */1
                  };
          } else {
            return {
                    TAG: /* PConst */3,
                    _0: fromTPat(x$2),
                    _1: /* Extra_none */0
                  };
          }
      case /* TConstruct */1 :
          var x$3 = x._2;
          if (x$3 === undefined) {
            return /* PNull */0;
          }
          _x = x$3;
          continue ;
      case /* TTuple */2 :
          return {
                  TAG: /* PArray */1,
                  _0: Belt_Array.map(x._1, (function (x) {
                          return fromPattern(x, props);
                        }))
                };
      case /* TRecord */3 :
          var match$1 = x._1;
          if (match$1 !== undefined) {
            var m = Belt_MapString.set(Belt_MapString.mapU(x._2, (function (v) {
                        return fromPattern(v, props);
                      })), match$1[0], {
                  TAG: /* PConst */3,
                  _0: fromTPat(match$1[1]),
                  _1: match$1[2].extra
                });
            return {
                    TAG: /* PDict */2,
                    _0: m
                  };
          }
          x$1 = x._2;
          exit = 2;
          break;
      case /* TDict */4 :
          x$1 = x._1;
          exit = 2;
          break;
      case /* TVar */5 :
      case /* TOptionalVar */6 :
          exit = 1;
          break;
      case /* TAny */7 :
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "Data.res",
                  317,
                  15
                ],
                Error: new Error()
              };
      
    }
    switch (exit) {
      case 1 :
          var x$4 = Belt_MapString.get(props, x._1);
          if (x$4 !== undefined) {
            return x$4;
          }
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "Data.res",
                  304,
                  14
                ],
                Error: new Error()
              };
      case 2 :
          return {
                  TAG: /* PDict */2,
                  _0: Belt_MapString.mapU(x$1, (function (v) {
                          return fromPattern(v, props);
                        }))
                };
      
    }
  };
}

function forEachListExn(l, f) {
  var _i = 0;
  var _l = l;
  while(true) {
    var l$1 = _l;
    var i = _i;
    if (l$1 === /* PNull */0) {
      return ;
    }
    var match = tupleExn(l$1);
    if (match.length !== 2) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "Data.res",
              329,
              13
            ],
            Error: new Error()
          };
    }
    var hd = match[0];
    var tl = match[1];
    f({
          TAG: /* PConst */3,
          _0: {
            TAG: /* PInt */0,
            _0: i
          },
          _1: /* Extra_none */0
        }, hd);
    _l = tl;
    _i = i + 1 | 0;
    continue ;
  };
}

function forEachDictExn(d, f) {
  return Belt_MapString.forEachU(dictExn(d), (function (k, v) {
                return f({
                            TAG: /* PConst */3,
                            _0: {
                              TAG: /* PString */1,
                              _0: k
                            },
                            _1: /* Extra_none */0
                          }, v);
              }));
}

function toString$1(t) {
  if (typeof t === "number") {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "Data.res",
            342,
            9
          ],
          Error: new Error()
        };
  }
  if (t.TAG === /* PConst */3) {
    return toString(t._0, t._1);
  }
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "Data.res",
          342,
          9
        ],
        Error: new Error()
      };
}

function toJson_record(t, ty) {
  return Js_dict.fromArray(Belt_MapString.toArray(Belt_MapString.mergeU(t, ty, (function (param, t, ty) {
                        if (t !== undefined && ty !== undefined) {
                          return Caml_option.some(toJson(t, ty.contents));
                        }
                        
                      }))));
}

function toJson(_t, _ty) {
  while(true) {
    var ty = _ty;
    var t = _t;
    var exit = 0;
    if (typeof t === "number") {
      if (typeof ty === "number") {
        exit = 2;
      } else {
        switch (ty.TAG | 0) {
          case /* Nullable */0 :
              return null;
          case /* List */1 :
              exit = 1;
              break;
          default:
            exit = 2;
        }
      }
    } else {
      switch (t.TAG | 0) {
        case /* PUnknown */0 :
            return t._0;
        case /* PArray */1 :
            var a = t._0;
            var exit$1 = 0;
            if (a.length !== 1) {
              exit$1 = 3;
            } else {
              var t$1 = a[0];
              if (typeof ty === "number") {
                exit = 2;
              } else {
                switch (ty.TAG | 0) {
                  case /* Nullable */0 :
                      _ty = ty._0.contents;
                      _t = t$1;
                      continue ;
                  case /* List */1 :
                      exit = 1;
                      break;
                  case /* Tuple */2 :
                      exit$1 = 3;
                      break;
                  default:
                    exit = 2;
                }
              }
            }
            if (exit$1 === 3) {
              if (typeof ty === "number") {
                exit = 2;
              } else {
                switch (ty.TAG | 0) {
                  case /* List */1 :
                      exit = 1;
                      break;
                  case /* Tuple */2 :
                      return Belt_Array.zipByU(a, ty._0, (function (t, ty) {
                                    return toJson(t, ty.contents);
                                  }));
                  default:
                    exit = 2;
                }
              }
            }
            break;
        case /* PDict */2 :
            var o = t._0;
            if (typeof ty === "number") {
              exit = 2;
            } else {
              switch (ty.TAG | 0) {
                case /* List */1 :
                    exit = 1;
                    break;
                case /* Record */3 :
                    return toJson_record(o, ty._0.contents);
                case /* Dict */4 :
                    var ty$1 = ty._0;
                    var r = {};
                    Belt_Array.forEachU(Belt_MapString.toArray(o), (function(ty$1,r){
                        return function (param) {
                          r[param[0]] = toJson(param[1], ty$1.contents);
                          
                        }
                        }(ty$1,r)));
                    return r;
                case /* Union */6 :
                    var k = ty._0;
                    var cases = ty._1.cases;
                    var tag = Belt_MapString.getExn(o, k);
                    var recordTy;
                    var exit$2 = 0;
                    if (cases.TAG === /* Int */0) {
                      if (typeof tag === "number" || tag.TAG !== /* PConst */3) {
                        exit$2 = 3;
                      } else {
                        var i = tag._0;
                        switch (i.TAG | 0) {
                          case /* PInt */0 :
                              recordTy = Belt_MapInt.getExn(cases._0, i._0).contents;
                              break;
                          case /* PString */1 :
                          case /* PFloat */2 :
                              exit$2 = 3;
                              break;
                          
                        }
                      }
                    } else if (typeof tag === "number" || tag.TAG !== /* PConst */3) {
                      exit$2 = 3;
                    } else {
                      var s = tag._0;
                      switch (s.TAG | 0) {
                        case /* PString */1 :
                            recordTy = Belt_MapString.getExn(cases._0, s._0).contents;
                            break;
                        case /* PInt */0 :
                        case /* PFloat */2 :
                            exit$2 = 3;
                            break;
                        
                      }
                    }
                    if (exit$2 === 3) {
                      throw {
                            RE_EXN_ID: "Assert_failure",
                            _1: [
                              "Data.res",
                              388,
                              11
                            ],
                            Error: new Error()
                          };
                    }
                    var tag$1;
                    var exit$3 = 0;
                    if (typeof tag === "number" || tag.TAG !== /* PConst */3) {
                      exit$3 = 3;
                    } else {
                      var s$1 = tag._0;
                      switch (s$1.TAG | 0) {
                        case /* PInt */0 :
                            var i$1 = s$1._0;
                            tag$1 = i$1 !== 0 ? (
                                tag._1 ? true : i$1
                              ) : (
                                tag._1 ? false : (
                                    tag._1 ? true : i$1
                                  )
                              );
                            break;
                        case /* PString */1 :
                            tag$1 = s$1._0;
                            break;
                        case /* PFloat */2 :
                            exit$3 = 3;
                            break;
                        
                      }
                    }
                    if (exit$3 === 3) {
                      throw {
                            RE_EXN_ID: "Assert_failure",
                            _1: [
                              "Data.res",
                              395,
                              11
                            ],
                            Error: new Error()
                          };
                    }
                    var jsobj = toJson_record(o, recordTy);
                    jsobj[k] = tag$1;
                    return jsobj;
                default:
                  exit = 2;
              }
            }
            break;
        case /* PConst */3 :
            var f = t._0;
            switch (f.TAG | 0) {
              case /* PInt */0 :
                  var i$2 = f._0;
                  var exit$4 = 0;
                  if (i$2 !== 0 || !t._1) {
                    exit$4 = 3;
                  } else if (typeof ty === "number") {
                    switch (ty) {
                      case /* Int */1 :
                          exit$4 = 3;
                          break;
                      case /* Echo */4 :
                          return false;
                      default:
                        exit = 2;
                    }
                  } else {
                    switch (ty.TAG | 0) {
                      case /* List */1 :
                          exit = 1;
                          break;
                      case /* Enum */5 :
                          if (ty._0.extra) {
                            return false;
                          }
                          exit$4 = 3;
                          break;
                      default:
                        exit = 2;
                    }
                  }
                  if (exit$4 === 3) {
                    var exit$5 = 0;
                    if (t._1) {
                      if (typeof ty === "number") {
                        switch (ty) {
                          case /* Int */1 :
                              exit$5 = 4;
                              break;
                          case /* Echo */4 :
                              return true;
                          default:
                            exit = 2;
                        }
                      } else {
                        switch (ty.TAG | 0) {
                          case /* List */1 :
                              exit = 1;
                              break;
                          case /* Enum */5 :
                              if (ty._0.extra) {
                                return true;
                              }
                              exit$5 = 4;
                              break;
                          default:
                            exit = 2;
                        }
                      }
                    } else {
                      exit$5 = 4;
                    }
                    if (exit$5 === 4) {
                      if (typeof ty === "number") {
                        switch (ty) {
                          case /* Int */1 :
                          case /* Echo */4 :
                              return i$2;
                          default:
                            exit = 2;
                        }
                      } else {
                        switch (ty.TAG | 0) {
                          case /* List */1 :
                              exit = 1;
                              break;
                          case /* Enum */5 :
                              return i$2;
                          default:
                            exit = 2;
                        }
                      }
                    }
                    
                  }
                  break;
              case /* PString */1 :
              case /* PFloat */2 :
                  return f._0;
              
            }
            break;
        
      }
    }
    switch (exit) {
      case 1 :
          var ty$2 = ty._0;
          var q = Belt_MutableQueue.make(undefined);
          var _l = t;
          while(true) {
            var l = _l;
            if (typeof l === "number") {
              return Belt_MutableQueue.toArray(q);
            }
            if (l.TAG === /* PArray */1) {
              var match = l._0;
              if (match.length !== 2) {
                throw {
                      RE_EXN_ID: "Assert_failure",
                      _1: [
                        "Data.res",
                        374,
                        13
                      ],
                      Error: new Error()
                    };
              }
              var hd = match[0];
              var tl = match[1];
              Belt_MutableQueue.add(q, toJson(hd, ty$2.contents));
              _l = tl;
              continue ;
            }
            throw {
                  RE_EXN_ID: "Assert_failure",
                  _1: [
                    "Data.res",
                    374,
                    13
                  ],
                  Error: new Error()
                };
          };
      case 2 :
          throw {
                RE_EXN_ID: "Assert_failure",
                _1: [
                  "Data.res",
                  400,
                  9
                ],
                Error: new Error()
              };
      
    }
  };
}

var toJson$1 = toJson_record;

exports.Const = Const;
exports.make = make$1;
exports.constantExn = constantExn;
exports.tupleExn = tupleExn;
exports.dictExn = dictExn;
exports.isNull = isNull;
exports.nullableExn = nullableExn;
exports.fromPattern = fromPattern;
exports.forEachListExn = forEachListExn;
exports.forEachDictExn = forEachDictExn;
exports.toString = toString$1;
exports.toJson = toJson$1;
/* Typescheme-AcutisLang Not a pure module */

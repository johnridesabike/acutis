{"version":3,"file":"acutis.mjs","sources":["../node_modules/bs-platform/lib/es6/caml_option.js","../node_modules/bs-platform/lib/es6/belt_Array.js","../node_modules/bs-platform/lib/es6/caml_primitive.js","../node_modules/bs-platform/lib/es6/belt_List.js","../node_modules/bs-platform/lib/es6/caml_exceptions.js","../src/Acutis_Types.bs.js","../src/Debug.bs.js","../node_modules/bs-platform/lib/es6/belt_MutableQueue.js","../src/Lexer.bs.js","../node_modules/bs-platform/lib/es6/belt_Float.js","../node_modules/bs-platform/lib/es6/caml_js_exceptions.js","../src/Compile.bs.js","../node_modules/bs-platform/lib/es6/js_dict.js","../node_modules/bs-platform/lib/es6/js_json.js","../node_modules/bs-platform/lib/es6/belt_Result.js","../src/Render.bs.js","../src/Environment.bs.js","../src/AcutisJs.bs.js"],"sourcesContent":["\n\n\nfunction isNested(x) {\n  return x.BS_PRIVATE_NESTED_SOME_NONE !== undefined;\n}\n\nfunction some(x) {\n  if (x === undefined) {\n    return {\n            BS_PRIVATE_NESTED_SOME_NONE: 0\n          };\n  } else if (x !== null && x.BS_PRIVATE_NESTED_SOME_NONE !== undefined) {\n    return {\n            BS_PRIVATE_NESTED_SOME_NONE: x.BS_PRIVATE_NESTED_SOME_NONE + 1 | 0\n          };\n  } else {\n    return x;\n  }\n}\n\nfunction nullable_to_opt(x) {\n  if (x == null) {\n    return ;\n  } else {\n    return some(x);\n  }\n}\n\nfunction undefined_to_opt(x) {\n  if (x === undefined) {\n    return ;\n  } else {\n    return some(x);\n  }\n}\n\nfunction null_to_opt(x) {\n  if (x === null) {\n    return ;\n  } else {\n    return some(x);\n  }\n}\n\nfunction valFromOption(x) {\n  if (!(x !== null && x.BS_PRIVATE_NESTED_SOME_NONE !== undefined)) {\n    return x;\n  }\n  var depth = x.BS_PRIVATE_NESTED_SOME_NONE;\n  if (depth === 0) {\n    return ;\n  } else {\n    return {\n            BS_PRIVATE_NESTED_SOME_NONE: depth - 1 | 0\n          };\n  }\n}\n\nfunction option_get(x) {\n  if (x === undefined) {\n    return ;\n  } else {\n    return valFromOption(x);\n  }\n}\n\nfunction option_unwrap(x) {\n  if (x !== undefined) {\n    return x.VAL;\n  } else {\n    return x;\n  }\n}\n\nexport {\n  nullable_to_opt ,\n  undefined_to_opt ,\n  null_to_opt ,\n  valFromOption ,\n  some ,\n  isNested ,\n  option_get ,\n  option_unwrap ,\n  \n}\n/* No side effect */\n","\n\nimport * as Curry from \"./curry.js\";\nimport * as Js_math from \"./js_math.js\";\nimport * as Caml_option from \"./caml_option.js\";\nimport * as Caml_primitive from \"./caml_primitive.js\";\n\nfunction get(arr, i) {\n  if (i >= 0 && i < arr.length) {\n    return Caml_option.some(arr[i]);\n  }\n  \n}\n\nfunction getExn(arr, i) {\n  if (!(i >= 0 && i < arr.length)) {\n    throw {\n          RE_EXN_ID: \"Assert_failure\",\n          _1: [\n            \"belt_Array.ml\",\n            27,\n            4\n          ],\n          Error: new Error()\n        };\n  }\n  return arr[i];\n}\n\nfunction set(arr, i, v) {\n  if (i >= 0 && i < arr.length) {\n    arr[i] = v;\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction setExn(arr, i, v) {\n  if (!(i >= 0 && i < arr.length)) {\n    throw {\n          RE_EXN_ID: \"Assert_failure\",\n          _1: [\n            \"belt_Array.ml\",\n            33,\n            2\n          ],\n          Error: new Error()\n        };\n  }\n  arr[i] = v;\n  \n}\n\nfunction swapUnsafe(xs, i, j) {\n  var tmp = xs[i];\n  xs[i] = xs[j];\n  xs[j] = tmp;\n  \n}\n\nfunction shuffleInPlace(xs) {\n  var len = xs.length;\n  for(var i = 0; i < len; ++i){\n    swapUnsafe(xs, i, Js_math.random_int(i, len));\n  }\n  \n}\n\nfunction shuffle(xs) {\n  var result = xs.slice(0);\n  shuffleInPlace(result);\n  return result;\n}\n\nfunction reverseInPlace(xs) {\n  var len = xs.length;\n  var ofs = 0;\n  for(var i = 0 ,i_finish = len / 2 | 0; i < i_finish; ++i){\n    swapUnsafe(xs, ofs + i | 0, ((ofs + len | 0) - i | 0) - 1 | 0);\n  }\n  \n}\n\nfunction reverse(xs) {\n  var len = xs.length;\n  var result = new Array(len);\n  for(var i = 0; i < len; ++i){\n    result[i] = xs[(len - 1 | 0) - i | 0];\n  }\n  return result;\n}\n\nfunction make(l, f) {\n  if (l <= 0) {\n    return [];\n  }\n  var res = new Array(l);\n  for(var i = 0; i < l; ++i){\n    res[i] = f;\n  }\n  return res;\n}\n\nfunction makeByU(l, f) {\n  if (l <= 0) {\n    return [];\n  }\n  var res = new Array(l);\n  for(var i = 0; i < l; ++i){\n    res[i] = f(i);\n  }\n  return res;\n}\n\nfunction makeBy(l, f) {\n  return makeByU(l, Curry.__1(f));\n}\n\nfunction makeByAndShuffleU(l, f) {\n  var u = makeByU(l, f);\n  shuffleInPlace(u);\n  return u;\n}\n\nfunction makeByAndShuffle(l, f) {\n  return makeByAndShuffleU(l, Curry.__1(f));\n}\n\nfunction range(start, finish) {\n  var cut = finish - start | 0;\n  if (cut < 0) {\n    return [];\n  }\n  var arr = new Array(cut + 1 | 0);\n  for(var i = 0; i <= cut; ++i){\n    arr[i] = start + i | 0;\n  }\n  return arr;\n}\n\nfunction rangeBy(start, finish, step) {\n  var cut = finish - start | 0;\n  if (cut < 0 || step <= 0) {\n    return [];\n  }\n  var nb = (cut / step | 0) + 1 | 0;\n  var arr = new Array(nb);\n  var cur = start;\n  for(var i = 0; i < nb; ++i){\n    arr[i] = cur;\n    cur = cur + step | 0;\n  }\n  return arr;\n}\n\nfunction zip(xs, ys) {\n  var lenx = xs.length;\n  var leny = ys.length;\n  var len = lenx < leny ? lenx : leny;\n  var s = new Array(len);\n  for(var i = 0; i < len; ++i){\n    s[i] = [\n      xs[i],\n      ys[i]\n    ];\n  }\n  return s;\n}\n\nfunction zipByU(xs, ys, f) {\n  var lenx = xs.length;\n  var leny = ys.length;\n  var len = lenx < leny ? lenx : leny;\n  var s = new Array(len);\n  for(var i = 0; i < len; ++i){\n    s[i] = f(xs[i], ys[i]);\n  }\n  return s;\n}\n\nfunction zipBy(xs, ys, f) {\n  return zipByU(xs, ys, Curry.__2(f));\n}\n\nfunction concat(a1, a2) {\n  var l1 = a1.length;\n  var l2 = a2.length;\n  var a1a2 = new Array(l1 + l2 | 0);\n  for(var i = 0; i < l1; ++i){\n    a1a2[i] = a1[i];\n  }\n  for(var i$1 = 0; i$1 < l2; ++i$1){\n    a1a2[l1 + i$1 | 0] = a2[i$1];\n  }\n  return a1a2;\n}\n\nfunction concatMany(arrs) {\n  var lenArrs = arrs.length;\n  var totalLen = 0;\n  for(var i = 0; i < lenArrs; ++i){\n    totalLen = totalLen + arrs[i].length | 0;\n  }\n  var result = new Array(totalLen);\n  totalLen = 0;\n  for(var j = 0; j < lenArrs; ++j){\n    var cur = arrs[j];\n    for(var k = 0 ,k_finish = cur.length; k < k_finish; ++k){\n      result[totalLen] = cur[k];\n      totalLen = totalLen + 1 | 0;\n    }\n  }\n  return result;\n}\n\nfunction slice(a, offset, len) {\n  if (len <= 0) {\n    return [];\n  }\n  var lena = a.length;\n  var ofs = offset < 0 ? Caml_primitive.caml_int_max(lena + offset | 0, 0) : offset;\n  var hasLen = lena - ofs | 0;\n  var copyLength = hasLen < len ? hasLen : len;\n  if (copyLength <= 0) {\n    return [];\n  }\n  var result = new Array(copyLength);\n  for(var i = 0; i < copyLength; ++i){\n    result[i] = a[ofs + i | 0];\n  }\n  return result;\n}\n\nfunction sliceToEnd(a, offset) {\n  var lena = a.length;\n  var ofs = offset < 0 ? Caml_primitive.caml_int_max(lena + offset | 0, 0) : offset;\n  var len = lena - ofs | 0;\n  var result = new Array(len);\n  for(var i = 0; i < len; ++i){\n    result[i] = a[ofs + i | 0];\n  }\n  return result;\n}\n\nfunction fill(a, offset, len, v) {\n  if (len <= 0) {\n    return ;\n  }\n  var lena = a.length;\n  var ofs = offset < 0 ? Caml_primitive.caml_int_max(lena + offset | 0, 0) : offset;\n  var hasLen = lena - ofs | 0;\n  var fillLength = hasLen < len ? hasLen : len;\n  if (fillLength <= 0) {\n    return ;\n  }\n  for(var i = ofs ,i_finish = ofs + fillLength | 0; i < i_finish; ++i){\n    a[i] = v;\n  }\n  \n}\n\nfunction blitUnsafe(a1, srcofs1, a2, srcofs2, blitLength) {\n  if (srcofs2 <= srcofs1) {\n    for(var j = 0; j < blitLength; ++j){\n      a2[j + srcofs2 | 0] = a1[j + srcofs1 | 0];\n    }\n    return ;\n  }\n  for(var j$1 = blitLength - 1 | 0; j$1 >= 0; --j$1){\n    a2[j$1 + srcofs2 | 0] = a1[j$1 + srcofs1 | 0];\n  }\n  \n}\n\nfunction blit(a1, ofs1, a2, ofs2, len) {\n  var lena1 = a1.length;\n  var lena2 = a2.length;\n  var srcofs1 = ofs1 < 0 ? Caml_primitive.caml_int_max(lena1 + ofs1 | 0, 0) : ofs1;\n  var srcofs2 = ofs2 < 0 ? Caml_primitive.caml_int_max(lena2 + ofs2 | 0, 0) : ofs2;\n  var blitLength = Caml_primitive.caml_int_min(len, Caml_primitive.caml_int_min(lena1 - srcofs1 | 0, lena2 - srcofs2 | 0));\n  if (srcofs2 <= srcofs1) {\n    for(var j = 0; j < blitLength; ++j){\n      a2[j + srcofs2 | 0] = a1[j + srcofs1 | 0];\n    }\n    return ;\n  }\n  for(var j$1 = blitLength - 1 | 0; j$1 >= 0; --j$1){\n    a2[j$1 + srcofs2 | 0] = a1[j$1 + srcofs1 | 0];\n  }\n  \n}\n\nfunction forEachU(a, f) {\n  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){\n    f(a[i]);\n  }\n  \n}\n\nfunction forEach(a, f) {\n  return forEachU(a, Curry.__1(f));\n}\n\nfunction mapU(a, f) {\n  var l = a.length;\n  var r = new Array(l);\n  for(var i = 0; i < l; ++i){\n    r[i] = f(a[i]);\n  }\n  return r;\n}\n\nfunction map(a, f) {\n  return mapU(a, Curry.__1(f));\n}\n\nfunction getByU(a, p) {\n  var l = a.length;\n  var i = 0;\n  var r;\n  while(r === undefined && i < l) {\n    var v = a[i];\n    if (p(v)) {\n      r = Caml_option.some(v);\n    }\n    i = i + 1 | 0;\n  };\n  return r;\n}\n\nfunction getBy(a, p) {\n  return getByU(a, Curry.__1(p));\n}\n\nfunction getIndexByU(a, p) {\n  var l = a.length;\n  var i = 0;\n  var r;\n  while(r === undefined && i < l) {\n    var v = a[i];\n    if (p(v)) {\n      r = i;\n    }\n    i = i + 1 | 0;\n  };\n  return r;\n}\n\nfunction getIndexBy(a, p) {\n  return getIndexByU(a, Curry.__1(p));\n}\n\nfunction keepU(a, f) {\n  var l = a.length;\n  var r = new Array(l);\n  var j = 0;\n  for(var i = 0; i < l; ++i){\n    var v = a[i];\n    if (f(v)) {\n      r[j] = v;\n      j = j + 1 | 0;\n    }\n    \n  }\n  r.length = j;\n  return r;\n}\n\nfunction keep(a, f) {\n  return keepU(a, Curry.__1(f));\n}\n\nfunction keepWithIndexU(a, f) {\n  var l = a.length;\n  var r = new Array(l);\n  var j = 0;\n  for(var i = 0; i < l; ++i){\n    var v = a[i];\n    if (f(v, i)) {\n      r[j] = v;\n      j = j + 1 | 0;\n    }\n    \n  }\n  r.length = j;\n  return r;\n}\n\nfunction keepWithIndex(a, f) {\n  return keepWithIndexU(a, Curry.__2(f));\n}\n\nfunction keepMapU(a, f) {\n  var l = a.length;\n  var r = new Array(l);\n  var j = 0;\n  for(var i = 0; i < l; ++i){\n    var v = a[i];\n    var v$1 = f(v);\n    if (v$1 !== undefined) {\n      r[j] = Caml_option.valFromOption(v$1);\n      j = j + 1 | 0;\n    }\n    \n  }\n  r.length = j;\n  return r;\n}\n\nfunction keepMap(a, f) {\n  return keepMapU(a, Curry.__1(f));\n}\n\nfunction forEachWithIndexU(a, f) {\n  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){\n    f(i, a[i]);\n  }\n  \n}\n\nfunction forEachWithIndex(a, f) {\n  return forEachWithIndexU(a, Curry.__2(f));\n}\n\nfunction mapWithIndexU(a, f) {\n  var l = a.length;\n  var r = new Array(l);\n  for(var i = 0; i < l; ++i){\n    r[i] = f(i, a[i]);\n  }\n  return r;\n}\n\nfunction mapWithIndex(a, f) {\n  return mapWithIndexU(a, Curry.__2(f));\n}\n\nfunction reduceU(a, x, f) {\n  var r = x;\n  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){\n    r = f(r, a[i]);\n  }\n  return r;\n}\n\nfunction reduce(a, x, f) {\n  return reduceU(a, x, Curry.__2(f));\n}\n\nfunction reduceReverseU(a, x, f) {\n  var r = x;\n  for(var i = a.length - 1 | 0; i >= 0; --i){\n    r = f(r, a[i]);\n  }\n  return r;\n}\n\nfunction reduceReverse(a, x, f) {\n  return reduceReverseU(a, x, Curry.__2(f));\n}\n\nfunction reduceReverse2U(a, b, x, f) {\n  var r = x;\n  var len = Caml_primitive.caml_int_min(a.length, b.length);\n  for(var i = len - 1 | 0; i >= 0; --i){\n    r = f(r, a[i], b[i]);\n  }\n  return r;\n}\n\nfunction reduceReverse2(a, b, x, f) {\n  return reduceReverse2U(a, b, x, Curry.__3(f));\n}\n\nfunction reduceWithIndexU(a, x, f) {\n  var r = x;\n  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){\n    r = f(r, a[i], i);\n  }\n  return r;\n}\n\nfunction reduceWithIndex(a, x, f) {\n  return reduceWithIndexU(a, x, Curry.__3(f));\n}\n\nfunction everyU(arr, b) {\n  var len = arr.length;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    if (i === len) {\n      return true;\n    }\n    if (!b(arr[i])) {\n      return false;\n    }\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction every(arr, f) {\n  return everyU(arr, Curry.__1(f));\n}\n\nfunction someU(arr, b) {\n  var len = arr.length;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    if (i === len) {\n      return false;\n    }\n    if (b(arr[i])) {\n      return true;\n    }\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction some(arr, f) {\n  return someU(arr, Curry.__1(f));\n}\n\nfunction everyAux2(arr1, arr2, _i, b, len) {\n  while(true) {\n    var i = _i;\n    if (i === len) {\n      return true;\n    }\n    if (!b(arr1[i], arr2[i])) {\n      return false;\n    }\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction every2U(a, b, p) {\n  return everyAux2(a, b, 0, p, Caml_primitive.caml_int_min(a.length, b.length));\n}\n\nfunction every2(a, b, p) {\n  return every2U(a, b, Curry.__2(p));\n}\n\nfunction some2U(a, b, p) {\n  var _i = 0;\n  var len = Caml_primitive.caml_int_min(a.length, b.length);\n  while(true) {\n    var i = _i;\n    if (i === len) {\n      return false;\n    }\n    if (p(a[i], b[i])) {\n      return true;\n    }\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction some2(a, b, p) {\n  return some2U(a, b, Curry.__2(p));\n}\n\nfunction eqU(a, b, p) {\n  var lena = a.length;\n  var lenb = b.length;\n  if (lena === lenb) {\n    return everyAux2(a, b, 0, p, lena);\n  } else {\n    return false;\n  }\n}\n\nfunction eq(a, b, p) {\n  return eqU(a, b, Curry.__2(p));\n}\n\nfunction cmpU(a, b, p) {\n  var lena = a.length;\n  var lenb = b.length;\n  if (lena > lenb) {\n    return 1;\n  } else if (lena < lenb) {\n    return -1;\n  } else {\n    var _i = 0;\n    while(true) {\n      var i = _i;\n      if (i === lena) {\n        return 0;\n      }\n      var c = p(a[i], b[i]);\n      if (c !== 0) {\n        return c;\n      }\n      _i = i + 1 | 0;\n      continue ;\n    };\n  }\n}\n\nfunction cmp(a, b, p) {\n  return cmpU(a, b, Curry.__2(p));\n}\n\nfunction partitionU(a, f) {\n  var l = a.length;\n  var i = 0;\n  var j = 0;\n  var a1 = new Array(l);\n  var a2 = new Array(l);\n  for(var ii = 0; ii < l; ++ii){\n    var v = a[ii];\n    if (f(v)) {\n      a1[i] = v;\n      i = i + 1 | 0;\n    } else {\n      a2[j] = v;\n      j = j + 1 | 0;\n    }\n  }\n  a1.length = i;\n  a2.length = j;\n  return [\n          a1,\n          a2\n        ];\n}\n\nfunction partition(a, f) {\n  return partitionU(a, Curry.__1(f));\n}\n\nfunction unzip(a) {\n  var l = a.length;\n  var a1 = new Array(l);\n  var a2 = new Array(l);\n  for(var i = 0; i < l; ++i){\n    var match = a[i];\n    a1[i] = match[0];\n    a2[i] = match[1];\n  }\n  return [\n          a1,\n          a2\n        ];\n}\n\nfunction joinWithU(a, sep, toString) {\n  var l = a.length;\n  if (l === 0) {\n    return \"\";\n  }\n  var lastIndex = l - 1 | 0;\n  var _i = 0;\n  var _res = \"\";\n  while(true) {\n    var res = _res;\n    var i = _i;\n    if (i === lastIndex) {\n      return res + toString(a[i]);\n    }\n    _res = res + (toString(a[i]) + sep);\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction joinWith(a, sep, toString) {\n  return joinWithU(a, sep, Curry.__1(toString));\n}\n\nexport {\n  get ,\n  getExn ,\n  set ,\n  setExn ,\n  shuffleInPlace ,\n  shuffle ,\n  reverseInPlace ,\n  reverse ,\n  make ,\n  range ,\n  rangeBy ,\n  makeByU ,\n  makeBy ,\n  makeByAndShuffleU ,\n  makeByAndShuffle ,\n  zip ,\n  zipByU ,\n  zipBy ,\n  unzip ,\n  concat ,\n  concatMany ,\n  slice ,\n  sliceToEnd ,\n  fill ,\n  blit ,\n  blitUnsafe ,\n  forEachU ,\n  forEach ,\n  mapU ,\n  map ,\n  getByU ,\n  getBy ,\n  getIndexByU ,\n  getIndexBy ,\n  keepU ,\n  keep ,\n  keepWithIndexU ,\n  keepWithIndex ,\n  keepMapU ,\n  keepMap ,\n  forEachWithIndexU ,\n  forEachWithIndex ,\n  mapWithIndexU ,\n  mapWithIndex ,\n  partitionU ,\n  partition ,\n  reduceU ,\n  reduce ,\n  reduceReverseU ,\n  reduceReverse ,\n  reduceReverse2U ,\n  reduceReverse2 ,\n  reduceWithIndexU ,\n  reduceWithIndex ,\n  joinWithU ,\n  joinWith ,\n  someU ,\n  some ,\n  everyU ,\n  every ,\n  every2U ,\n  every2 ,\n  some2U ,\n  some2 ,\n  cmpU ,\n  cmp ,\n  eqU ,\n  eq ,\n  \n}\n/* No side effect */\n","\n\n\nfunction caml_int_compare(x, y) {\n  if (x < y) {\n    return -1;\n  } else if (x === y) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nfunction caml_bool_compare(x, y) {\n  if (x) {\n    if (y) {\n      return 0;\n    } else {\n      return 1;\n    }\n  } else if (y) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nfunction caml_float_compare(x, y) {\n  if (x === y) {\n    return 0;\n  } else if (x < y) {\n    return -1;\n  } else if (x > y || x === x) {\n    return 1;\n  } else if (y === y) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nfunction caml_string_compare(s1, s2) {\n  if (s1 === s2) {\n    return 0;\n  } else if (s1 < s2) {\n    return -1;\n  } else {\n    return 1;\n  }\n}\n\nfunction caml_bool_min(x, y) {\n  if (x) {\n    return y;\n  } else {\n    return x;\n  }\n}\n\nfunction caml_int_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_float_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_string_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_nativeint_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_int32_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_bool_max(x, y) {\n  if (x) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_int_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_float_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_string_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_nativeint_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_int32_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nvar caml_nativeint_compare = caml_int_compare;\n\nvar caml_int32_compare = caml_int_compare;\n\nexport {\n  caml_int_compare ,\n  caml_bool_compare ,\n  caml_float_compare ,\n  caml_nativeint_compare ,\n  caml_string_compare ,\n  caml_int32_compare ,\n  caml_bool_min ,\n  caml_int_min ,\n  caml_float_min ,\n  caml_string_min ,\n  caml_nativeint_min ,\n  caml_int32_min ,\n  caml_bool_max ,\n  caml_int_max ,\n  caml_float_max ,\n  caml_string_max ,\n  caml_nativeint_max ,\n  caml_int32_max ,\n  \n}\n/* No side effect */\n","\n\nimport * as Curry from \"./curry.js\";\nimport * as Belt_Array from \"./belt_Array.js\";\nimport * as Caml_option from \"./caml_option.js\";\nimport * as Belt_SortArray from \"./belt_SortArray.js\";\n\nfunction head(x) {\n  if (x) {\n    return Caml_option.some(x.hd);\n  }\n  \n}\n\nfunction headExn(x) {\n  if (x) {\n    return x.hd;\n  }\n  throw {\n        RE_EXN_ID: \"Not_found\",\n        Error: new Error()\n      };\n}\n\nfunction tail(x) {\n  if (x) {\n    return x.tl;\n  }\n  \n}\n\nfunction tailExn(x) {\n  if (x) {\n    return x.tl;\n  }\n  throw {\n        RE_EXN_ID: \"Not_found\",\n        Error: new Error()\n      };\n}\n\nfunction add(xs, x) {\n  return {\n          hd: x,\n          tl: xs\n        };\n}\n\nfunction get(x, n) {\n  if (n < 0) {\n    return ;\n  } else {\n    var _x = x;\n    var _n = n;\n    while(true) {\n      var n$1 = _n;\n      var x$1 = _x;\n      if (!x$1) {\n        return ;\n      }\n      if (n$1 === 0) {\n        return Caml_option.some(x$1.hd);\n      }\n      _n = n$1 - 1 | 0;\n      _x = x$1.tl;\n      continue ;\n    };\n  }\n}\n\nfunction getExn(x, n) {\n  if (n < 0) {\n    throw {\n          RE_EXN_ID: \"Not_found\",\n          Error: new Error()\n        };\n  }\n  var _x = x;\n  var _n = n;\n  while(true) {\n    var n$1 = _n;\n    var x$1 = _x;\n    if (x$1) {\n      if (n$1 === 0) {\n        return x$1.hd;\n      }\n      _n = n$1 - 1 | 0;\n      _x = x$1.tl;\n      continue ;\n    }\n    throw {\n          RE_EXN_ID: \"Not_found\",\n          Error: new Error()\n        };\n  };\n}\n\nfunction partitionAux(p, _cell, _precX, _precY) {\n  while(true) {\n    var precY = _precY;\n    var precX = _precX;\n    var cell = _cell;\n    if (!cell) {\n      return ;\n    }\n    var t = cell.tl;\n    var h = cell.hd;\n    var next = {\n      hd: h,\n      tl: /* [] */0\n    };\n    if (p(h)) {\n      precX.tl = next;\n      _precX = next;\n      _cell = t;\n      continue ;\n    }\n    precY.tl = next;\n    _precY = next;\n    _cell = t;\n    continue ;\n  };\n}\n\nfunction splitAux(_cell, _precX, _precY) {\n  while(true) {\n    var precY = _precY;\n    var precX = _precX;\n    var cell = _cell;\n    if (!cell) {\n      return ;\n    }\n    var match = cell.hd;\n    var nextA = {\n      hd: match[0],\n      tl: /* [] */0\n    };\n    var nextB = {\n      hd: match[1],\n      tl: /* [] */0\n    };\n    precX.tl = nextA;\n    precY.tl = nextB;\n    _precY = nextB;\n    _precX = nextA;\n    _cell = cell.tl;\n    continue ;\n  };\n}\n\nfunction copyAuxCont(_cellX, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cellX = _cellX;\n    if (!cellX) {\n      return prec;\n    }\n    var next = {\n      hd: cellX.hd,\n      tl: /* [] */0\n    };\n    prec.tl = next;\n    _prec = next;\n    _cellX = cellX.tl;\n    continue ;\n  };\n}\n\nfunction copyAuxWitFilter(f, _cellX, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cellX = _cellX;\n    if (!cellX) {\n      return ;\n    }\n    var t = cellX.tl;\n    var h = cellX.hd;\n    if (f(h)) {\n      var next = {\n        hd: h,\n        tl: /* [] */0\n      };\n      prec.tl = next;\n      _prec = next;\n      _cellX = t;\n      continue ;\n    }\n    _cellX = t;\n    continue ;\n  };\n}\n\nfunction copyAuxWithFilterIndex(f, _cellX, _prec, _i) {\n  while(true) {\n    var i = _i;\n    var prec = _prec;\n    var cellX = _cellX;\n    if (!cellX) {\n      return ;\n    }\n    var t = cellX.tl;\n    var h = cellX.hd;\n    if (f(h, i)) {\n      var next = {\n        hd: h,\n        tl: /* [] */0\n      };\n      prec.tl = next;\n      _i = i + 1 | 0;\n      _prec = next;\n      _cellX = t;\n      continue ;\n    }\n    _i = i + 1 | 0;\n    _cellX = t;\n    continue ;\n  };\n}\n\nfunction copyAuxWitFilterMap(f, _cellX, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cellX = _cellX;\n    if (!cellX) {\n      return ;\n    }\n    var t = cellX.tl;\n    var h = f(cellX.hd);\n    if (h !== undefined) {\n      var next = {\n        hd: Caml_option.valFromOption(h),\n        tl: /* [] */0\n      };\n      prec.tl = next;\n      _prec = next;\n      _cellX = t;\n      continue ;\n    }\n    _cellX = t;\n    continue ;\n  };\n}\n\nfunction removeAssocAuxWithMap(_cellX, x, _prec, f) {\n  while(true) {\n    var prec = _prec;\n    var cellX = _cellX;\n    if (!cellX) {\n      return false;\n    }\n    var t = cellX.tl;\n    var h = cellX.hd;\n    if (f(h[0], x)) {\n      prec.tl = t;\n      return true;\n    }\n    var next = {\n      hd: h,\n      tl: /* [] */0\n    };\n    prec.tl = next;\n    _prec = next;\n    _cellX = t;\n    continue ;\n  };\n}\n\nfunction setAssocAuxWithMap(_cellX, x, k, _prec, eq) {\n  while(true) {\n    var prec = _prec;\n    var cellX = _cellX;\n    if (!cellX) {\n      return false;\n    }\n    var t = cellX.tl;\n    var h = cellX.hd;\n    if (eq(h[0], x)) {\n      prec.tl = {\n        hd: [\n          x,\n          k\n        ],\n        tl: t\n      };\n      return true;\n    }\n    var next = {\n      hd: h,\n      tl: /* [] */0\n    };\n    prec.tl = next;\n    _prec = next;\n    _cellX = t;\n    continue ;\n  };\n}\n\nfunction copyAuxWithMap(_cellX, _prec, f) {\n  while(true) {\n    var prec = _prec;\n    var cellX = _cellX;\n    if (!cellX) {\n      return ;\n    }\n    var next = {\n      hd: f(cellX.hd),\n      tl: /* [] */0\n    };\n    prec.tl = next;\n    _prec = next;\n    _cellX = cellX.tl;\n    continue ;\n  };\n}\n\nfunction zipAux(_cellX, _cellY, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cellY = _cellY;\n    var cellX = _cellX;\n    if (!cellX) {\n      return ;\n    }\n    if (!cellY) {\n      return ;\n    }\n    var next = {\n      hd: [\n        cellX.hd,\n        cellY.hd\n      ],\n      tl: /* [] */0\n    };\n    prec.tl = next;\n    _prec = next;\n    _cellY = cellY.tl;\n    _cellX = cellX.tl;\n    continue ;\n  };\n}\n\nfunction copyAuxWithMap2(f, _cellX, _cellY, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cellY = _cellY;\n    var cellX = _cellX;\n    if (!cellX) {\n      return ;\n    }\n    if (!cellY) {\n      return ;\n    }\n    var next = {\n      hd: f(cellX.hd, cellY.hd),\n      tl: /* [] */0\n    };\n    prec.tl = next;\n    _prec = next;\n    _cellY = cellY.tl;\n    _cellX = cellX.tl;\n    continue ;\n  };\n}\n\nfunction copyAuxWithMapI(f, _i, _cellX, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cellX = _cellX;\n    var i = _i;\n    if (!cellX) {\n      return ;\n    }\n    var next = {\n      hd: f(i, cellX.hd),\n      tl: /* [] */0\n    };\n    prec.tl = next;\n    _prec = next;\n    _cellX = cellX.tl;\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction takeAux(_n, _cell, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cell = _cell;\n    var n = _n;\n    if (n === 0) {\n      return true;\n    }\n    if (!cell) {\n      return false;\n    }\n    var cell$1 = {\n      hd: cell.hd,\n      tl: /* [] */0\n    };\n    prec.tl = cell$1;\n    _prec = cell$1;\n    _cell = cell.tl;\n    _n = n - 1 | 0;\n    continue ;\n  };\n}\n\nfunction splitAtAux(_n, _cell, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cell = _cell;\n    var n = _n;\n    if (n === 0) {\n      return cell;\n    }\n    if (!cell) {\n      return ;\n    }\n    var cell$1 = {\n      hd: cell.hd,\n      tl: /* [] */0\n    };\n    prec.tl = cell$1;\n    _prec = cell$1;\n    _cell = cell.tl;\n    _n = n - 1 | 0;\n    continue ;\n  };\n}\n\nfunction take(lst, n) {\n  if (n < 0) {\n    return ;\n  }\n  if (n === 0) {\n    return /* [] */0;\n  }\n  if (!lst) {\n    return ;\n  }\n  var cell = {\n    hd: lst.hd,\n    tl: /* [] */0\n  };\n  var has = takeAux(n - 1 | 0, lst.tl, cell);\n  if (has) {\n    return cell;\n  }\n  \n}\n\nfunction drop(lst, n) {\n  if (n < 0) {\n    return ;\n  } else {\n    var _l = lst;\n    var _n = n;\n    while(true) {\n      var n$1 = _n;\n      var l = _l;\n      if (n$1 === 0) {\n        return l;\n      }\n      if (!l) {\n        return ;\n      }\n      _n = n$1 - 1 | 0;\n      _l = l.tl;\n      continue ;\n    };\n  }\n}\n\nfunction splitAt(lst, n) {\n  if (n < 0) {\n    return ;\n  }\n  if (n === 0) {\n    return [\n            /* [] */0,\n            lst\n          ];\n  }\n  if (!lst) {\n    return ;\n  }\n  var cell = {\n    hd: lst.hd,\n    tl: /* [] */0\n  };\n  var rest = splitAtAux(n - 1 | 0, lst.tl, cell);\n  if (rest !== undefined) {\n    return [\n            cell,\n            rest\n          ];\n  }\n  \n}\n\nfunction concat(xs, ys) {\n  if (!xs) {\n    return ys;\n  }\n  var cell = {\n    hd: xs.hd,\n    tl: /* [] */0\n  };\n  copyAuxCont(xs.tl, cell).tl = ys;\n  return cell;\n}\n\nfunction mapU(xs, f) {\n  if (!xs) {\n    return /* [] */0;\n  }\n  var cell = {\n    hd: f(xs.hd),\n    tl: /* [] */0\n  };\n  copyAuxWithMap(xs.tl, cell, f);\n  return cell;\n}\n\nfunction map(xs, f) {\n  return mapU(xs, Curry.__1(f));\n}\n\nfunction zipByU(l1, l2, f) {\n  if (!l1) {\n    return /* [] */0;\n  }\n  if (!l2) {\n    return /* [] */0;\n  }\n  var cell = {\n    hd: f(l1.hd, l2.hd),\n    tl: /* [] */0\n  };\n  copyAuxWithMap2(f, l1.tl, l2.tl, cell);\n  return cell;\n}\n\nfunction zipBy(l1, l2, f) {\n  return zipByU(l1, l2, Curry.__2(f));\n}\n\nfunction mapWithIndexU(xs, f) {\n  if (!xs) {\n    return /* [] */0;\n  }\n  var cell = {\n    hd: f(0, xs.hd),\n    tl: /* [] */0\n  };\n  copyAuxWithMapI(f, 1, xs.tl, cell);\n  return cell;\n}\n\nfunction mapWithIndex(xs, f) {\n  return mapWithIndexU(xs, Curry.__2(f));\n}\n\nfunction makeByU(n, f) {\n  if (n <= 0) {\n    return /* [] */0;\n  }\n  var headX = {\n    hd: f(0),\n    tl: /* [] */0\n  };\n  var cur = headX;\n  var i = 1;\n  while(i < n) {\n    var v = {\n      hd: f(i),\n      tl: /* [] */0\n    };\n    cur.tl = v;\n    cur = v;\n    i = i + 1 | 0;\n  };\n  return headX;\n}\n\nfunction makeBy(n, f) {\n  return makeByU(n, Curry.__1(f));\n}\n\nfunction make(n, v) {\n  if (n <= 0) {\n    return /* [] */0;\n  }\n  var headX = {\n    hd: v,\n    tl: /* [] */0\n  };\n  var cur = headX;\n  var i = 1;\n  while(i < n) {\n    var v$1 = {\n      hd: v,\n      tl: /* [] */0\n    };\n    cur.tl = v$1;\n    cur = v$1;\n    i = i + 1 | 0;\n  };\n  return headX;\n}\n\nfunction length(xs) {\n  var _x = xs;\n  var _acc = 0;\n  while(true) {\n    var acc = _acc;\n    var x = _x;\n    if (!x) {\n      return acc;\n    }\n    _acc = acc + 1 | 0;\n    _x = x.tl;\n    continue ;\n  };\n}\n\nfunction fillAux(arr, _i, _x) {\n  while(true) {\n    var x = _x;\n    var i = _i;\n    if (!x) {\n      return ;\n    }\n    arr[i] = x.hd;\n    _x = x.tl;\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction fromArray(a) {\n  var _i = a.length - 1 | 0;\n  var _res = /* [] */0;\n  while(true) {\n    var res = _res;\n    var i = _i;\n    if (i < 0) {\n      return res;\n    }\n    _res = {\n      hd: a[i],\n      tl: res\n    };\n    _i = i - 1 | 0;\n    continue ;\n  };\n}\n\nfunction toArray(x) {\n  var len = length(x);\n  var arr = new Array(len);\n  fillAux(arr, 0, x);\n  return arr;\n}\n\nfunction shuffle(xs) {\n  var v = toArray(xs);\n  Belt_Array.shuffleInPlace(v);\n  return fromArray(v);\n}\n\nfunction reverseConcat(_l1, _l2) {\n  while(true) {\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      return l2;\n    }\n    _l2 = {\n      hd: l1.hd,\n      tl: l2\n    };\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction reverse(l) {\n  return reverseConcat(l, /* [] */0);\n}\n\nfunction flattenAux(_prec, _xs) {\n  while(true) {\n    var xs = _xs;\n    var prec = _prec;\n    if (xs) {\n      _xs = xs.tl;\n      _prec = copyAuxCont(xs.hd, prec);\n      continue ;\n    }\n    prec.tl = /* [] */0;\n    return ;\n  };\n}\n\nfunction flatten(_xs) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return /* [] */0;\n    }\n    var match = xs.hd;\n    if (match) {\n      var cell = {\n        hd: match.hd,\n        tl: /* [] */0\n      };\n      flattenAux(copyAuxCont(match.tl, cell), xs.tl);\n      return cell;\n    }\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction concatMany(xs) {\n  var len = xs.length;\n  if (len === 1) {\n    return xs[0];\n  }\n  if (len === 0) {\n    return /* [] */0;\n  }\n  var len$1 = xs.length;\n  var v = xs[len$1 - 1 | 0];\n  for(var i = len$1 - 2 | 0; i >= 0; --i){\n    v = concat(xs[i], v);\n  }\n  return v;\n}\n\nfunction mapReverseU(l, f) {\n  var _accu = /* [] */0;\n  var _xs = l;\n  while(true) {\n    var xs = _xs;\n    var accu = _accu;\n    if (!xs) {\n      return accu;\n    }\n    _xs = xs.tl;\n    _accu = {\n      hd: f(xs.hd),\n      tl: accu\n    };\n    continue ;\n  };\n}\n\nfunction mapReverse(l, f) {\n  return mapReverseU(l, Curry.__1(f));\n}\n\nfunction forEachU(_xs, f) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return ;\n    }\n    f(xs.hd);\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction forEach(xs, f) {\n  return forEachU(xs, Curry.__1(f));\n}\n\nfunction forEachWithIndexU(l, f) {\n  var _xs = l;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    var xs = _xs;\n    if (!xs) {\n      return ;\n    }\n    f(i, xs.hd);\n    _i = i + 1 | 0;\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction forEachWithIndex(l, f) {\n  return forEachWithIndexU(l, Curry.__2(f));\n}\n\nfunction reduceU(_l, _accu, f) {\n  while(true) {\n    var accu = _accu;\n    var l = _l;\n    if (!l) {\n      return accu;\n    }\n    _accu = f(accu, l.hd);\n    _l = l.tl;\n    continue ;\n  };\n}\n\nfunction reduce(l, accu, f) {\n  return reduceU(l, accu, Curry.__2(f));\n}\n\nfunction reduceReverseUnsafeU(l, accu, f) {\n  if (l) {\n    return f(reduceReverseUnsafeU(l.tl, accu, f), l.hd);\n  } else {\n    return accu;\n  }\n}\n\nfunction reduceReverseU(l, acc, f) {\n  var len = length(l);\n  if (len < 1000) {\n    return reduceReverseUnsafeU(l, acc, f);\n  } else {\n    return Belt_Array.reduceReverseU(toArray(l), acc, f);\n  }\n}\n\nfunction reduceReverse(l, accu, f) {\n  return reduceReverseU(l, accu, Curry.__2(f));\n}\n\nfunction reduceWithIndexU(l, acc, f) {\n  var _l = l;\n  var _acc = acc;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    var acc$1 = _acc;\n    var l$1 = _l;\n    if (!l$1) {\n      return acc$1;\n    }\n    _i = i + 1 | 0;\n    _acc = f(acc$1, l$1.hd, i);\n    _l = l$1.tl;\n    continue ;\n  };\n}\n\nfunction reduceWithIndex(l, acc, f) {\n  return reduceWithIndexU(l, acc, Curry.__3(f));\n}\n\nfunction mapReverse2U(l1, l2, f) {\n  var _l1 = l1;\n  var _l2 = l2;\n  var _accu = /* [] */0;\n  while(true) {\n    var accu = _accu;\n    var l2$1 = _l2;\n    var l1$1 = _l1;\n    if (!l1$1) {\n      return accu;\n    }\n    if (!l2$1) {\n      return accu;\n    }\n    _accu = {\n      hd: f(l1$1.hd, l2$1.hd),\n      tl: accu\n    };\n    _l2 = l2$1.tl;\n    _l1 = l1$1.tl;\n    continue ;\n  };\n}\n\nfunction mapReverse2(l1, l2, f) {\n  return mapReverse2U(l1, l2, Curry.__2(f));\n}\n\nfunction forEach2U(_l1, _l2, f) {\n  while(true) {\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      return ;\n    }\n    if (!l2) {\n      return ;\n    }\n    f(l1.hd, l2.hd);\n    _l2 = l2.tl;\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction forEach2(l1, l2, f) {\n  return forEach2U(l1, l2, Curry.__2(f));\n}\n\nfunction reduce2U(_l1, _l2, _accu, f) {\n  while(true) {\n    var accu = _accu;\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      return accu;\n    }\n    if (!l2) {\n      return accu;\n    }\n    _accu = f(accu, l1.hd, l2.hd);\n    _l2 = l2.tl;\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction reduce2(l1, l2, acc, f) {\n  return reduce2U(l1, l2, acc, Curry.__3(f));\n}\n\nfunction reduceReverse2UnsafeU(l1, l2, accu, f) {\n  if (l1 && l2) {\n    return f(reduceReverse2UnsafeU(l1.tl, l2.tl, accu, f), l1.hd, l2.hd);\n  } else {\n    return accu;\n  }\n}\n\nfunction reduceReverse2U(l1, l2, acc, f) {\n  var len = length(l1);\n  if (len < 1000) {\n    return reduceReverse2UnsafeU(l1, l2, acc, f);\n  } else {\n    return Belt_Array.reduceReverse2U(toArray(l1), toArray(l2), acc, f);\n  }\n}\n\nfunction reduceReverse2(l1, l2, acc, f) {\n  return reduceReverse2U(l1, l2, acc, Curry.__3(f));\n}\n\nfunction everyU(_xs, p) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return true;\n    }\n    if (!p(xs.hd)) {\n      return false;\n    }\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction every(xs, p) {\n  return everyU(xs, Curry.__1(p));\n}\n\nfunction someU(_xs, p) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return false;\n    }\n    if (p(xs.hd)) {\n      return true;\n    }\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction some(xs, p) {\n  return someU(xs, Curry.__1(p));\n}\n\nfunction every2U(_l1, _l2, p) {\n  while(true) {\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      return true;\n    }\n    if (!l2) {\n      return true;\n    }\n    if (!p(l1.hd, l2.hd)) {\n      return false;\n    }\n    _l2 = l2.tl;\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction every2(l1, l2, p) {\n  return every2U(l1, l2, Curry.__2(p));\n}\n\nfunction cmpByLength(_l1, _l2) {\n  while(true) {\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      if (l2) {\n        return -1;\n      } else {\n        return 0;\n      }\n    }\n    if (!l2) {\n      return 1;\n    }\n    _l2 = l2.tl;\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction cmpU(_l1, _l2, p) {\n  while(true) {\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      if (l2) {\n        return -1;\n      } else {\n        return 0;\n      }\n    }\n    if (!l2) {\n      return 1;\n    }\n    var c = p(l1.hd, l2.hd);\n    if (c !== 0) {\n      return c;\n    }\n    _l2 = l2.tl;\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction cmp(l1, l2, f) {\n  return cmpU(l1, l2, Curry.__2(f));\n}\n\nfunction eqU(_l1, _l2, p) {\n  while(true) {\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      if (l2) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n    if (!l2) {\n      return false;\n    }\n    if (!p(l1.hd, l2.hd)) {\n      return false;\n    }\n    _l2 = l2.tl;\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction eq(l1, l2, f) {\n  return eqU(l1, l2, Curry.__2(f));\n}\n\nfunction some2U(_l1, _l2, p) {\n  while(true) {\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      return false;\n    }\n    if (!l2) {\n      return false;\n    }\n    if (p(l1.hd, l2.hd)) {\n      return true;\n    }\n    _l2 = l2.tl;\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction some2(l1, l2, p) {\n  return some2U(l1, l2, Curry.__2(p));\n}\n\nfunction hasU(_xs, x, eq) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return false;\n    }\n    if (eq(xs.hd, x)) {\n      return true;\n    }\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction has(xs, x, eq) {\n  return hasU(xs, x, Curry.__2(eq));\n}\n\nfunction getAssocU(_xs, x, eq) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return ;\n    }\n    var match = xs.hd;\n    if (eq(match[0], x)) {\n      return Caml_option.some(match[1]);\n    }\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction getAssoc(xs, x, eq) {\n  return getAssocU(xs, x, Curry.__2(eq));\n}\n\nfunction hasAssocU(_xs, x, eq) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return false;\n    }\n    if (eq(xs.hd[0], x)) {\n      return true;\n    }\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction hasAssoc(xs, x, eq) {\n  return hasAssocU(xs, x, Curry.__2(eq));\n}\n\nfunction removeAssocU(xs, x, eq) {\n  if (!xs) {\n    return /* [] */0;\n  }\n  var l = xs.tl;\n  var pair = xs.hd;\n  if (eq(pair[0], x)) {\n    return l;\n  }\n  var cell = {\n    hd: pair,\n    tl: /* [] */0\n  };\n  var removed = removeAssocAuxWithMap(l, x, cell, eq);\n  if (removed) {\n    return cell;\n  } else {\n    return xs;\n  }\n}\n\nfunction removeAssoc(xs, x, eq) {\n  return removeAssocU(xs, x, Curry.__2(eq));\n}\n\nfunction setAssocU(xs, x, k, eq) {\n  if (!xs) {\n    return {\n            hd: [\n              x,\n              k\n            ],\n            tl: /* [] */0\n          };\n  }\n  var l = xs.tl;\n  var pair = xs.hd;\n  if (eq(pair[0], x)) {\n    return {\n            hd: [\n              x,\n              k\n            ],\n            tl: l\n          };\n  }\n  var cell = {\n    hd: pair,\n    tl: /* [] */0\n  };\n  var replaced = setAssocAuxWithMap(l, x, k, cell, eq);\n  if (replaced) {\n    return cell;\n  } else {\n    return {\n            hd: [\n              x,\n              k\n            ],\n            tl: xs\n          };\n  }\n}\n\nfunction setAssoc(xs, x, k, eq) {\n  return setAssocU(xs, x, k, Curry.__2(eq));\n}\n\nfunction sortU(xs, cmp) {\n  var arr = toArray(xs);\n  Belt_SortArray.stableSortInPlaceByU(arr, cmp);\n  return fromArray(arr);\n}\n\nfunction sort(xs, cmp) {\n  return sortU(xs, Curry.__2(cmp));\n}\n\nfunction getByU(_xs, p) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return ;\n    }\n    var x = xs.hd;\n    if (p(x)) {\n      return Caml_option.some(x);\n    }\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction getBy(xs, p) {\n  return getByU(xs, Curry.__1(p));\n}\n\nfunction keepU(_xs, p) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return /* [] */0;\n    }\n    var t = xs.tl;\n    var h = xs.hd;\n    if (p(h)) {\n      var cell = {\n        hd: h,\n        tl: /* [] */0\n      };\n      copyAuxWitFilter(p, t, cell);\n      return cell;\n    }\n    _xs = t;\n    continue ;\n  };\n}\n\nfunction keep(xs, p) {\n  return keepU(xs, Curry.__1(p));\n}\n\nfunction keepWithIndexU(xs, p) {\n  var _xs = xs;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    var xs$1 = _xs;\n    if (!xs$1) {\n      return /* [] */0;\n    }\n    var t = xs$1.tl;\n    var h = xs$1.hd;\n    if (p(h, i)) {\n      var cell = {\n        hd: h,\n        tl: /* [] */0\n      };\n      copyAuxWithFilterIndex(p, t, cell, i + 1 | 0);\n      return cell;\n    }\n    _i = i + 1 | 0;\n    _xs = t;\n    continue ;\n  };\n}\n\nfunction keepWithIndex(xs, p) {\n  return keepWithIndexU(xs, Curry.__2(p));\n}\n\nfunction keepMapU(_xs, p) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return /* [] */0;\n    }\n    var t = xs.tl;\n    var h = p(xs.hd);\n    if (h !== undefined) {\n      var cell = {\n        hd: Caml_option.valFromOption(h),\n        tl: /* [] */0\n      };\n      copyAuxWitFilterMap(p, t, cell);\n      return cell;\n    }\n    _xs = t;\n    continue ;\n  };\n}\n\nfunction keepMap(xs, p) {\n  return keepMapU(xs, Curry.__1(p));\n}\n\nfunction partitionU(l, p) {\n  if (!l) {\n    return [\n            /* [] */0,\n            /* [] */0\n          ];\n  }\n  var h = l.hd;\n  var nextX = {\n    hd: h,\n    tl: /* [] */0\n  };\n  var nextY = {\n    hd: h,\n    tl: /* [] */0\n  };\n  var b = p(h);\n  partitionAux(p, l.tl, nextX, nextY);\n  if (b) {\n    return [\n            nextX,\n            nextY.tl\n          ];\n  } else {\n    return [\n            nextX.tl,\n            nextY\n          ];\n  }\n}\n\nfunction partition(l, p) {\n  return partitionU(l, Curry.__1(p));\n}\n\nfunction unzip(xs) {\n  if (!xs) {\n    return [\n            /* [] */0,\n            /* [] */0\n          ];\n  }\n  var match = xs.hd;\n  var cellX = {\n    hd: match[0],\n    tl: /* [] */0\n  };\n  var cellY = {\n    hd: match[1],\n    tl: /* [] */0\n  };\n  splitAux(xs.tl, cellX, cellY);\n  return [\n          cellX,\n          cellY\n        ];\n}\n\nfunction zip(l1, l2) {\n  if (!l1) {\n    return /* [] */0;\n  }\n  if (!l2) {\n    return /* [] */0;\n  }\n  var cell = {\n    hd: [\n      l1.hd,\n      l2.hd\n    ],\n    tl: /* [] */0\n  };\n  zipAux(l1.tl, l2.tl, cell);\n  return cell;\n}\n\nvar size = length;\n\nvar filter = keep;\n\nvar filterWithIndex = keepWithIndex;\n\nexport {\n  length ,\n  size ,\n  head ,\n  headExn ,\n  tail ,\n  tailExn ,\n  add ,\n  get ,\n  getExn ,\n  make ,\n  makeByU ,\n  makeBy ,\n  shuffle ,\n  drop ,\n  take ,\n  splitAt ,\n  concat ,\n  concatMany ,\n  reverseConcat ,\n  flatten ,\n  mapU ,\n  map ,\n  zip ,\n  zipByU ,\n  zipBy ,\n  mapWithIndexU ,\n  mapWithIndex ,\n  fromArray ,\n  toArray ,\n  reverse ,\n  mapReverseU ,\n  mapReverse ,\n  forEachU ,\n  forEach ,\n  forEachWithIndexU ,\n  forEachWithIndex ,\n  reduceU ,\n  reduce ,\n  reduceWithIndexU ,\n  reduceWithIndex ,\n  reduceReverseU ,\n  reduceReverse ,\n  mapReverse2U ,\n  mapReverse2 ,\n  forEach2U ,\n  forEach2 ,\n  reduce2U ,\n  reduce2 ,\n  reduceReverse2U ,\n  reduceReverse2 ,\n  everyU ,\n  every ,\n  someU ,\n  some ,\n  every2U ,\n  every2 ,\n  some2U ,\n  some2 ,\n  cmpByLength ,\n  cmpU ,\n  cmp ,\n  eqU ,\n  eq ,\n  hasU ,\n  has ,\n  getByU ,\n  getBy ,\n  keepU ,\n  keep ,\n  filter ,\n  keepWithIndexU ,\n  keepWithIndex ,\n  filterWithIndex ,\n  keepMapU ,\n  keepMap ,\n  partitionU ,\n  partition ,\n  unzip ,\n  getAssocU ,\n  getAssoc ,\n  hasAssocU ,\n  hasAssoc ,\n  removeAssocU ,\n  removeAssoc ,\n  setAssocU ,\n  setAssoc ,\n  sortU ,\n  sort ,\n  \n}\n/* No side effect */\n","\n\n\nvar id = {\n  contents: 0\n};\n\nfunction create(str) {\n  id.contents = id.contents + 1 | 0;\n  return str + (\"/\" + id.contents);\n}\n\nfunction caml_is_extension(e) {\n  if (e == null) {\n    return false;\n  } else {\n    return typeof e.RE_EXN_ID === \"string\";\n  }\n}\n\nfunction caml_exn_slot_name(x) {\n  return x.RE_EXN_ID;\n}\n\nexport {\n  id ,\n  create ,\n  caml_is_extension ,\n  caml_exn_slot_name ,\n  \n}\n/* No side effect */\n","// Generated by ReScript, PLEASE EDIT WITH CARE\n\nimport * as Belt_List from \"bs-platform/lib/es6/belt_List.js\";\nimport * as Caml_option from \"bs-platform/lib/es6/caml_option.js\";\n\nfunction map(param, f) {\n  return /* NonEmpty */{\n          _0: f(param._0),\n          _1: Belt_List.mapU(param._1, f)\n        };\n}\n\nfunction toList(param) {\n  return {\n          hd: param._0,\n          tl: param._1\n        };\n}\n\nvar NonEmpty = {\n  map: map,\n  toList: toList\n};\n\nvar identifierChar = /^[a-zA-Z0-9_]$/;\n\nfunction isEndOfIdentifier(s) {\n  return !identifierChar.test(s);\n}\n\nvar identifierStartChar = /^[a-z_]$/;\n\nfunction isValidIdentifierStart(c) {\n  return identifierStartChar.test(c);\n}\n\nvar componentStart = /^[A-Z]$/;\n\nfunction isValidComponentStart(c) {\n  return componentStart.test(c);\n}\n\nfunction isReservedKeyword(s) {\n  switch (s) {\n    case \"false\" :\n    case \"null\" :\n    case \"true\" :\n        return true;\n    default:\n      return false;\n  }\n}\n\nvar bindingRegEx = /^[a-z_][a-zA-Z0-9_]*$/;\n\nfunction isLegalBinding(x) {\n  if (bindingRegEx.test(x)) {\n    return !isReservedKeyword(x);\n  } else {\n    return false;\n  }\n}\n\nvar RegEx = {\n  isEndOfIdentifier: isEndOfIdentifier,\n  isValidIdentifierStart: isValidIdentifierStart,\n  isValidComponentStart: isValidComponentStart,\n  isLegalBinding: isLegalBinding\n};\n\nfunction $$location(x) {\n  return {\n          character: x + 1 | 0\n        };\n}\n\nfunction nameToJson(x) {\n  if (typeof x === \"number\") {\n    if (x === /* Match */0) {\n      return \"match\";\n    } else {\n      return \"map\";\n    }\n  }\n  switch (x.TAG | 0) {\n    case /* Component */0 :\n        var x$1 = x._0;\n        if (x$1 !== undefined) {\n          return x$1;\n        } else {\n          return null;\n        }\n    case /* Section */1 :\n        return \"section: \" + x.component + \"#\" + x.section;\n    case /* Index */2 :\n        return x._0;\n    \n  }\n}\n\nvar Stack = {\n  nameToJson: nameToJson\n};\n\nvar Errors = {\n  $$location: $$location,\n  Stack: Stack\n};\n\nvar Result = {};\n\nfunction toString(x) {\n  switch (x.TAG | 0) {\n    case /* Text */0 :\n        return \"[text]: \" + x._1;\n    case /* Comment */1 :\n        return \"{*\" + x._1 + \"*}\";\n    case /* String */2 :\n        return \"\\\"\" + x._1 + \"\\\"\";\n    case /* Number */3 :\n        return String(x._1);\n    case /* Comma */4 :\n        return \",\";\n    case /* Colon */5 :\n        return \":\";\n    case /* OpenBracket */6 :\n        return \"[\";\n    case /* CloseBracket */7 :\n        return \"]\";\n    case /* OpenBrace */8 :\n        return \"{\";\n    case /* CloseBrace */9 :\n        return \"}\";\n    case /* Spread */10 :\n        return \"...\";\n    case /* Slash */12 :\n        return \"/\";\n    case /* Block */13 :\n        return \"#\";\n    case /* Equals */14 :\n        return \"=\";\n    case /* ComponentName */11 :\n    case /* Identifier */15 :\n        return x._1;\n    case /* Tilde */16 :\n        return \"~\";\n    case /* Question */17 :\n        return \"?\";\n    case /* Echo */18 :\n        return \"{{\";\n    case /* EndOfExpression */19 :\n        return x._1 + \"}\";\n    case /* EndOfFile */20 :\n        return \"[end of file]\";\n    \n  }\n}\n\nfunction toLocation(x) {\n  return x._0;\n}\n\nvar Token = {\n  toString: toString,\n  toLocation: toLocation\n};\n\nfunction toString$1(x) {\n  switch (x.TAG | 0) {\n    case /* Null */0 :\n        return \"null\";\n    case /* False */1 :\n    case /* True */2 :\n        return \"boolean\";\n    case /* String */3 :\n        return \"string\";\n    case /* Number */4 :\n        return \"number\";\n    case /* Array */5 :\n    case /* ArrayWithTailBinding */6 :\n        return \"array\";\n    case /* Object */7 :\n        return \"object\";\n    case /* Binding */8 :\n        return \"binding: `\" + x._1 + \"`\";\n    \n  }\n}\n\nfunction toLocation$1(x) {\n  if (x.TAG === /* ArrayWithTailBinding */6) {\n    return x.loc;\n  } else {\n    return x._0;\n  }\n}\n\nvar Pattern_Ast = {\n  toString: toString$1,\n  toLocation: toLocation$1\n};\n\nfunction make(x) {\n  return {\n          data: x,\n          acutis_is_valid: \"ACUTIS_IS_VALID\"\n        };\n}\n\nfunction validate(x) {\n  if (x.acutis_is_valid === \"ACUTIS_IS_VALID\") {\n    return Caml_option.some(x.data);\n  }\n  \n}\n\nvar Valid = {\n  make: make,\n  validate: validate\n};\n\nvar Echo = {};\n\nvar Ast = {\n  Echo: Echo\n};\n\nexport {\n  NonEmpty ,\n  RegEx ,\n  Errors ,\n  Result ,\n  Token ,\n  Pattern_Ast ,\n  Valid ,\n  Ast ,\n  \n}\n/* No side effect */\n","// Generated by ReScript, PLEASE EDIT WITH CARE\n\nimport * as Belt_List from \"bs-platform/lib/es6/belt_List.js\";\nimport * as Caml_option from \"bs-platform/lib/es6/caml_option.js\";\nimport * as Caml_exceptions from \"bs-platform/lib/es6/caml_exceptions.js\";\nimport * as Acutis_Types$AcutisLang from \"./Acutis_Types.bs.js\";\n\nfunction stackToPath(x) {\n  return Belt_List.toArray(Belt_List.mapU(x, Acutis_Types$AcutisLang.Errors.Stack.nameToJson));\n}\n\nvar CompileError = Caml_exceptions.create(\"Debug-AcutisLang.CompileError\");\n\nfunction unexpectedEoF(loc, name) {\n  return {\n          message: \"Unexpected end of file.\",\n          kind: \"Syntax\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: [name !== undefined ? name : null],\n          exn: undefined\n        };\n}\n\nfunction unterminatedComment(loc, name) {\n  return {\n          message: \"Unterminated comment.\",\n          kind: \"Syntax\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: [name !== undefined ? name : null],\n          exn: undefined\n        };\n}\n\nfunction unterminatedString(loc, name) {\n  return {\n          message: \"Unterminated string.\",\n          kind: \"Syntax\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: [name !== undefined ? name : null],\n          exn: undefined\n        };\n}\n\nfunction illegalIdentifier(loc, name, identifier) {\n  return {\n          message: \"\\\"\" + identifier + \"\\\" is an illegal identifier name.\",\n          kind: \"Parse\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: [name !== undefined ? name : null],\n          exn: undefined\n        };\n}\n\nfunction invalidCharacter(loc, name, character) {\n  return {\n          message: \"Invalid character: \\\"\" + character + \"\\\".\",\n          kind: \"Syntax\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: [name !== undefined ? name : null],\n          exn: undefined\n        };\n}\n\nfunction unexpectedCharacter(loc, name, character, expected) {\n  return {\n          message: \"Unexpected character: \\\"\" + character + \"\\\". Expected: \\\"\" + expected + \"\\\".\",\n          kind: \"Syntax\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: [name !== undefined ? name : null],\n          exn: undefined\n        };\n}\n\nfunction unexpectedToken(token, name) {\n  var $$location = Acutis_Types$AcutisLang.Errors.$$location(Acutis_Types$AcutisLang.Token.toLocation(token));\n  var token$1 = Acutis_Types$AcutisLang.Token.toString(token);\n  return {\n          message: \"Unexpected token: \\\"\" + token$1 + \"\\\".\",\n          kind: \"Parse\",\n          location: $$location,\n          path: [name !== undefined ? name : null],\n          exn: undefined\n        };\n}\n\nfunction illegalBindingName(loc, name, binding) {\n  return {\n          message: \"\\\"\" + binding + \"\\\" is a reserved name\",\n          kind: \"Parse\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: [name !== undefined ? name : null],\n          exn: undefined\n        };\n}\n\nfunction jsonTaggedTToString(x) {\n  if (typeof x === \"number\") {\n    switch (x) {\n      case /* JSONFalse */0 :\n      case /* JSONTrue */1 :\n          return \"boolean\";\n      case /* JSONNull */2 :\n          return \"null\";\n      \n    }\n  } else {\n    switch (x.TAG | 0) {\n      case /* JSONString */0 :\n          return \"string\";\n      case /* JSONNumber */1 :\n          return \"number\";\n      case /* JSONObject */2 :\n          return \"object\";\n      case /* JSONArray */3 :\n          return \"array\";\n      \n    }\n  }\n}\n\nfunction componentDoesNotExist(loc, component, stack) {\n  return {\n          message: \"Component \\\"\" + component + \"\\\" does not exist.\",\n          kind: \"Render\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nfunction patternTypeMismatch(data, pattern, stack) {\n  var data$1 = jsonTaggedTToString(data);\n  var type_ = Acutis_Types$AcutisLang.Pattern_Ast.toString(pattern);\n  return {\n          message: \"This pattern is type \" + type_ + \" but the data is type \" + data$1 + \".\",\n          kind: \"Type\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(Acutis_Types$AcutisLang.Pattern_Ast.toLocation(pattern)),\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nfunction bindingTypeMismatch(data, pattern, binding, stack) {\n  var data$1 = jsonTaggedTToString(data);\n  var loc = Acutis_Types$AcutisLang.Pattern_Ast.toLocation(pattern);\n  var pattern$1 = Acutis_Types$AcutisLang.Pattern_Ast.toString(pattern);\n  return {\n          message: \"\\\"\" + binding + \"\\\" is type \" + pattern$1 + \" but the data is type \" + data$1 + \".\",\n          kind: \"Type\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nfunction nameBoundMultipleTimes(loc, binding, stack) {\n  return {\n          message: \"\\\"\" + binding + \"\\\" is bound multiple times in this pattern.\",\n          kind: \"Pattern\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nfunction noMatchFound(loc, stack) {\n  return {\n          message: \"None of the patterns match the data. Consider a catch-all case to avoid this.\",\n          kind: \"Pattern\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nfunction patternNumberMismatch(loc, stack) {\n  return {\n          message: \"The number of patterns does not match the number of data.\",\n          kind: \"Pattern\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nfunction badEchoType(loc, binding, type_, stack) {\n  var type_$1 = jsonTaggedTToString(type_);\n  return {\n          message: \"\\\"\" + binding + \"\\\" is type \" + type_$1 + \". I can only echo strings and numbers.\",\n          kind: \"Render\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nfunction bindingDoesNotExist(loc, binding, stack) {\n  return {\n          message: \"Binding \\\"\" + binding + \"\\\" does not exist.\",\n          kind: \"Render\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nfunction childDoesNotExist(loc, child, stack) {\n  return {\n          message: \"Template child \\\"\" + child + \"\\\" does not exist.\",\n          kind: \"Render\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nfunction badMapType(loc, binding, type_, stack) {\n  var type_$1 = jsonTaggedTToString(type_);\n  return {\n          message: \"\\\"\" + binding + \"\\\" is a \" + type_$1 + \". I can only map arrays.\",\n          kind: \"Type\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nfunction invalidInput(stack) {\n  return {\n          message: \"A template AST was not valid. Did you forget to compile one?\",\n          kind: \"Render\",\n          location: undefined,\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nfunction compileExn(e, name) {\n  return {\n          message: \"An exception was thrown while rendering this template. This is probably due to malformed input.\",\n          kind: \"Compile\",\n          location: undefined,\n          path: [name !== undefined ? name : null],\n          exn: Caml_option.some(e)\n        };\n}\n\nfunction componentExn(e, stack) {\n  return {\n          message: \"An exception was thrown while rendering a template component.\",\n          kind: \"Render\",\n          location: undefined,\n          path: stackToPath(stack),\n          exn: Caml_option.some(e)\n        };\n}\n\nfunction customError(message, stack) {\n  return {\n          message: message,\n          kind: \"Render\",\n          location: undefined,\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nexport {\n  stackToPath ,\n  CompileError ,\n  unexpectedEoF ,\n  unterminatedComment ,\n  unterminatedString ,\n  illegalIdentifier ,\n  invalidCharacter ,\n  unexpectedCharacter ,\n  unexpectedToken ,\n  illegalBindingName ,\n  jsonTaggedTToString ,\n  componentDoesNotExist ,\n  patternTypeMismatch ,\n  bindingTypeMismatch ,\n  nameBoundMultipleTimes ,\n  noMatchFound ,\n  patternNumberMismatch ,\n  badEchoType ,\n  bindingDoesNotExist ,\n  childDoesNotExist ,\n  badMapType ,\n  invalidInput ,\n  compileExn ,\n  componentExn ,\n  customError ,\n  \n}\n/* No side effect */\n","\n\nimport * as Curry from \"./curry.js\";\nimport * as Caml_option from \"./caml_option.js\";\n\nfunction make(param) {\n  return {\n          length: 0,\n          first: undefined,\n          last: undefined\n        };\n}\n\nfunction clear(q) {\n  q.length = 0;\n  q.first = undefined;\n  q.last = undefined;\n  \n}\n\nfunction add(q, x) {\n  var cell = {\n    content: x,\n    next: undefined\n  };\n  var last = q.last;\n  if (last !== undefined) {\n    q.length = q.length + 1 | 0;\n    last.next = cell;\n    q.last = cell;\n  } else {\n    q.length = 1;\n    q.first = cell;\n    q.last = cell;\n  }\n  \n}\n\nfunction peek(q) {\n  var v = q.first;\n  if (v !== undefined) {\n    return Caml_option.some(v.content);\n  }\n  \n}\n\nfunction peekUndefined(q) {\n  var v = q.first;\n  if (v !== undefined) {\n    return v.content;\n  }\n  \n}\n\nfunction peekExn(q) {\n  var v = q.first;\n  if (v !== undefined) {\n    return v.content;\n  }\n  throw {\n        RE_EXN_ID: \"Not_found\",\n        Error: new Error()\n      };\n}\n\nfunction pop(q) {\n  var x = q.first;\n  if (x === undefined) {\n    return ;\n  }\n  var next = x.next;\n  if (next === undefined) {\n    clear(q);\n    return Caml_option.some(x.content);\n  } else {\n    q.length = q.length - 1 | 0;\n    q.first = next;\n    return Caml_option.some(x.content);\n  }\n}\n\nfunction popExn(q) {\n  var x = q.first;\n  if (x !== undefined) {\n    var next = x.next;\n    if (next === undefined) {\n      clear(q);\n      return x.content;\n    } else {\n      q.length = q.length - 1 | 0;\n      q.first = next;\n      return x.content;\n    }\n  }\n  throw {\n        RE_EXN_ID: \"Not_found\",\n        Error: new Error()\n      };\n}\n\nfunction popUndefined(q) {\n  var x = q.first;\n  if (x === undefined) {\n    return ;\n  }\n  var next = x.next;\n  if (next === undefined) {\n    clear(q);\n    return x.content;\n  } else {\n    q.length = q.length - 1 | 0;\n    q.first = next;\n    return x.content;\n  }\n}\n\nfunction copy(q) {\n  var qRes = {\n    length: q.length,\n    first: undefined,\n    last: undefined\n  };\n  var _prev;\n  var _cell = q.first;\n  while(true) {\n    var cell = _cell;\n    var prev = _prev;\n    if (cell !== undefined) {\n      var content = cell.content;\n      var res = {\n        content: content,\n        next: undefined\n      };\n      if (prev !== undefined) {\n        prev.next = res;\n      } else {\n        qRes.first = res;\n      }\n      _cell = cell.next;\n      _prev = res;\n      continue ;\n    }\n    qRes.last = prev;\n    return qRes;\n  };\n}\n\nfunction mapU(q, f) {\n  var qRes = {\n    length: q.length,\n    first: undefined,\n    last: undefined\n  };\n  var _prev;\n  var _cell = q.first;\n  while(true) {\n    var cell = _cell;\n    var prev = _prev;\n    if (cell !== undefined) {\n      var content = f(cell.content);\n      var res = {\n        content: content,\n        next: undefined\n      };\n      if (prev !== undefined) {\n        prev.next = res;\n      } else {\n        qRes.first = res;\n      }\n      _cell = cell.next;\n      _prev = res;\n      continue ;\n    }\n    qRes.last = prev;\n    return qRes;\n  };\n}\n\nfunction map(q, f) {\n  return mapU(q, Curry.__1(f));\n}\n\nfunction isEmpty(q) {\n  return q.length === 0;\n}\n\nfunction size(q) {\n  return q.length;\n}\n\nfunction forEachU(q, f) {\n  var _cell = q.first;\n  while(true) {\n    var cell = _cell;\n    if (cell === undefined) {\n      return ;\n    }\n    f(cell.content);\n    _cell = cell.next;\n    continue ;\n  };\n}\n\nfunction forEach(q, f) {\n  return forEachU(q, Curry.__1(f));\n}\n\nfunction reduceU(q, accu, f) {\n  var _accu = accu;\n  var _cell = q.first;\n  while(true) {\n    var cell = _cell;\n    var accu$1 = _accu;\n    if (cell === undefined) {\n      return accu$1;\n    }\n    var accu$2 = f(accu$1, cell.content);\n    _cell = cell.next;\n    _accu = accu$2;\n    continue ;\n  };\n}\n\nfunction reduce(q, accu, f) {\n  return reduceU(q, accu, Curry.__2(f));\n}\n\nfunction transfer(q1, q2) {\n  if (q1.length <= 0) {\n    return ;\n  }\n  var l = q2.last;\n  if (l !== undefined) {\n    q2.length = q2.length + q1.length | 0;\n    l.next = q1.first;\n    q2.last = q1.last;\n    return clear(q1);\n  } else {\n    q2.length = q1.length;\n    q2.first = q1.first;\n    q2.last = q1.last;\n    return clear(q1);\n  }\n}\n\nfunction fillAux(_i, arr, _cell) {\n  while(true) {\n    var cell = _cell;\n    var i = _i;\n    if (cell === undefined) {\n      return ;\n    }\n    arr[i] = cell.content;\n    _cell = cell.next;\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction toArray(x) {\n  var v = new Array(x.length);\n  fillAux(0, v, x.first);\n  return v;\n}\n\nfunction fromArray(arr) {\n  var q = {\n    length: 0,\n    first: undefined,\n    last: undefined\n  };\n  for(var i = 0 ,i_finish = arr.length; i < i_finish; ++i){\n    add(q, arr[i]);\n  }\n  return q;\n}\n\nexport {\n  make ,\n  clear ,\n  isEmpty ,\n  fromArray ,\n  add ,\n  peek ,\n  peekUndefined ,\n  peekExn ,\n  pop ,\n  popUndefined ,\n  popExn ,\n  copy ,\n  size ,\n  mapU ,\n  map ,\n  forEachU ,\n  forEach ,\n  reduceU ,\n  reduce ,\n  transfer ,\n  toArray ,\n  \n}\n/* No side effect */\n","// Generated by ReScript, PLEASE EDIT WITH CARE\n\nimport * as Belt_Float from \"bs-platform/lib/es6/belt_Float.js\";\nimport * as Debug$AcutisLang from \"./Debug.bs.js\";\nimport * as Belt_MutableQueue from \"bs-platform/lib/es6/belt_MutableQueue.js\";\nimport * as Acutis_Types$AcutisLang from \"./Acutis_Types.bs.js\";\n\nfunction peekCharAt(source, x) {\n  return source.str.charAt(source.position + x | 0);\n}\n\nfunction peekChar(source) {\n  return source.str.charAt(source.position);\n}\n\nfunction skipChar(source) {\n  source.position = source.position + 1 | 0;\n  \n}\n\nfunction readChar(source) {\n  var c = peekChar(source);\n  skipChar(source);\n  return c;\n}\n\nfunction peek(source, until) {\n  var position = source.position;\n  while(!until(source.str.charAt(position))) {\n    position = position + 1 | 0;\n  };\n  return position;\n}\n\nfunction skipBy(source, x) {\n  source.position = source.position + x | 0;\n  \n}\n\nfunction readSubstring(source, until) {\n  var start = source.position;\n  var end = peek(source, until);\n  source.position = end;\n  return source.str.slice(start, end);\n}\n\nfunction readSubstringBy(source, x) {\n  var start = source.position;\n  source.position = source.position + x | 0;\n  return source.str.slice(start, source.position);\n}\n\nfunction endOfNumber(c) {\n  switch (c) {\n    case \"+\" :\n    case \"-\" :\n    case \".\" :\n    case \"0\" :\n    case \"1\" :\n    case \"2\" :\n    case \"3\" :\n    case \"4\" :\n    case \"5\" :\n    case \"6\" :\n    case \"7\" :\n    case \"8\" :\n    case \"9\" :\n    case \"E\" :\n    case \"e\" :\n        return false;\n    default:\n      return true;\n  }\n}\n\nfunction readText(source, tokens) {\n  var loc = source.position;\n  var _position = 0;\n  while(true) {\n    var position = _position;\n    var match = peekCharAt(source, position);\n    switch (match) {\n      case \"\" :\n          Belt_MutableQueue.add(tokens, {\n                TAG: /* Text */0,\n                _0: loc,\n                _1: readSubstringBy(source, position)\n              });\n          return /* EndMode */3;\n      case \"{\" :\n          var match$1 = peekCharAt(source, position + 1 | 0);\n          switch (match$1) {\n            case \"%\" :\n                Belt_MutableQueue.add(tokens, {\n                      TAG: /* Text */0,\n                      _0: loc,\n                      _1: readSubstringBy(source, position)\n                    });\n                skipBy(source, 2);\n                return /* ExpressionMode */1;\n            case \"*\" :\n                Belt_MutableQueue.add(tokens, {\n                      TAG: /* Text */0,\n                      _0: loc,\n                      _1: readSubstringBy(source, position)\n                    });\n                skipBy(source, 2);\n                return /* CommentMode */2;\n            case \"{\" :\n                Belt_MutableQueue.add(tokens, {\n                      TAG: /* Text */0,\n                      _0: loc,\n                      _1: readSubstringBy(source, position)\n                    });\n                skipBy(source, 2);\n                return /* EchoMode */0;\n            default:\n              _position = position + 2 | 0;\n              continue ;\n          }\n      default:\n        _position = position + 1 | 0;\n        continue ;\n    }\n  };\n}\n\nfunction readComment(source, name) {\n  var loc = source.position;\n  var _position = 0;\n  var _nested = 0;\n  while(true) {\n    var nested = _nested;\n    var position = _position;\n    var match = peekCharAt(source, position);\n    switch (match) {\n      case \"\" :\n          throw {\n                RE_EXN_ID: Debug$AcutisLang.CompileError,\n                _1: Debug$AcutisLang.unterminatedComment(loc, name),\n                Error: new Error()\n              };\n      case \"*\" :\n          var match$1 = peekCharAt(source, position + 1 | 0);\n          if (match$1 === \"}\") {\n            if (nested === 0) {\n              var result = readSubstringBy(source, position);\n              skipBy(source, 2);\n              return result;\n            }\n            _nested = nested - 1 | 0;\n            _position = position + 2 | 0;\n            continue ;\n          }\n          _position = position + 2 | 0;\n          continue ;\n      case \"{\" :\n          var match$2 = peekCharAt(source, position + 1 | 0);\n          if (match$2 === \"*\") {\n            _nested = nested + 1 | 0;\n            _position = position + 2 | 0;\n            continue ;\n          }\n          _position = position + 1 | 0;\n          continue ;\n      default:\n        _position = position + 1 | 0;\n        continue ;\n    }\n  };\n}\n\nvar unescapeQuotes = /\\\\\"/g;\n\nfunction readJsonString(source, name) {\n  var loc = source.position;\n  var _position = 0;\n  while(true) {\n    var position = _position;\n    var match = peekCharAt(source, position);\n    switch (match) {\n      case \"\" :\n          throw {\n                RE_EXN_ID: Debug$AcutisLang.CompileError,\n                _1: Debug$AcutisLang.unterminatedString(loc, name),\n                Error: new Error()\n              };\n      case \"\\\"\" :\n          var result = readSubstringBy(source, position).replace(unescapeQuotes, \"\\\"\");\n          skipChar(source);\n          return result;\n      case \"\\\\\" :\n          var match$1 = peekCharAt(source, position + 1 | 0);\n          switch (match$1) {\n            case \"\\\"\" :\n            case \"\\\\\" :\n                _position = position + 2 | 0;\n                continue ;\n            default:\n              _position = position + 1 | 0;\n              continue ;\n          }\n      default:\n        _position = position + 1 | 0;\n        continue ;\n    }\n  };\n}\n\nfunction readNumber(source, name) {\n  var loc = source.position;\n  var num = readSubstring(source, endOfNumber);\n  var num$1 = Belt_Float.fromString(num);\n  if (num$1 !== undefined) {\n    return num$1;\n  }\n  throw {\n        RE_EXN_ID: Debug$AcutisLang.CompileError,\n        _1: Debug$AcutisLang.illegalIdentifier(loc, name, num),\n        Error: new Error()\n      };\n}\n\nfunction makeExpression(source, tokens, name, until) {\n  var loop = true;\n  while(loop) {\n    var loc = source.position;\n    var c = peekChar(source);\n    var exit = 0;\n    if (c === until) {\n      skipChar(source);\n      Belt_MutableQueue.add(tokens, {\n            TAG: /* EndOfExpression */19,\n            _0: loc,\n            _1: until\n          });\n      loop = false;\n    } else {\n      switch (c) {\n        case \"\" :\n            throw {\n                  RE_EXN_ID: Debug$AcutisLang.CompileError,\n                  _1: Debug$AcutisLang.unexpectedEoF(loc, name),\n                  Error: new Error()\n                };\n        case \"\\t\" :\n        case \"\\n\" :\n        case \"\\r\" :\n        case \" \" :\n            skipChar(source);\n            break;\n        case \"\\\"\" :\n            skipChar(source);\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* String */2,\n                  _0: loc,\n                  _1: readJsonString(source, name)\n                });\n            break;\n        case \"#\" :\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* Block */13,\n                  _0: loc\n                });\n            skipChar(source);\n            break;\n        case \",\" :\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* Comma */4,\n                  _0: loc\n                });\n            skipChar(source);\n            break;\n        case \".\" :\n            var c$1 = readSubstringBy(source, 3);\n            if (c$1 === \"...\") {\n              Belt_MutableQueue.add(tokens, {\n                    TAG: /* Spread */10,\n                    _0: loc\n                  });\n            } else {\n              throw {\n                    RE_EXN_ID: Debug$AcutisLang.CompileError,\n                    _1: Debug$AcutisLang.unexpectedCharacter(loc, name, c$1, \"...\"),\n                    Error: new Error()\n                  };\n            }\n            break;\n        case \"/\" :\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* Slash */12,\n                  _0: loc\n                });\n            skipChar(source);\n            break;\n        case \"-\" :\n        case \"0\" :\n        case \"1\" :\n        case \"2\" :\n        case \"3\" :\n        case \"4\" :\n        case \"5\" :\n        case \"6\" :\n        case \"7\" :\n        case \"8\" :\n        case \"9\" :\n            exit = 1;\n            break;\n        case \":\" :\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* Colon */5,\n                  _0: loc\n                });\n            skipChar(source);\n            break;\n        case \"=\" :\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* Equals */14,\n                  _0: loc\n                });\n            skipChar(source);\n            break;\n        case \"?\" :\n            skipChar(source);\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* Question */17,\n                  _0: loc\n                });\n            break;\n        case \"[\" :\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* OpenBracket */6,\n                  _0: loc\n                });\n            skipChar(source);\n            break;\n        case \"]\" :\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* CloseBracket */7,\n                  _0: loc\n                });\n            skipChar(source);\n            break;\n        case \"{\" :\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* OpenBrace */8,\n                  _0: loc\n                });\n            skipChar(source);\n            break;\n        case \"}\" :\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* CloseBrace */9,\n                  _0: loc\n                });\n            skipChar(source);\n            break;\n        case \"~\" :\n            skipChar(source);\n            var c$2 = peekChar(source);\n            if (c$2 === until) {\n              skipChar(source);\n              Belt_MutableQueue.add(tokens, {\n                    TAG: /* EndOfExpression */19,\n                    _0: loc,\n                    _1: until\n                  });\n              Belt_MutableQueue.add(tokens, {\n                    TAG: /* Tilde */16,\n                    _0: loc\n                  });\n              loop = false;\n            } else {\n              Belt_MutableQueue.add(tokens, {\n                    TAG: /* Tilde */16,\n                    _0: loc\n                  });\n            }\n            break;\n        default:\n          if (Acutis_Types$AcutisLang.RegEx.isValidIdentifierStart(c)) {\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* Identifier */15,\n                  _0: loc,\n                  _1: readSubstring(source, Acutis_Types$AcutisLang.RegEx.isEndOfIdentifier)\n                });\n          } else if (Acutis_Types$AcutisLang.RegEx.isValidComponentStart(c)) {\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* ComponentName */11,\n                  _0: loc,\n                  _1: readSubstring(source, Acutis_Types$AcutisLang.RegEx.isEndOfIdentifier)\n                });\n          } else {\n            throw {\n                  RE_EXN_ID: Debug$AcutisLang.CompileError,\n                  _1: Debug$AcutisLang.invalidCharacter(loc, name, c),\n                  Error: new Error()\n                };\n          }\n      }\n    }\n    if (exit === 1) {\n      Belt_MutableQueue.add(tokens, {\n            TAG: /* Number */3,\n            _0: loc,\n            _1: readNumber(source, name)\n          });\n    }\n    \n  };\n  \n}\n\nfunction make(name, str) {\n  var source = {\n    str: str,\n    position: 0\n  };\n  var tokens = Belt_MutableQueue.make(undefined);\n  var _mode = readText(source, tokens);\n  while(true) {\n    var mode = _mode;\n    switch (mode) {\n      case /* EchoMode */0 :\n          var echoLoc = source.position;\n          if (peekChar(source) === \"~\") {\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* Tilde */16,\n                  _0: source.position\n                });\n            skipChar(source);\n          }\n          Belt_MutableQueue.add(tokens, {\n                TAG: /* Echo */18,\n                _0: echoLoc\n              });\n          makeExpression(source, tokens, name, \"}\");\n          var c = readChar(source);\n          if (c === \"}\") {\n            _mode = readText(source, tokens);\n            continue ;\n          }\n          throw {\n                RE_EXN_ID: Debug$AcutisLang.CompileError,\n                _1: Debug$AcutisLang.unexpectedCharacter(source.position, name, c, \"}\"),\n                Error: new Error()\n              };\n      case /* ExpressionMode */1 :\n          makeExpression(source, tokens, name, \"%\");\n          var c$1 = readChar(source);\n          if (c$1 === \"}\") {\n            _mode = readText(source, tokens);\n            continue ;\n          }\n          throw {\n                RE_EXN_ID: Debug$AcutisLang.CompileError,\n                _1: Debug$AcutisLang.unexpectedCharacter(source.position, name, c$1, \"}\"),\n                Error: new Error()\n              };\n      case /* CommentMode */2 :\n          var loc = source.position;\n          Belt_MutableQueue.add(tokens, {\n                TAG: /* Comment */1,\n                _0: loc,\n                _1: readComment(source, name)\n              });\n          _mode = readText(source, tokens);\n          continue ;\n      case /* EndMode */3 :\n          Belt_MutableQueue.add(tokens, {\n                TAG: /* EndOfFile */20,\n                _0: source.position\n              });\n          return {\n                  tokens: tokens,\n                  name: name\n                };\n      \n    }\n  };\n}\n\nfunction peekExn(x) {\n  return Belt_MutableQueue.peekExn(x.tokens);\n}\n\nfunction popExn(x) {\n  return Belt_MutableQueue.popExn(x.tokens);\n}\n\nfunction name(x) {\n  return x.name;\n}\n\nfunction debugToArray(x) {\n  return Belt_MutableQueue.toArray(x.tokens);\n}\n\nexport {\n  make ,\n  peekExn ,\n  popExn ,\n  name ,\n  debugToArray ,\n  \n}\n/* No side effect */\n","\n\n\nfunction fromString(i) {\n  var i$1 = parseFloat(i);\n  if (isNaN(i$1)) {\n    return ;\n  } else {\n    return i$1;\n  }\n}\n\nexport {\n  fromString ,\n  \n}\n/* No side effect */\n","\n\nimport * as Caml_option from \"./caml_option.js\";\nimport * as Caml_exceptions from \"./caml_exceptions.js\";\n\nvar $$Error = Caml_exceptions.create(\"Caml_js_exceptions.Error\");\n\nfunction internalToOCamlException(e) {\n  if (Caml_exceptions.caml_is_extension(e)) {\n    return e;\n  } else {\n    return {\n            RE_EXN_ID: $$Error,\n            _1: e\n          };\n  }\n}\n\nfunction caml_as_js_exn(exn) {\n  if (exn.RE_EXN_ID === $$Error) {\n    return Caml_option.some(exn._1);\n  }\n  \n}\n\nexport {\n  $$Error ,\n  internalToOCamlException ,\n  caml_as_js_exn ,\n  \n}\n/* No side effect */\n","// Generated by ReScript, PLEASE EDIT WITH CARE\n\nimport * as Belt_List from \"bs-platform/lib/es6/belt_List.js\";\nimport * as Debug$AcutisLang from \"./Debug.bs.js\";\nimport * as Lexer$AcutisLang from \"./Lexer.bs.js\";\nimport * as Caml_js_exceptions from \"bs-platform/lib/es6/caml_js_exceptions.js\";\nimport * as Acutis_Types$AcutisLang from \"./Acutis_Types.bs.js\";\n\nfunction unexpectedToken(token, tokens) {\n  throw {\n        RE_EXN_ID: Debug$AcutisLang.CompileError,\n        _1: Debug$AcutisLang.unexpectedToken(token, Lexer$AcutisLang.name(tokens)),\n        Error: new Error()\n      };\n}\n\nfunction parseNode(t, tokens) {\n  switch (t.TAG | 0) {\n    case /* String */2 :\n        return {\n                TAG: /* String */3,\n                _0: t._0,\n                _1: t._1\n              };\n    case /* Number */3 :\n        return {\n                TAG: /* Number */4,\n                _0: t._0,\n                _1: t._1\n              };\n    case /* OpenBracket */6 :\n        var loc = t._0;\n        var t$1 = Lexer$AcutisLang.popExn(tokens);\n        if (t$1.TAG === /* CloseBracket */7) {\n          return {\n                  TAG: /* Array */5,\n                  _0: loc,\n                  _1: /* [] */0\n                };\n        }\n        var head = parseNode(t$1, tokens);\n        var _valueList = {\n          hd: head,\n          tl: /* [] */0\n        };\n        while(true) {\n          var valueList = _valueList;\n          var t$2 = Lexer$AcutisLang.popExn(tokens);\n          switch (t$2.TAG | 0) {\n            case /* Comma */4 :\n                var t$3 = Lexer$AcutisLang.popExn(tokens);\n                switch (t$3.TAG | 0) {\n                  case /* Spread */10 :\n                      var match = Lexer$AcutisLang.popExn(tokens);\n                      var match$1 = Lexer$AcutisLang.popExn(tokens);\n                      if (match.TAG === /* Identifier */15) {\n                        if (match$1.TAG === /* CloseBracket */7) {\n                          return {\n                                  TAG: /* ArrayWithTailBinding */6,\n                                  loc: loc,\n                                  array: Belt_List.reverse(valueList),\n                                  bindLoc: match._0,\n                                  binding: match._1\n                                };\n                        } else {\n                          return unexpectedToken(match$1, tokens);\n                        }\n                      } else {\n                        return unexpectedToken(match, tokens);\n                      }\n                  case /* String */2 :\n                  case /* Number */3 :\n                  case /* OpenBracket */6 :\n                  case /* OpenBrace */8 :\n                  case /* Identifier */15 :\n                      break;\n                  default:\n                    return unexpectedToken(t$3, tokens);\n                }\n                var item = parseNode(t$3, tokens);\n                _valueList = {\n                  hd: item,\n                  tl: valueList\n                };\n                continue ;\n            case /* CloseBracket */7 :\n                return {\n                        TAG: /* Array */5,\n                        _0: loc,\n                        _1: Belt_List.reverse(valueList)\n                      };\n            default:\n              return unexpectedToken(t$2, tokens);\n          }\n        };\n    case /* OpenBrace */8 :\n        var loc$1 = t._0;\n        var t$4 = Lexer$AcutisLang.popExn(tokens);\n        if (t$4.TAG === /* CloseBrace */9) {\n          return {\n                  TAG: /* Object */7,\n                  _0: loc$1,\n                  _1: /* [] */0\n                };\n        }\n        var head$1 = parseObjectKeyValue(t$4, tokens);\n        var _l = {\n          hd: head$1,\n          tl: /* [] */0\n        };\n        while(true) {\n          var l = _l;\n          var t$5 = Lexer$AcutisLang.popExn(tokens);\n          switch (t$5.TAG | 0) {\n            case /* Comma */4 :\n                var x = parseObjectKeyValue(Lexer$AcutisLang.popExn(tokens), tokens);\n                _l = {\n                  hd: x,\n                  tl: l\n                };\n                continue ;\n            case /* CloseBrace */9 :\n                return {\n                        TAG: /* Object */7,\n                        _0: loc$1,\n                        _1: Belt_List.reverse(l)\n                      };\n            default:\n              return unexpectedToken(t$5, tokens);\n          }\n        };\n    case /* Identifier */15 :\n        var x$1 = t._1;\n        var loc$2 = t._0;\n        switch (x$1) {\n          case \"false\" :\n              return {\n                      TAG: /* False */1,\n                      _0: loc$2\n                    };\n          case \"null\" :\n              return {\n                      TAG: /* Null */0,\n                      _0: loc$2\n                    };\n          case \"true\" :\n              return {\n                      TAG: /* True */2,\n                      _0: loc$2\n                    };\n          default:\n            return {\n                    TAG: /* Binding */8,\n                    _0: loc$2,\n                    _1: x$1\n                  };\n        }\n    default:\n      return unexpectedToken(t, tokens);\n  }\n}\n\nfunction parseObjectKeyValue(t, tokens) {\n  switch (t.TAG | 0) {\n    case /* String */2 :\n    case /* Identifier */15 :\n        break;\n    default:\n      return unexpectedToken(t, tokens);\n  }\n  var key = t._1;\n  var loc = t._0;\n  var match = Lexer$AcutisLang.peekExn(tokens);\n  if (match.TAG === /* Colon */5) {\n    Lexer$AcutisLang.popExn(tokens);\n    var value = parseNode(Lexer$AcutisLang.popExn(tokens), tokens);\n    return [\n            key,\n            value\n          ];\n  }\n  if (Acutis_Types$AcutisLang.RegEx.isLegalBinding(key)) {\n    return [\n            key,\n            {\n              TAG: /* Binding */8,\n              _0: loc,\n              _1: key\n            }\n          ];\n  }\n  throw {\n        RE_EXN_ID: Debug$AcutisLang.CompileError,\n        _1: Debug$AcutisLang.illegalIdentifier(loc, Lexer$AcutisLang.name(tokens), key),\n        Error: new Error()\n      };\n}\n\nfunction make(tokens) {\n  var head = parseNode(Lexer$AcutisLang.popExn(tokens), tokens);\n  var _l = /* [] */0;\n  while(true) {\n    var l = _l;\n    var match = Lexer$AcutisLang.peekExn(tokens);\n    if (match.TAG !== /* Comma */4) {\n      return /* NonEmpty */{\n              _0: head,\n              _1: Belt_List.reverse(l)\n            };\n    }\n    Lexer$AcutisLang.popExn(tokens);\n    _l = {\n      hd: parseNode(Lexer$AcutisLang.popExn(tokens), tokens),\n      tl: l\n    };\n    continue ;\n  };\n}\n\nfunction parseBindingName(tokens) {\n  var t = Lexer$AcutisLang.popExn(tokens);\n  if (t.TAG !== /* Identifier */15) {\n    return unexpectedToken(t, tokens);\n  }\n  var x = t._1;\n  var loc = t._0;\n  if (Acutis_Types$AcutisLang.RegEx.isLegalBinding(x)) {\n    return [\n            loc,\n            x\n          ];\n  }\n  throw {\n        RE_EXN_ID: Debug$AcutisLang.CompileError,\n        _1: Debug$AcutisLang.illegalBindingName(loc, Lexer$AcutisLang.name(tokens), x),\n        Error: new Error()\n      };\n}\n\nfunction parseCommaSequence(tokens) {\n  var head = parseBindingName(tokens);\n  var _l = /* [] */0;\n  while(true) {\n    var l = _l;\n    var match = Lexer$AcutisLang.peekExn(tokens);\n    if (match.TAG !== /* Comma */4) {\n      return /* NonEmpty */{\n              _0: head,\n              _1: Belt_List.reverse(l)\n            };\n    }\n    Lexer$AcutisLang.popExn(tokens);\n    _l = {\n      hd: parseBindingName(tokens),\n      tl: l\n    };\n    continue ;\n  };\n}\n\nfunction parseEcho(tokens) {\n  var t = Lexer$AcutisLang.popExn(tokens);\n  switch (t.TAG | 0) {\n    case /* String */2 :\n        return {\n                TAG: /* String */2,\n                _0: t._1\n              };\n    case /* Number */3 :\n        return {\n                TAG: /* Number */3,\n                _0: t._1\n              };\n    case /* ComponentName */11 :\n        return {\n                TAG: /* Child */1,\n                _0: t._0,\n                _1: t._1\n              };\n    case /* Identifier */15 :\n        var x = t._1;\n        var loc = t._0;\n        if (Acutis_Types$AcutisLang.RegEx.isLegalBinding(x)) {\n          return {\n                  TAG: /* Binding */0,\n                  _0: loc,\n                  _1: x\n                };\n        }\n        throw {\n              RE_EXN_ID: Debug$AcutisLang.CompileError,\n              _1: Debug$AcutisLang.illegalBindingName(loc, Lexer$AcutisLang.name(tokens), x),\n              Error: new Error()\n            };\n    default:\n      return unexpectedToken(t, tokens);\n  }\n}\n\nfunction parseEchoes(tokens) {\n  var head = parseEcho(tokens);\n  var _l = /* [] */0;\n  while(true) {\n    var l = _l;\n    var t = Lexer$AcutisLang.popExn(tokens);\n    switch (t.TAG | 0) {\n      case /* Question */17 :\n          _l = {\n            hd: parseEcho(tokens),\n            tl: l\n          };\n          continue ;\n      case /* EndOfExpression */19 :\n          return /* NonEmpty */{\n                  _0: head,\n                  _1: Belt_List.reverse(l)\n                };\n      default:\n        return unexpectedToken(t, tokens);\n    }\n  };\n}\n\nfunction endOfMatchMap(t) {\n  switch (t.TAG | 0) {\n    case /* Slash */12 :\n        return true;\n    case /* Identifier */15 :\n        if (t._1 === \"with\") {\n          return true;\n        } else {\n          return false;\n        }\n    default:\n      return false;\n  }\n}\n\nfunction endOfFile(t) {\n  if (t.TAG === /* EndOfFile */20) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction slash(t) {\n  if (t.TAG === /* Slash */12) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction parse(t, tokens, until) {\n  var _t = t;\n  var _l = /* [] */0;\n  while(true) {\n    var l = _l;\n    var t$1 = _t;\n    if (until(t$1)) {\n      return [\n              t$1,\n              Belt_List.reverse(l)\n            ];\n    }\n    switch (t$1.TAG | 0) {\n      case /* Text */0 :\n          var x = t$1._1;\n          var t$2 = Lexer$AcutisLang.popExn(tokens);\n          if (t$2.TAG === /* Tilde */16) {\n            _l = {\n              hd: {\n                TAG: /* Text */0,\n                _0: x,\n                _1: /* TrimEnd */1\n              },\n              tl: l\n            };\n            _t = Lexer$AcutisLang.popExn(tokens);\n            continue ;\n          }\n          _l = {\n            hd: {\n              TAG: /* Text */0,\n              _0: x,\n              _1: /* NoTrim */3\n            },\n            tl: l\n          };\n          _t = t$2;\n          continue ;\n      case /* ComponentName */11 :\n          _l = {\n            hd: parseComponent(t$1._0, t$1._1, tokens),\n            tl: l\n          };\n          _t = Lexer$AcutisLang.popExn(tokens);\n          continue ;\n      case /* Identifier */15 :\n          var loc = t$1._0;\n          switch (t$1._1) {\n            case \"map\" :\n                var match = parseBindingName(tokens);\n                var withs = parseWithBlocks(tokens, \"map\");\n                _l = {\n                  hd: {\n                    TAG: /* Map */4,\n                    _0: match[0],\n                    _1: match[1],\n                    _2: withs\n                  },\n                  tl: l\n                };\n                _t = Lexer$AcutisLang.popExn(tokens);\n                continue ;\n            case \"match\" :\n                var identifiers = parseCommaSequence(tokens);\n                var withs$1 = parseWithBlocks(tokens, \"match\");\n                _l = {\n                  hd: {\n                    TAG: /* Match */3,\n                    _0: loc,\n                    _1: identifiers,\n                    _2: withs$1\n                  },\n                  tl: l\n                };\n                _t = Lexer$AcutisLang.popExn(tokens);\n                continue ;\n            case \"raw\" :\n                _l = {\n                  hd: {\n                    TAG: /* Unescaped */2,\n                    _0: loc,\n                    _1: parseEchoes(tokens)\n                  },\n                  tl: l\n                };\n                _t = Lexer$AcutisLang.popExn(tokens);\n                continue ;\n            default:\n              return unexpectedToken(t$1, tokens);\n          }\n      case /* Tilde */16 :\n          var t$3 = Lexer$AcutisLang.popExn(tokens);\n          if (t$3.TAG !== /* Text */0) {\n            return unexpectedToken(t$3, tokens);\n          }\n          var x$1 = t$3._1;\n          var t$4 = Lexer$AcutisLang.popExn(tokens);\n          if (t$4.TAG === /* Tilde */16) {\n            _l = {\n              hd: {\n                TAG: /* Text */0,\n                _0: x$1,\n                _1: /* TrimBoth */2\n              },\n              tl: l\n            };\n            _t = Lexer$AcutisLang.popExn(tokens);\n            continue ;\n          }\n          _l = {\n            hd: {\n              TAG: /* Text */0,\n              _0: x$1,\n              _1: /* TrimStart */0\n            },\n            tl: l\n          };\n          _t = t$4;\n          continue ;\n      case /* Echo */18 :\n          _l = {\n            hd: {\n              TAG: /* Echo */1,\n              _0: t$1._0,\n              _1: parseEchoes(tokens)\n            },\n            tl: l\n          };\n          _t = Lexer$AcutisLang.popExn(tokens);\n          continue ;\n      case /* Comment */1 :\n      case /* EndOfExpression */19 :\n          _t = Lexer$AcutisLang.popExn(tokens);\n          continue ;\n      default:\n        return unexpectedToken(t$1, tokens);\n    }\n  };\n}\n\nfunction parseWithBlock(tokens) {\n  var head = make(tokens);\n  var _l = /* [] */0;\n  while(true) {\n    var l = _l;\n    var t = Lexer$AcutisLang.popExn(tokens);\n    if (t.TAG === /* Identifier */15 && t._1 === \"with\") {\n      _l = {\n        hd: make(tokens),\n        tl: l\n      };\n      continue ;\n    }\n    var match = parse(t, tokens, endOfMatchMap);\n    return [\n            match[0],\n            {\n              patterns: /* NonEmpty */{\n                _0: head,\n                _1: Belt_List.reverse(l)\n              },\n              ast: match[1]\n            }\n          ];\n  };\n}\n\nfunction parseWithBlocks(tokens, block) {\n  var t = Lexer$AcutisLang.popExn(tokens);\n  if (t.TAG !== /* Identifier */15) {\n    return unexpectedToken(t, tokens);\n  }\n  if (t._1 !== \"with\") {\n    return unexpectedToken(t, tokens);\n  }\n  var match = parseWithBlock(tokens);\n  var head = match[1];\n  var _t = match[0];\n  var _l = /* [] */0;\n  while(true) {\n    var l = _l;\n    var t$1 = _t;\n    if (t$1.TAG === /* Slash */12) {\n      var t$2 = Lexer$AcutisLang.popExn(tokens);\n      if (t$2.TAG === /* Identifier */15 && t$2._1 === block) {\n        return /* NonEmpty */{\n                _0: head,\n                _1: Belt_List.reverse(l)\n              };\n      } else {\n        return unexpectedToken(t$2, tokens);\n      }\n    }\n    var match$1 = parseWithBlock(tokens);\n    _l = {\n      hd: match$1[1],\n      tl: l\n    };\n    _t = match$1[0];\n    continue ;\n  };\n}\n\nfunction parseComponent(loc, name, tokens) {\n  var match = parseProps(Lexer$AcutisLang.popExn(tokens), tokens, /* [] */0, /* [] */0);\n  var children = match[2];\n  var props = match[1];\n  var t = match[0];\n  if (t.TAG === /* Slash */12) {\n    return {\n            TAG: /* Component */5,\n            loc: loc,\n            name: name,\n            props: props,\n            children: children\n          };\n  }\n  var match$1 = parse(t, tokens, slash);\n  var t$1 = Lexer$AcutisLang.popExn(tokens);\n  if (t$1.TAG === /* ComponentName */11 && name === t$1._1) {\n    return {\n            TAG: /* Component */5,\n            loc: loc,\n            name: name,\n            props: props,\n            children: {\n              hd: [\n                \"Children\",\n                {\n                  TAG: /* ChildBlock */1,\n                  _0: match$1[1]\n                }\n              ],\n              tl: children\n            }\n          };\n  } else {\n    return unexpectedToken(t$1, tokens);\n  }\n}\n\nfunction parseProps(_t, tokens, _props, _children) {\n  while(true) {\n    var children = _children;\n    var props = _props;\n    var t = _t;\n    switch (t.TAG | 0) {\n      case /* ComponentName */11 :\n          var name = t._1;\n          var t$1 = Lexer$AcutisLang.popExn(tokens);\n          if (t$1.TAG === /* Equals */14) {\n            var t$2 = Lexer$AcutisLang.popExn(tokens);\n            switch (t$2.TAG | 0) {\n              case /* ComponentName */11 :\n                  _children = {\n                    hd: [\n                      name,\n                      {\n                        TAG: /* ChildName */0,\n                        _0: t$2._1\n                      }\n                    ],\n                    tl: children\n                  };\n                  _t = Lexer$AcutisLang.popExn(tokens);\n                  continue ;\n              case /* Block */13 :\n                  var match = parse(Lexer$AcutisLang.popExn(tokens), tokens, slash);\n                  var t$3 = Lexer$AcutisLang.popExn(tokens);\n                  if (t$3.TAG !== /* Block */13) {\n                    return unexpectedToken(t$3, tokens);\n                  }\n                  _children = {\n                    hd: [\n                      name,\n                      {\n                        TAG: /* ChildBlock */1,\n                        _0: match[1]\n                      }\n                    ],\n                    tl: children\n                  };\n                  _t = Lexer$AcutisLang.popExn(tokens);\n                  continue ;\n              default:\n                return unexpectedToken(t$2, tokens);\n            }\n          } else {\n            _children = {\n              hd: [\n                name,\n                {\n                  TAG: /* ChildName */0,\n                  _0: name\n                }\n              ],\n              tl: children\n            };\n            _t = t$1;\n            continue ;\n          }\n      case /* Identifier */15 :\n          var key = t._1;\n          var t$4 = Lexer$AcutisLang.popExn(tokens);\n          if (t$4.TAG === /* Equals */14) {\n            var prop = parseNode(Lexer$AcutisLang.popExn(tokens), tokens);\n            _props = {\n              hd: [\n                key,\n                prop\n              ],\n              tl: props\n            };\n            _t = Lexer$AcutisLang.popExn(tokens);\n            continue ;\n          }\n          _props = {\n            hd: [\n              key,\n              {\n                TAG: /* Binding */8,\n                _0: t._0,\n                _1: key\n              }\n            ],\n            tl: props\n          };\n          _t = t$4;\n          continue ;\n      default:\n        return [\n                t,\n                props,\n                children\n              ];\n    }\n  };\n}\n\nfunction makeAst(name, source) {\n  try {\n    var tokens = Lexer$AcutisLang.make(name, source);\n    var match = parse(Lexer$AcutisLang.popExn(tokens), tokens, endOfFile);\n    return Acutis_Types$AcutisLang.Valid.make({\n                NAME: \"data\",\n                VAL: {\n                  ast: match[1],\n                  name: name\n                }\n              });\n  }\n  catch (raw_e){\n    var e = Caml_js_exceptions.internalToOCamlException(raw_e);\n    if (e.RE_EXN_ID === Debug$AcutisLang.CompileError) {\n      return Acutis_Types$AcutisLang.Valid.make({\n                  NAME: \"errors\",\n                  VAL: e._1\n                });\n    } else {\n      return Acutis_Types$AcutisLang.Valid.make({\n                  NAME: \"errors\",\n                  VAL: Debug$AcutisLang.compileExn(e, name)\n                });\n    }\n  }\n}\n\nfunction make$1(name, source) {\n  var ast = makeAst(name, source);\n  return function (env, props, templates) {\n    return env.render(ast, props, templates);\n  };\n}\n\nfunction makeAst$1(source, name) {\n  return makeAst(name, source);\n}\n\nfunction make$2(source, name) {\n  return make$1(name, source);\n}\n\nvar Js = {\n  makeAst: makeAst$1,\n  make: make$2\n};\n\nvar Pattern = {\n  make: make\n};\n\nexport {\n  Pattern ,\n  makeAst ,\n  make$1 as make,\n  Js ,\n  \n}\n/* No side effect */\n","\n\nimport * as Caml_option from \"./caml_option.js\";\n\nfunction get(dict, k) {\n  if ((k in dict)) {\n    return Caml_option.some(dict[k]);\n  }\n  \n}\n\nvar unsafeDeleteKey = (function (dict,key){\n      delete dict[key];\n     });\n\nfunction entries(dict) {\n  var keys = Object.keys(dict);\n  var l = keys.length;\n  var values = new Array(l);\n  for(var i = 0; i < l; ++i){\n    var key = keys[i];\n    values[i] = [\n      key,\n      dict[key]\n    ];\n  }\n  return values;\n}\n\nfunction values(dict) {\n  var keys = Object.keys(dict);\n  var l = keys.length;\n  var values$1 = new Array(l);\n  for(var i = 0; i < l; ++i){\n    values$1[i] = dict[keys[i]];\n  }\n  return values$1;\n}\n\nfunction fromList(entries) {\n  var dict = {};\n  var _param = entries;\n  while(true) {\n    var param = _param;\n    if (!param) {\n      return dict;\n    }\n    var match = param.hd;\n    dict[match[0]] = match[1];\n    _param = param.tl;\n    continue ;\n  };\n}\n\nfunction fromArray(entries) {\n  var dict = {};\n  var l = entries.length;\n  for(var i = 0; i < l; ++i){\n    var match = entries[i];\n    dict[match[0]] = match[1];\n  }\n  return dict;\n}\n\nfunction map(f, source) {\n  var target = {};\n  var keys = Object.keys(source);\n  var l = keys.length;\n  for(var i = 0; i < l; ++i){\n    var key = keys[i];\n    target[key] = f(source[key]);\n  }\n  return target;\n}\n\nexport {\n  get ,\n  unsafeDeleteKey ,\n  entries ,\n  values ,\n  fromList ,\n  fromArray ,\n  map ,\n  \n}\n/* No side effect */\n","\n\nimport * as Caml_option from \"./caml_option.js\";\n\nfunction classify(x) {\n  var ty = typeof x;\n  if (ty === \"string\") {\n    return {\n            TAG: /* JSONString */0,\n            _0: x\n          };\n  } else if (ty === \"number\") {\n    return {\n            TAG: /* JSONNumber */1,\n            _0: x\n          };\n  } else if (ty === \"boolean\") {\n    if (x === true) {\n      return /* JSONTrue */1;\n    } else {\n      return /* JSONFalse */0;\n    }\n  } else if (x === null) {\n    return /* JSONNull */2;\n  } else if (Array.isArray(x)) {\n    return {\n            TAG: /* JSONArray */3,\n            _0: x\n          };\n  } else {\n    return {\n            TAG: /* JSONObject */2,\n            _0: x\n          };\n  }\n}\n\nfunction test(x, v) {\n  switch (v) {\n    case /* String */0 :\n        return typeof x === \"string\";\n    case /* Number */1 :\n        return typeof x === \"number\";\n    case /* Object */2 :\n        if (x !== null && typeof x === \"object\") {\n          return !Array.isArray(x);\n        } else {\n          return false;\n        }\n    case /* Array */3 :\n        return Array.isArray(x);\n    case /* Boolean */4 :\n        return typeof x === \"boolean\";\n    case /* Null */5 :\n        return x === null;\n    \n  }\n}\n\nfunction decodeString(json) {\n  if (typeof json === \"string\") {\n    return json;\n  }\n  \n}\n\nfunction decodeNumber(json) {\n  if (typeof json === \"number\") {\n    return json;\n  }\n  \n}\n\nfunction decodeObject(json) {\n  if (typeof json === \"object\" && !Array.isArray(json) && json !== null) {\n    return Caml_option.some(json);\n  }\n  \n}\n\nfunction decodeArray(json) {\n  if (Array.isArray(json)) {\n    return json;\n  }\n  \n}\n\nfunction decodeBoolean(json) {\n  if (typeof json === \"boolean\") {\n    return json;\n  }\n  \n}\n\nfunction decodeNull(json) {\n  if (json === null) {\n    return null;\n  }\n  \n}\n\nvar patch = (function (json) {\n  var x = [json];\n  var q = [{ kind: 0, i: 0, parent: x }];\n  while (q.length !== 0) {\n    // begin pop the stack\n    var cur = q[q.length - 1];\n    if (cur.kind === 0) {\n      cur.val = cur.parent[cur.i]; // patch the undefined value for array\n      if (++cur.i === cur.parent.length) {\n        q.pop();\n      }\n    } else {\n      q.pop();\n    }\n    // finish\n    var task = cur.val;\n    if (typeof task === \"object\") {\n      if (Array.isArray(task) && task.length !== 0) {\n        q.push({ kind: 0, i: 0, parent: task, val: undefined });\n      } else {\n        for (var k in task) {\n          if (k === \"RE_PRIVATE_NONE\") {\n            if (cur.kind === 0) {\n              cur.parent[cur.i - 1] = undefined;\n            } else {\n              cur.parent[cur.i] = undefined;\n            }\n            continue;\n          }\n          q.push({ kind: 1, i: k, parent: task, val: task[k] });\n        }\n      }\n    }\n  }\n  return x[0];\n});\n\nfunction serializeExn(x) {\n  return (function(obj){\n  var output= JSON.stringify(obj,function(_,value){\n      if(value===undefined){\n          return {RE_PRIVATE_NONE : true}\n      }\n    return value\n  });\n  \n if(output === undefined){\n   // JSON.stringify will raise TypeError when it detects cylic objects\n   throw new TypeError(\"output is undefined\")\n }\n return output \n })(x);\n}\n\nfunction deserializeUnsafe(s) {\n  return patch(JSON.parse(s));\n}\n\nexport {\n  classify ,\n  test ,\n  decodeString ,\n  decodeNumber ,\n  decodeObject ,\n  decodeArray ,\n  decodeBoolean ,\n  decodeNull ,\n  deserializeUnsafe ,\n  serializeExn ,\n  \n}\n/* No side effect */\n","\n\nimport * as Curry from \"./curry.js\";\n\nfunction getExn(x) {\n  if (x.TAG === /* Ok */0) {\n    return x._0;\n  }\n  throw {\n        RE_EXN_ID: \"Not_found\",\n        Error: new Error()\n      };\n}\n\nfunction mapWithDefaultU(opt, $$default, f) {\n  if (opt.TAG === /* Ok */0) {\n    return f(opt._0);\n  } else {\n    return $$default;\n  }\n}\n\nfunction mapWithDefault(opt, $$default, f) {\n  return mapWithDefaultU(opt, $$default, Curry.__1(f));\n}\n\nfunction mapU(opt, f) {\n  if (opt.TAG === /* Ok */0) {\n    return {\n            TAG: /* Ok */0,\n            _0: f(opt._0)\n          };\n  } else {\n    return {\n            TAG: /* Error */1,\n            _0: opt._0\n          };\n  }\n}\n\nfunction map(opt, f) {\n  return mapU(opt, Curry.__1(f));\n}\n\nfunction flatMapU(opt, f) {\n  if (opt.TAG === /* Ok */0) {\n    return f(opt._0);\n  } else {\n    return {\n            TAG: /* Error */1,\n            _0: opt._0\n          };\n  }\n}\n\nfunction flatMap(opt, f) {\n  return flatMapU(opt, Curry.__1(f));\n}\n\nfunction getWithDefault(opt, $$default) {\n  if (opt.TAG === /* Ok */0) {\n    return opt._0;\n  } else {\n    return $$default;\n  }\n}\n\nfunction isOk(param) {\n  if (param.TAG === /* Ok */0) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction isError(param) {\n  if (param.TAG === /* Ok */0) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nfunction eqU(a, b, f) {\n  if (a.TAG === /* Ok */0) {\n    if (b.TAG === /* Ok */0) {\n      return f(a._0, b._0);\n    } else {\n      return false;\n    }\n  } else if (b.TAG === /* Ok */0) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nfunction eq(a, b, f) {\n  return eqU(a, b, Curry.__2(f));\n}\n\nfunction cmpU(a, b, f) {\n  if (a.TAG === /* Ok */0) {\n    if (b.TAG === /* Ok */0) {\n      return f(a._0, b._0);\n    } else {\n      return 1;\n    }\n  } else if (b.TAG === /* Ok */0) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nfunction cmp(a, b, f) {\n  return cmpU(a, b, Curry.__2(f));\n}\n\nexport {\n  getExn ,\n  mapWithDefaultU ,\n  mapWithDefault ,\n  mapU ,\n  map ,\n  flatMapU ,\n  flatMap ,\n  getWithDefault ,\n  isOk ,\n  isError ,\n  eqU ,\n  eq ,\n  cmpU ,\n  cmp ,\n  \n}\n/* No side effect */\n","// Generated by ReScript, PLEASE EDIT WITH CARE\n\nimport * as Js_dict from \"bs-platform/lib/es6/js_dict.js\";\nimport * as Js_json from \"bs-platform/lib/es6/js_json.js\";\nimport * as Belt_List from \"bs-platform/lib/es6/belt_List.js\";\nimport * as Belt_Array from \"bs-platform/lib/es6/belt_Array.js\";\nimport * as Belt_Result from \"bs-platform/lib/es6/belt_Result.js\";\nimport * as Caml_option from \"bs-platform/lib/es6/caml_option.js\";\nimport * as Debug$AcutisLang from \"./Debug.bs.js\";\nimport * as Belt_MutableQueue from \"bs-platform/lib/es6/belt_MutableQueue.js\";\nimport * as Acutis_Types$AcutisLang from \"./Acutis_Types.bs.js\";\n\nfunction listToQueueResult(l, f) {\n  var q = Belt_MutableQueue.make(undefined);\n  var _l = l;\n  while(true) {\n    var l$1 = _l;\n    if (!l$1) {\n      return {\n              TAG: /* Ok */0,\n              _0: q\n            };\n    }\n    var e = f(l$1.hd);\n    if (e.TAG !== /* Ok */0) {\n      return e;\n    }\n    Belt_MutableQueue.add(q, e._0);\n    _l = l$1.tl;\n    continue ;\n  };\n}\n\nfunction toJson(pattern, props) {\n  switch (pattern.TAG | 0) {\n    case /* Null */0 :\n        return {\n                TAG: /* Ok */0,\n                _0: null\n              };\n    case /* False */1 :\n        return {\n                TAG: /* Ok */0,\n                _0: false\n              };\n    case /* True */2 :\n        return {\n                TAG: /* Ok */0,\n                _0: true\n              };\n    case /* String */3 :\n    case /* Number */4 :\n        return {\n                TAG: /* Ok */0,\n                _0: pattern._1\n              };\n    case /* Array */5 :\n        return Belt_Result.mapU(listToQueueResult(pattern._1, (function (x) {\n                          return toJson(x, props);\n                        })), Belt_MutableQueue.toArray);\n    case /* ArrayWithTailBinding */6 :\n        var binding = pattern.binding;\n        var data = Js_dict.get(props, binding);\n        if (data === undefined) {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* BindingDoesNotExist */1,\n                    loc: pattern.bindLoc,\n                    binding: binding\n                  }\n                };\n        }\n        var binding$1 = Js_json.classify(Caml_option.valFromOption(data));\n        if (typeof binding$1 === \"number\") {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* BindingTypeMismatch */0,\n                    data: binding$1,\n                    pattern: pattern,\n                    binding: binding\n                  }\n                };\n        }\n        if (binding$1.TAG !== /* JSONArray */3) {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* BindingTypeMismatch */0,\n                    data: binding$1,\n                    pattern: pattern,\n                    binding: binding\n                  }\n                };\n        }\n        var binding$2 = binding$1._0;\n        return Belt_Result.mapU(listToQueueResult(pattern.array, (function (x) {\n                          return toJson(x, props);\n                        })), (function (q) {\n                      return Belt_Array.concat(Belt_MutableQueue.toArray(q), binding$2);\n                    }));\n    case /* Object */7 :\n        return Belt_Result.mapU(listToQueueResult(pattern._1, (function (param) {\n                          var v = toJson(param[1], props);\n                          if (v.TAG === /* Ok */0) {\n                            return {\n                                    TAG: /* Ok */0,\n                                    _0: [\n                                      param[0],\n                                      v._0\n                                    ]\n                                  };\n                          } else {\n                            return v;\n                          }\n                        })), (function (q) {\n                      var d = {};\n                      Belt_MutableQueue.forEachU(q, (function (param) {\n                              d[param[0]] = param[1];\n                              \n                            }));\n                      return d;\n                    }));\n    case /* Binding */8 :\n        var x = pattern._1;\n        var x$1 = Js_dict.get(props, x);\n        if (x$1 !== undefined) {\n          return {\n                  TAG: /* Ok */0,\n                  _0: Caml_option.valFromOption(x$1)\n                };\n        } else {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* BindingDoesNotExist */1,\n                    loc: pattern._0,\n                    binding: x\n                  }\n                };\n        }\n    \n  }\n}\n\nfunction setBinding(bindings, identifier, json, loc) {\n  if (identifier === \"_\") {\n    return {\n            TAG: /* Ok */0,\n            _0: bindings\n          };\n  }\n  var match = Js_dict.get(bindings, identifier);\n  if (match !== undefined) {\n    return {\n            TAG: /* Error */1,\n            _0: {\n              TAG: /* TooManyBindings */1,\n              loc: loc,\n              binding: identifier\n            }\n          };\n  } else {\n    bindings[identifier] = json;\n    return {\n            TAG: /* Ok */0,\n            _0: bindings\n          };\n  }\n}\n\nfunction testValue(pattern, json, bindings) {\n  var match = Js_json.classify(json);\n  switch (pattern.TAG | 0) {\n    case /* Null */0 :\n        if (typeof match === \"number\" && match >= 2) {\n          return {\n                  TAG: /* Ok */0,\n                  _0: bindings\n                };\n        } else {\n          return {\n                  TAG: /* Error */1,\n                  _0: /* NoMatch */0\n                };\n        }\n    case /* False */1 :\n        if (typeof match !== \"number\") {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* PatternTypeMismatch */0,\n                    data: match,\n                    pattern: pattern\n                  }\n                };\n        }\n        switch (match) {\n          case /* JSONFalse */0 :\n              return {\n                      TAG: /* Ok */0,\n                      _0: bindings\n                    };\n          case /* JSONTrue */1 :\n          case /* JSONNull */2 :\n              return {\n                      TAG: /* Error */1,\n                      _0: /* NoMatch */0\n                    };\n          \n        }\n    case /* True */2 :\n        if (typeof match !== \"number\") {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* PatternTypeMismatch */0,\n                    data: match,\n                    pattern: pattern\n                  }\n                };\n        }\n        switch (match) {\n          case /* JSONTrue */1 :\n              return {\n                      TAG: /* Ok */0,\n                      _0: bindings\n                    };\n          case /* JSONFalse */0 :\n          case /* JSONNull */2 :\n              return {\n                      TAG: /* Error */1,\n                      _0: /* NoMatch */0\n                    };\n          \n        }\n    case /* String */3 :\n        if (typeof match === \"number\") {\n          if (match === /* JSONNull */2) {\n            return {\n                    TAG: /* Error */1,\n                    _0: /* NoMatch */0\n                  };\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: {\n                      TAG: /* PatternTypeMismatch */0,\n                      data: match,\n                      pattern: pattern\n                    }\n                  };\n          }\n        } else if (match.TAG === /* JSONString */0) {\n          if (pattern._1 === match._0) {\n            return {\n                    TAG: /* Ok */0,\n                    _0: bindings\n                  };\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: /* NoMatch */0\n                  };\n          }\n        } else {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* PatternTypeMismatch */0,\n                    data: match,\n                    pattern: pattern\n                  }\n                };\n        }\n    case /* Number */4 :\n        if (typeof match === \"number\") {\n          if (match === /* JSONNull */2) {\n            return {\n                    TAG: /* Error */1,\n                    _0: /* NoMatch */0\n                  };\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: {\n                      TAG: /* PatternTypeMismatch */0,\n                      data: match,\n                      pattern: pattern\n                    }\n                  };\n          }\n        } else if (match.TAG === /* JSONNumber */1) {\n          if (pattern._1 === match._0) {\n            return {\n                    TAG: /* Ok */0,\n                    _0: bindings\n                  };\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: /* NoMatch */0\n                  };\n          }\n        } else {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* PatternTypeMismatch */0,\n                    data: match,\n                    pattern: pattern\n                  }\n                };\n        }\n    case /* Array */5 :\n        var x = pattern._1;\n        if (x) {\n          if (typeof match === \"number\") {\n            if (match === /* JSONNull */2) {\n              return {\n                      TAG: /* Error */1,\n                      _0: /* NoMatch */0\n                    };\n            } else {\n              return {\n                      TAG: /* Error */1,\n                      _0: {\n                        TAG: /* PatternTypeMismatch */0,\n                        data: match,\n                        pattern: pattern\n                      }\n                    };\n            }\n          } else if (match.TAG === /* JSONArray */3) {\n            return testArray(x, match._0, bindings, undefined);\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: {\n                      TAG: /* PatternTypeMismatch */0,\n                      data: match,\n                      pattern: pattern\n                    }\n                  };\n          }\n        } else if (typeof match === \"number\") {\n          if (match === /* JSONNull */2) {\n            return {\n                    TAG: /* Error */1,\n                    _0: /* NoMatch */0\n                  };\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: {\n                      TAG: /* PatternTypeMismatch */0,\n                      data: match,\n                      pattern: pattern\n                    }\n                  };\n          }\n        } else if (match.TAG === /* JSONArray */3) {\n          if (match._0.length === 0) {\n            return {\n                    TAG: /* Ok */0,\n                    _0: bindings\n                  };\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: /* NoMatch */0\n                  };\n          }\n        } else {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* PatternTypeMismatch */0,\n                    data: match,\n                    pattern: pattern\n                  }\n                };\n        }\n    case /* ArrayWithTailBinding */6 :\n        if (typeof match === \"number\") {\n          if (match === /* JSONNull */2) {\n            return {\n                    TAG: /* Error */1,\n                    _0: /* NoMatch */0\n                  };\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: {\n                      TAG: /* PatternTypeMismatch */0,\n                      data: match,\n                      pattern: pattern\n                    }\n                  };\n          }\n        } else if (match.TAG === /* JSONArray */3) {\n          return testArray(pattern.array, match._0, bindings, [\n                      pattern.bindLoc,\n                      pattern.binding\n                    ]);\n        } else {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* PatternTypeMismatch */0,\n                    data: match,\n                    pattern: pattern\n                  }\n                };\n        }\n    case /* Object */7 :\n        var x$1 = pattern._1;\n        if (x$1) {\n          if (typeof match === \"number\") {\n            if (match === /* JSONNull */2) {\n              return {\n                      TAG: /* Error */1,\n                      _0: /* NoMatch */0\n                    };\n            } else {\n              return {\n                      TAG: /* Error */1,\n                      _0: {\n                        TAG: /* PatternTypeMismatch */0,\n                        data: match,\n                        pattern: pattern\n                      }\n                    };\n            }\n          } else if (match.TAG === /* JSONObject */2) {\n            var _patterns = x$1;\n            var obj = match._0;\n            while(true) {\n              var patterns = _patterns;\n              if (!patterns) {\n                return {\n                        TAG: /* Ok */0,\n                        _0: bindings\n                      };\n              }\n              var match$1 = patterns.hd;\n              var json$1 = Js_dict.get(obj, match$1[0]);\n              if (json$1 === undefined) {\n                return {\n                        TAG: /* Error */1,\n                        _0: /* NoMatch */0\n                      };\n              }\n              var x$2 = testValue(match$1[1], Caml_option.valFromOption(json$1), bindings);\n              if (x$2.TAG !== /* Ok */0) {\n                return x$2;\n              }\n              _patterns = patterns.tl;\n              continue ;\n            };\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: {\n                      TAG: /* PatternTypeMismatch */0,\n                      data: match,\n                      pattern: pattern\n                    }\n                  };\n          }\n        } else if (typeof match === \"number\") {\n          if (match === /* JSONNull */2) {\n            return {\n                    TAG: /* Error */1,\n                    _0: /* NoMatch */0\n                  };\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: {\n                      TAG: /* PatternTypeMismatch */0,\n                      data: match,\n                      pattern: pattern\n                    }\n                  };\n          }\n        } else if (match.TAG === /* JSONObject */2) {\n          if (Object.keys(match._0).length === 0) {\n            return {\n                    TAG: /* Ok */0,\n                    _0: bindings\n                  };\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: /* NoMatch */0\n                  };\n          }\n        } else {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* PatternTypeMismatch */0,\n                    data: match,\n                    pattern: pattern\n                  }\n                };\n        }\n    case /* Binding */8 :\n        return setBinding(bindings, pattern._1, json, pattern._0);\n    \n  }\n}\n\nfunction testArray(patterns, arr, bindings, tailBinding) {\n  var _patterns = patterns;\n  var _index = 0;\n  while(true) {\n    var index = _index;\n    var patterns$1 = _patterns;\n    if (!patterns$1) {\n      if (tailBinding !== undefined) {\n        return setBinding(bindings, tailBinding[1], Belt_Array.sliceToEnd(arr, index), tailBinding[0]);\n      } else {\n        return {\n                TAG: /* Ok */0,\n                _0: bindings\n              };\n      }\n    }\n    var json = Belt_Array.get(arr, index);\n    if (json === undefined) {\n      return {\n              TAG: /* Error */1,\n              _0: /* NoMatch */0\n            };\n    }\n    var x = testValue(patterns$1.hd, Caml_option.valFromOption(json), bindings);\n    if (x.TAG !== /* Ok */0) {\n      return x;\n    }\n    _index = index + 1 | 0;\n    _patterns = patterns$1.tl;\n    continue ;\n  };\n}\n\nfunction test(patternSequence, jsonSequence) {\n  var bindings = {};\n  var _patternSequence = Acutis_Types$AcutisLang.NonEmpty.toList(patternSequence);\n  var _jsonSequence = Acutis_Types$AcutisLang.NonEmpty.toList(jsonSequence);\n  while(true) {\n    var jsonSequence$1 = _jsonSequence;\n    var patternSequence$1 = _patternSequence;\n    if (!patternSequence$1) {\n      if (jsonSequence$1) {\n        return {\n                TAG: /* Error */1,\n                _0: /* PatternNumberMismatch */1\n              };\n      } else {\n        return {\n                TAG: /* Ok */0,\n                _0: bindings\n              };\n      }\n    }\n    if (!jsonSequence$1) {\n      return {\n              TAG: /* Error */1,\n              _0: /* PatternNumberMismatch */1\n            };\n    }\n    var x = testValue(patternSequence$1.hd, jsonSequence$1.hd, bindings);\n    if (x.TAG !== /* Ok */0) {\n      return x;\n    }\n    _jsonSequence = jsonSequence$1.tl;\n    _patternSequence = patternSequence$1.tl;\n    continue ;\n  };\n}\n\nfunction matchCase(param, jsonSequence) {\n  var f = param.f;\n  var _l = Acutis_Types$AcutisLang.NonEmpty.toList(param.patterns);\n  while(true) {\n    var l = _l;\n    if (!l) {\n      return {\n              TAG: /* Error */1,\n              _0: /* NoMatch */0\n            };\n    }\n    var bindings = test(l.hd, jsonSequence);\n    if (bindings.TAG === /* Ok */0) {\n      return {\n              TAG: /* Ok */0,\n              _0: f(bindings._0)\n            };\n    }\n    var match = bindings._0;\n    if (typeof match !== \"number\") {\n      return bindings;\n    }\n    if (match !== 0) {\n      return bindings;\n    }\n    _l = l.tl;\n    continue ;\n  };\n}\n\nfunction match(patterns, data) {\n  var _l = Acutis_Types$AcutisLang.NonEmpty.toList(patterns);\n  while(true) {\n    var l = _l;\n    if (!l) {\n      return {\n              TAG: /* Error */1,\n              _0: /* NoMatch */0\n            };\n    }\n    var x = matchCase(l.hd, data);\n    if (x.TAG === /* Ok */0) {\n      return x;\n    }\n    var match$1 = x._0;\n    if (typeof match$1 !== \"number\") {\n      return x;\n    }\n    if (match$1 !== 0) {\n      return x;\n    }\n    _l = l.tl;\n    continue ;\n  };\n}\n\nfunction $$escape(str) {\n  var _index = 0;\n  var _result = \"\";\n  while(true) {\n    var result = _result;\n    var index = _index;\n    var c = str.charAt(index);\n    switch (c) {\n      case \"\" :\n          return result;\n      case \"\\\"\" :\n          _result = result + \"&quot;\";\n          _index = index + 1 | 0;\n          continue ;\n      case \"&\" :\n          _result = result + \"&amp;\";\n          _index = index + 1 | 0;\n          continue ;\n      case \"'\" :\n          _result = result + \"&apos;\";\n          _index = index + 1 | 0;\n          continue ;\n      case \"/\" :\n          _result = result + \"&#x2F;\";\n          _index = index + 1 | 0;\n          continue ;\n      case \"<\" :\n          _result = result + \"&lt;\";\n          _index = index + 1 | 0;\n          continue ;\n      case \"=\" :\n          _result = result + \"&#x3D;\";\n          _index = index + 1 | 0;\n          continue ;\n      case \">\" :\n          _result = result + \"&gt;\";\n          _index = index + 1 | 0;\n          continue ;\n      case \"`\" :\n          _result = result + \"&#x60;\";\n          _index = index + 1 | 0;\n          continue ;\n      default:\n        _result = result + c;\n        _index = index + 1 | 0;\n        continue ;\n    }\n  };\n}\n\nfunction getBindingOrNull(props, binding) {\n  var x = Js_dict.get(props, binding);\n  if (x !== undefined) {\n    return Caml_option.valFromOption(x);\n  } else {\n    return null;\n  }\n}\n\nfunction echoBinding(props, binding) {\n  var x = Js_json.classify(getBindingOrNull(props, binding));\n  if (typeof x === \"number\") {\n    return {\n            TAG: /* Error */1,\n            _0: x\n          };\n  }\n  switch (x.TAG | 0) {\n    case /* JSONString */0 :\n        return {\n                TAG: /* Ok */0,\n                _0: x._0\n              };\n    case /* JSONNumber */1 :\n        return {\n                TAG: /* Ok */0,\n                _0: String(x._0)\n              };\n    default:\n      return {\n              TAG: /* Error */1,\n              _0: x\n            };\n  }\n}\n\nfunction addImplicitIndexBinding(loc) {\n  return function (x) {\n    if (x._1) {\n      return x;\n    } else {\n      return /* NonEmpty */{\n              _0: x._0,\n              _1: {\n                hd: {\n                  TAG: /* Binding */8,\n                  _0: loc,\n                  _1: \"_\"\n                },\n                tl: /* [] */0\n              }\n            };\n    }\n  };\n}\n\nfunction match$1(patterns, json, loc, stack) {\n  var x = match(patterns, json);\n  if (x.TAG === /* Ok */0) {\n    return x;\n  }\n  var match$2 = x._0;\n  if (typeof match$2 === \"number\") {\n    if (match$2 === /* NoMatch */0) {\n      return {\n              TAG: /* Error */1,\n              _0: Debug$AcutisLang.noMatchFound(loc, stack)\n            };\n    } else {\n      return {\n              TAG: /* Error */1,\n              _0: Debug$AcutisLang.patternNumberMismatch(loc, stack)\n            };\n    }\n  } else if (match$2.TAG === /* PatternTypeMismatch */0) {\n    return {\n            TAG: /* Error */1,\n            _0: Debug$AcutisLang.patternTypeMismatch(match$2.data, match$2.pattern, stack)\n          };\n  } else {\n    return {\n            TAG: /* Error */1,\n            _0: Debug$AcutisLang.nameBoundMultipleTimes(match$2.loc, match$2.binding, stack)\n          };\n  }\n}\n\nfunction trimStart(string) {\n  var _pos = 0;\n  while(true) {\n    var pos = _pos;\n    var match = string.charAt(pos);\n    switch (match) {\n      case \"\\t\" :\n      case \"\\n\" :\n      case \"\\r\" :\n      case \" \" :\n          _pos = pos + 1 | 0;\n          continue ;\n      default:\n        return string.slice(pos);\n    }\n  };\n}\n\nfunction trimEnd(string) {\n  var _pos = string.length;\n  while(true) {\n    var pos = _pos;\n    var match = string.charAt(pos - 1 | 0);\n    switch (match) {\n      case \"\\t\" :\n      case \"\\n\" :\n      case \"\\r\" :\n      case \" \" :\n          _pos = pos - 1 | 0;\n          continue ;\n      default:\n        return string.slice(0, pos);\n    }\n  };\n}\n\nfunction getEcho(_head, _tail, props, stack, children, $$return, error) {\n  while(true) {\n    var tail = _tail;\n    var head = _head;\n    switch (head.TAG | 0) {\n      case /* Binding */0 :\n          var binding = head._1;\n          var x = echoBinding(props, binding);\n          if (x.TAG === /* Ok */0) {\n            return $$return(x._0);\n          }\n          var type_ = x._0;\n          if (typeof type_ === \"number\" && type_ >= 2 && tail) {\n            _tail = tail.tl;\n            _head = tail.hd;\n            continue ;\n          }\n          return error([Debug$AcutisLang.badEchoType(head._0, binding, type_, stack)]);\n          break;\n      case /* Child */1 :\n          var child = head._1;\n          var x$1 = Js_dict.get(children, child);\n          if (x$1 !== undefined) {\n            return Caml_option.valFromOption(x$1);\n          }\n          if (!tail) {\n            return error([Debug$AcutisLang.childDoesNotExist(head._0, child, stack)]);\n          }\n          _tail = tail.tl;\n          _head = tail.hd;\n          continue ;\n      case /* String */2 :\n          return $$return(head._0);\n      case /* Number */3 :\n          return $$return(String(head._0));\n      \n    }\n  };\n}\n\nfunction make(ast, props, children, envData, makeEnv, error, try_, reduceQueue) {\n  var stack = envData.stack;\n  var components = envData.components;\n  var env = makeEnv(envData);\n  var queue = Belt_MutableQueue.make(undefined);\n  var $$escape$1 = function (x) {\n    return env.return($$escape(x));\n  };\n  Belt_List.forEachU(ast, (function (node) {\n          switch (node.TAG | 0) {\n            case /* Text */0 :\n                var str = node._0;\n                var tmp;\n                switch (node._1) {\n                  case /* TrimStart */0 :\n                      tmp = trimStart(str);\n                      break;\n                  case /* TrimEnd */1 :\n                      tmp = trimEnd(str);\n                      break;\n                  case /* TrimBoth */2 :\n                      tmp = trimStart(trimEnd(str));\n                      break;\n                  case /* NoTrim */3 :\n                      tmp = str;\n                      break;\n                  \n                }\n                return Belt_MutableQueue.add(queue, env.return(tmp));\n            case /* Echo */1 :\n                var match$2 = node._1;\n                return Belt_MutableQueue.add(queue, getEcho(match$2._0, match$2._1, props, stack, children, $$escape$1, error));\n            case /* Unescaped */2 :\n                var match$3 = node._1;\n                return Belt_MutableQueue.add(queue, getEcho(match$3._0, match$3._1, props, stack, children, env.return, error));\n            case /* Match */3 :\n                var patterns = Acutis_Types$AcutisLang.NonEmpty.map(node._2, (function (param) {\n                        var ast = param.ast;\n                        return {\n                                patterns: param.patterns,\n                                f: (function (props$prime) {\n                                    return make(ast, Object.assign({}, props, props$prime), children, {\n                                                components: envData.components,\n                                                stack: {\n                                                  hd: /* Match */0,\n                                                  tl: stack\n                                                }\n                                              }, makeEnv, error, try_, reduceQueue);\n                                  })\n                              };\n                      }));\n                var data = Acutis_Types$AcutisLang.NonEmpty.map(node._1, (function (param) {\n                        return getBindingOrNull(props, param[1]);\n                      }));\n                var result = match$1(patterns, data, node._0, stack);\n                if (result.TAG === /* Ok */0) {\n                  return Belt_MutableQueue.transfer(result._0, queue);\n                } else {\n                  return Belt_MutableQueue.add(queue, error([result._0]));\n                }\n            case /* Map */4 :\n                var cases = node._2;\n                var binding = node._1;\n                var loc = node._0;\n                var arr = Js_json.classify(getBindingOrNull(props, binding));\n                if (typeof arr !== \"number\" && arr.TAG === /* JSONArray */3) {\n                  return Belt_Array.forEachWithIndexU(arr._0, (function (index, json) {\n                                var patterns = Acutis_Types$AcutisLang.NonEmpty.map(cases, (function (param) {\n                                        var ast = param.ast;\n                                        return {\n                                                patterns: Acutis_Types$AcutisLang.NonEmpty.map(param.patterns, addImplicitIndexBinding(loc)),\n                                                f: (function (props$prime) {\n                                                    return make(ast, Object.assign({}, props, props$prime), children, {\n                                                                components: envData.components,\n                                                                stack: {\n                                                                  hd: {\n                                                                    TAG: /* Index */2,\n                                                                    _0: index\n                                                                  },\n                                                                  tl: {\n                                                                    hd: /* Map */1,\n                                                                    tl: stack\n                                                                  }\n                                                                }\n                                                              }, makeEnv, error, try_, reduceQueue);\n                                                  })\n                                              };\n                                      }));\n                                var result = match$1(patterns, /* NonEmpty */{\n                                      _0: json,\n                                      _1: {\n                                        hd: index,\n                                        tl: /* [] */0\n                                      }\n                                    }, loc, stack);\n                                if (result.TAG === /* Ok */0) {\n                                  return Belt_MutableQueue.transfer(result._0, queue);\n                                } else {\n                                  return Belt_MutableQueue.add(queue, error([result._0]));\n                                }\n                              }));\n                }\n                return Belt_MutableQueue.add(queue, error([Debug$AcutisLang.badMapType(loc, binding, arr, stack)]));\n            case /* Component */5 :\n                var name = node.name;\n                var loc$1 = node.loc;\n                var component = Js_dict.get(components, name);\n                if (component === undefined) {\n                  return Belt_MutableQueue.add(queue, error([Debug$AcutisLang.componentDoesNotExist(loc$1, name, stack)]));\n                }\n                var compProps = {};\n                var compChildren = {};\n                var errors = Belt_MutableQueue.make(undefined);\n                Belt_List.forEachU(node.children, (function (param) {\n                        var child = param[1];\n                        var key = param[0];\n                        if (child.TAG === /* ChildName */0) {\n                          var child$1 = child._0;\n                          var data = Js_dict.get(children, child$1);\n                          if (data !== undefined) {\n                            compChildren[key] = Caml_option.valFromOption(data);\n                            return ;\n                          } else {\n                            return Belt_MutableQueue.add(errors, Debug$AcutisLang.childDoesNotExist(loc$1, child$1, stack));\n                          }\n                        }\n                        compChildren[key] = reduceQueue(make(child._0, props, children, {\n                                  components: envData.components,\n                                  stack: {\n                                    hd: {\n                                      TAG: /* Section */1,\n                                      component: name,\n                                      section: key\n                                    },\n                                    tl: stack\n                                  }\n                                }, makeEnv, error, try_, reduceQueue));\n                        \n                      }));\n                Belt_List.forEachU(node.props, (function (param) {\n                        var data = toJson(param[1], props);\n                        if (data.TAG === /* Ok */0) {\n                          compProps[param[0]] = data._0;\n                          return ;\n                        }\n                        var match = data._0;\n                        if (match.TAG === /* BindingTypeMismatch */0) {\n                          return Belt_MutableQueue.add(errors, Debug$AcutisLang.bindingTypeMismatch(match.data, match.pattern, match.binding, stack));\n                        } else {\n                          return Belt_MutableQueue.add(errors, Debug$AcutisLang.bindingDoesNotExist(match.loc, match.binding, stack));\n                        }\n                      }));\n                if (Belt_MutableQueue.isEmpty(errors)) {\n                  return Belt_MutableQueue.add(queue, try_((function () {\n                                    return component(env, compProps, compChildren);\n                                  }), (function (e) {\n                                    return error([Debug$AcutisLang.componentExn(e, stack)]);\n                                  })));\n                } else {\n                  return Belt_MutableQueue.add(queue, error(Belt_MutableQueue.toArray(errors)));\n                }\n            \n          }\n        }));\n  return queue;\n}\n\nvar Pattern = {\n  toJson: toJson,\n  test: test\n};\n\nexport {\n  Pattern ,\n  make ,\n  \n}\n/* No side effect */\n","// Generated by ReScript, PLEASE EDIT WITH CARE\n\nimport * as Belt_Array from \"bs-platform/lib/es6/belt_Array.js\";\nimport * as Debug$AcutisLang from \"./Debug.bs.js\";\nimport * as Belt_MutableQueue from \"bs-platform/lib/es6/belt_MutableQueue.js\";\nimport * as Render$AcutisLang from \"./Render.bs.js\";\nimport * as Caml_js_exceptions from \"bs-platform/lib/es6/caml_js_exceptions.js\";\nimport * as Acutis_Types$AcutisLang from \"./Acutis_Types.bs.js\";\n\nfunction returnAsync(x) {\n  return Promise.resolve({\n              NAME: \"data\",\n              VAL: x\n            });\n}\n\nfunction error(x) {\n  return Promise.resolve({\n              NAME: \"errors\",\n              VAL: x\n            });\n}\n\nfunction try_(f, $$catch) {\n  return f().catch(function (e) {\n              return $$catch(e);\n            });\n}\n\nfunction mapChildAsync(child, f) {\n  return child.then(function (child) {\n              if (child.NAME === \"errors\") {\n                return Promise.resolve(child);\n              } else {\n                return Promise.resolve({\n                            NAME: \"data\",\n                            VAL: f(child.VAL)\n                          });\n              }\n            });\n}\n\nfunction flatMapChildAsync(child, f) {\n  return child.then(function (child) {\n              if (child.NAME === \"errors\") {\n                return Promise.resolve(child);\n              } else {\n                return f(child.VAL);\n              }\n            });\n}\n\nfunction reduceArray(a) {\n  var result = {\n    contents: \"\"\n  };\n  var errors = Belt_MutableQueue.make(undefined);\n  Belt_Array.forEachU(a, (function (x) {\n          if (x.NAME === \"errors\") {\n            return Belt_Array.forEachU(x.VAL, (function (x) {\n                          return Belt_MutableQueue.add(errors, x);\n                        }));\n          } else {\n            result.contents = result.contents + x.VAL;\n            return ;\n          }\n        }));\n  if (Belt_MutableQueue.isEmpty(errors)) {\n    return Promise.resolve({\n                NAME: \"data\",\n                VAL: result.contents\n              });\n  } else {\n    return Promise.resolve({\n                NAME: \"errors\",\n                VAL: Belt_MutableQueue.toArray(errors)\n              });\n  }\n}\n\nfunction reduceQueue(q) {\n  return Promise.all(Belt_MutableQueue.toArray(q)).then(reduceArray);\n}\n\nfunction makeAux(param) {\n  var stack = param.stack;\n  var components = param.components;\n  return {\n          render: (function (ast, props, children) {\n              var match = Acutis_Types$AcutisLang.Valid.validate(ast);\n              if (match === undefined) {\n                return Promise.resolve({\n                            NAME: \"errors\",\n                            VAL: [Debug$AcutisLang.invalidInput(stack)]\n                          });\n              }\n              if (match.NAME === \"errors\") {\n                return Promise.resolve({\n                            NAME: \"errors\",\n                            VAL: [match.VAL]\n                          });\n              }\n              var match$1 = match.VAL;\n              return reduceQueue(Render$AcutisLang.make(match$1.ast, props, children, {\n                              components: components,\n                              stack: {\n                                hd: {\n                                  TAG: /* Component */0,\n                                  _0: match$1.name\n                                },\n                                tl: stack\n                              }\n                            }, makeAux, error, try_, reduceQueue));\n            }),\n          return: returnAsync,\n          error: (function (message) {\n              return Promise.resolve({\n                          NAME: \"errors\",\n                          VAL: [Debug$AcutisLang.customError(message, stack)]\n                        });\n            }),\n          mapChild: mapChildAsync,\n          flatMapChild: flatMapChildAsync\n        };\n}\n\nfunction make(components) {\n  return makeAux({\n              components: components,\n              stack: /* [] */0\n            });\n}\n\nfunction $$return(x) {\n  return {\n          NAME: \"data\",\n          VAL: x\n        };\n}\n\nfunction error$1(x) {\n  return {\n          NAME: \"errors\",\n          VAL: x\n        };\n}\n\nfunction try_$1(f, $$catch) {\n  try {\n    return f();\n  }\n  catch (raw_e){\n    var e = Caml_js_exceptions.internalToOCamlException(raw_e);\n    return $$catch(e);\n  }\n}\n\nfunction mapChild(child, f) {\n  if (child.NAME === \"errors\") {\n    return child;\n  } else {\n    return {\n            NAME: \"data\",\n            VAL: f(child.VAL)\n          };\n  }\n}\n\nfunction flatMapChild(child, f) {\n  if (child.NAME === \"errors\") {\n    return child;\n  } else {\n    return f(child.VAL);\n  }\n}\n\nfunction reduceQueue$1(q) {\n  var result = {\n    contents: \"\"\n  };\n  var errors = Belt_MutableQueue.make(undefined);\n  Belt_MutableQueue.forEachU(q, (function (x) {\n          if (x.NAME === \"errors\") {\n            return Belt_Array.forEachU(x.VAL, (function (x) {\n                          return Belt_MutableQueue.add(errors, x);\n                        }));\n          } else {\n            result.contents = result.contents + x.VAL;\n            return ;\n          }\n        }));\n  if (Belt_MutableQueue.isEmpty(errors)) {\n    return {\n            NAME: \"data\",\n            VAL: result.contents\n          };\n  } else {\n    return {\n            NAME: \"errors\",\n            VAL: Belt_MutableQueue.toArray(errors)\n          };\n  }\n}\n\nfunction makeAux$1(param) {\n  var stack = param.stack;\n  var components = param.components;\n  return {\n          render: (function (ast, props, children) {\n              var match = Acutis_Types$AcutisLang.Valid.validate(ast);\n              if (match === undefined) {\n                return {\n                        NAME: \"errors\",\n                        VAL: [Debug$AcutisLang.invalidInput(stack)]\n                      };\n              }\n              if (match.NAME === \"errors\") {\n                return {\n                        NAME: \"errors\",\n                        VAL: [match.VAL]\n                      };\n              }\n              var match$1 = match.VAL;\n              return reduceQueue$1(Render$AcutisLang.make(match$1.ast, props, children, {\n                              components: components,\n                              stack: {\n                                hd: {\n                                  TAG: /* Component */0,\n                                  _0: match$1.name\n                                },\n                                tl: stack\n                              }\n                            }, makeAux$1, error$1, try_$1, reduceQueue$1));\n            }),\n          return: $$return,\n          error: (function (message) {\n              return {\n                      NAME: \"errors\",\n                      VAL: [Debug$AcutisLang.customError(message, stack)]\n                    };\n            }),\n          mapChild: mapChild,\n          flatMapChild: flatMapChild\n        };\n}\n\nfunction make$1(components) {\n  return makeAux$1({\n              components: components,\n              stack: /* [] */0\n            });\n}\n\nvar Async = {\n  make: make\n};\n\nexport {\n  Async ,\n  make$1 as make,\n  \n}\n/* No side effect */\n","// Generated by ReScript, PLEASE EDIT WITH CARE\n\nimport * as Compile$AcutisLang from \"./Compile.bs.js\";\nimport * as Environment$AcutisLang from \"./Environment.bs.js\";\n\nvar Compile_makeAst = Compile$AcutisLang.Js.makeAst;\n\nvar Compile_make = Compile$AcutisLang.Js.make;\n\nvar Compile = {\n  makeAst: Compile_makeAst,\n  make: Compile_make\n};\n\nvar Environment = Environment$AcutisLang;\n\nexport {\n  Compile ,\n  Environment ,\n  \n}\n/* No side effect */\n"],"names":["some","x","undefined","BS_PRIVATE_NESTED_SOME_NONE","valFromOption","depth","get","arr","i","length","Caml_option.some","sliceToEnd","a","offset","y","lena","ofs","len","result","Array","forEachU","f","i_finish","mapU","xs","cell","hd","tl","_cellX","_prec","prec","cellX","next","copyAuxWithMap","reverse","l","_l1","_l2","l2","l1","reverseConcat","_xs","id","contents","create","str","NonEmpty","map","param","_0","_1","Belt_List.mapU","toList","identifierChar","identifierStartChar","componentStart","bindingRegEx","RegEx","isEndOfIdentifier","s","test","isValidIdentifierStart","c","isValidComponentStart","isLegalBinding","isReservedKeyword","Errors","$$location","character","Stack","nameToJson","TAG","x$1","component","section","Token","toString","String","toLocation","Pattern_Ast","loc","Valid","make","data","acutis_is_valid","validate","stackToPath","_x","_acc","_i","fillAux","Belt_List.toArray","Acutis_Types$AcutisLang.Errors","CompileError","Caml_exceptions.create","unexpectedEoF","name","message","kind","location","path","exn","unterminatedComment","unterminatedString","illegalIdentifier","identifier","invalidCharacter","unexpectedCharacter","expected","unexpectedToken","token","Acutis_Types$AcutisLang.Token","illegalBindingName","binding","jsonTaggedTToString","componentDoesNotExist","stack","patternTypeMismatch","pattern","data$1","Acutis_Types$AcutisLang.Pattern_Ast","nameBoundMultipleTimes","noMatchFound","patternNumberMismatch","badEchoType","type_","childDoesNotExist","child","badMapType","invalidInput","compileExn","e","componentExn","customError","clear","q","first","last","add","content","isEmpty","_cell","transfer","q1","q2","toArray","v","peekCharAt","source","charAt","position","peekChar","skipChar","readChar","skipBy","readSubstring","until","start","end","peek","slice","readSubstringBy","endOfNumber","readText","tokens","_position","Belt_MutableQueue.add","readComment","_nested","nested","RE_EXN_ID","Debug$AcutisLang.CompileError","Debug$AcutisLang.unterminatedComment","Error","unescapeQuotes","readJsonString","Debug$AcutisLang.unterminatedString","replace","readNumber","i$1","num","num$1","parseFloat","isNaN","Debug$AcutisLang.illegalIdentifier","makeExpression","loop","exit","Debug$AcutisLang.unexpectedEoF","c$1","Debug$AcutisLang.unexpectedCharacter","Acutis_Types$AcutisLang.RegEx","Debug$AcutisLang.invalidCharacter","peekExn","Belt_MutableQueue.peekExn","popExn","Belt_MutableQueue.popExn","$$Error","internalToOCamlException","Caml_exceptions.caml_is_extension","Debug$AcutisLang.unexpectedToken","Lexer$AcutisLang.name","parseNode","t","t$1","Lexer$AcutisLang.popExn","_valueList","valueList","t$2","t$3","match","match$1","array","Belt_List.reverse","bindLoc","loc$1","t$4","_l","parseObjectKeyValue","t$5","loc$2","key","Lexer$AcutisLang.peekExn","head","parseBindingName","Debug$AcutisLang.illegalBindingName","parseCommaSequence","parseEcho","parseEchoes","endOfMatchMap","endOfFile","slash","parse","_t","parseComponent","withs","parseWithBlocks","_2","parseWithBlock","patterns","ast","block","_props","_children","children","props","parseProps","makeAst","_mode","echoLoc","Lexer$AcutisLang.make","Acutis_Types$AcutisLang.Valid","NAME","VAL","raw_e","Caml_js_exceptions.internalToOCamlException","Debug$AcutisLang.compileExn","dict","k","classify","ty","isArray","opt","listToQueueResult","l$1","toJson","Belt_Result.mapU","Belt_MutableQueue.toArray","Js_dict.get","binding$1","Js_json.classify","Caml_option.valFromOption","binding$2","a1","a2","a1a2","Belt_Array.concat","d","Belt_MutableQueue.forEachU","setBinding","bindings","json","testValue","testArray","Object","keys","_patterns","obj","json$1","x$2","tailBinding","_index","index","patterns$1","Belt_Array.sliceToEnd","Belt_Array.get","patternSequence","jsonSequence","_patternSequence","Acutis_Types$AcutisLang.NonEmpty","_jsonSequence","jsonSequence$1","patternSequence$1","matchCase","getBindingOrNull","echoBinding","addImplicitIndexBinding","match$2","Debug$AcutisLang.noMatchFound","Debug$AcutisLang.patternNumberMismatch","Debug$AcutisLang.patternTypeMismatch","Debug$AcutisLang.nameBoundMultipleTimes","trimStart","string","_pos","pos","trimEnd","getEcho","_head","_tail","$$return","error","tail","Debug$AcutisLang.badEchoType","Debug$AcutisLang.childDoesNotExist","envData","makeEnv","try_","reduceQueue","components","env","queue","$$escape$1","return","_result","$$escape","Belt_List.forEachU","node","tmp","match$3","props$prime","assign","Belt_MutableQueue.transfer","cases","Belt_Array.forEachWithIndexU","Debug$AcutisLang.badMapType","Debug$AcutisLang.componentDoesNotExist","compProps","compChildren","errors","child$1","Debug$AcutisLang.bindingTypeMismatch","Debug$AcutisLang.bindingDoesNotExist","Belt_MutableQueue.isEmpty","Debug$AcutisLang.componentExn","returnAsync","Promise","resolve","$$catch","catch","mapChildAsync","then","flatMapChildAsync","reduceArray","Belt_Array.forEachU","all","makeAux","render","Debug$AcutisLang.invalidInput","Render$AcutisLang.make","Debug$AcutisLang.customError","mapChild","flatMapChild","error$1","try_$1","reduceQueue$1","makeAux$1","Async","Compile","templates","make$1","Environment"],"mappings":"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"}
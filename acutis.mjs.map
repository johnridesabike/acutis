{"version":3,"file":"acutis.mjs","sources":["../node_modules/bs-platform/lib/es6/caml_option.js","../node_modules/bs-platform/lib/es6/belt_Array.js","../node_modules/bs-platform/lib/es6/caml_exceptions.js","../src/Acutis_Types.bs.js","../src/Debug.bs.js","../node_modules/bs-platform/lib/es6/belt_List.js","../node_modules/bs-platform/lib/es6/belt_MutableQueue.js","../src/Lexer.bs.js","../node_modules/bs-platform/lib/es6/belt_Float.js","../node_modules/bs-platform/lib/es6/caml_js_exceptions.js","../src/Compile.bs.js","../node_modules/bs-platform/lib/es6/js_dict.js","../node_modules/bs-platform/lib/es6/js_json.js","../node_modules/bs-platform/lib/es6/belt_Result.js","../node_modules/bs-platform/lib/es6/belt_internalAVLtree.js","../node_modules/bs-platform/lib/es6/belt_MapString.js","../node_modules/bs-platform/lib/es6/belt_internalMapString.js","../src/Render.bs.js","../node_modules/bs-platform/lib/es6/caml_primitive.js","../src/Environment.bs.js","../src/AcutisJs.bs.js"],"sourcesContent":["\n\n\nfunction isNested(x) {\n  return x.BS_PRIVATE_NESTED_SOME_NONE !== undefined;\n}\n\nfunction some(x) {\n  if (x === undefined) {\n    return {\n            BS_PRIVATE_NESTED_SOME_NONE: 0\n          };\n  } else if (x !== null && x.BS_PRIVATE_NESTED_SOME_NONE !== undefined) {\n    return {\n            BS_PRIVATE_NESTED_SOME_NONE: x.BS_PRIVATE_NESTED_SOME_NONE + 1 | 0\n          };\n  } else {\n    return x;\n  }\n}\n\nfunction nullable_to_opt(x) {\n  if (x == null) {\n    return ;\n  } else {\n    return some(x);\n  }\n}\n\nfunction undefined_to_opt(x) {\n  if (x === undefined) {\n    return ;\n  } else {\n    return some(x);\n  }\n}\n\nfunction null_to_opt(x) {\n  if (x === null) {\n    return ;\n  } else {\n    return some(x);\n  }\n}\n\nfunction valFromOption(x) {\n  if (!(x !== null && x.BS_PRIVATE_NESTED_SOME_NONE !== undefined)) {\n    return x;\n  }\n  var depth = x.BS_PRIVATE_NESTED_SOME_NONE;\n  if (depth === 0) {\n    return ;\n  } else {\n    return {\n            BS_PRIVATE_NESTED_SOME_NONE: depth - 1 | 0\n          };\n  }\n}\n\nfunction option_get(x) {\n  if (x === undefined) {\n    return ;\n  } else {\n    return valFromOption(x);\n  }\n}\n\nfunction option_unwrap(x) {\n  if (x !== undefined) {\n    return x.VAL;\n  } else {\n    return x;\n  }\n}\n\nexport {\n  nullable_to_opt ,\n  undefined_to_opt ,\n  null_to_opt ,\n  valFromOption ,\n  some ,\n  isNested ,\n  option_get ,\n  option_unwrap ,\n  \n}\n/* No side effect */\n","\n\nimport * as Curry from \"./curry.js\";\nimport * as Js_math from \"./js_math.js\";\nimport * as Caml_option from \"./caml_option.js\";\nimport * as Caml_primitive from \"./caml_primitive.js\";\n\nfunction get(arr, i) {\n  if (i >= 0 && i < arr.length) {\n    return Caml_option.some(arr[i]);\n  }\n  \n}\n\nfunction getExn(arr, i) {\n  if (!(i >= 0 && i < arr.length)) {\n    throw {\n          RE_EXN_ID: \"Assert_failure\",\n          _1: [\n            \"belt_Array.ml\",\n            27,\n            4\n          ],\n          Error: new Error()\n        };\n  }\n  return arr[i];\n}\n\nfunction set(arr, i, v) {\n  if (i >= 0 && i < arr.length) {\n    arr[i] = v;\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction setExn(arr, i, v) {\n  if (!(i >= 0 && i < arr.length)) {\n    throw {\n          RE_EXN_ID: \"Assert_failure\",\n          _1: [\n            \"belt_Array.ml\",\n            33,\n            2\n          ],\n          Error: new Error()\n        };\n  }\n  arr[i] = v;\n  \n}\n\nfunction swapUnsafe(xs, i, j) {\n  var tmp = xs[i];\n  xs[i] = xs[j];\n  xs[j] = tmp;\n  \n}\n\nfunction shuffleInPlace(xs) {\n  var len = xs.length;\n  for(var i = 0; i < len; ++i){\n    swapUnsafe(xs, i, Js_math.random_int(i, len));\n  }\n  \n}\n\nfunction shuffle(xs) {\n  var result = xs.slice(0);\n  shuffleInPlace(result);\n  return result;\n}\n\nfunction reverseInPlace(xs) {\n  var len = xs.length;\n  var ofs = 0;\n  for(var i = 0 ,i_finish = len / 2 | 0; i < i_finish; ++i){\n    swapUnsafe(xs, ofs + i | 0, ((ofs + len | 0) - i | 0) - 1 | 0);\n  }\n  \n}\n\nfunction reverse(xs) {\n  var len = xs.length;\n  var result = new Array(len);\n  for(var i = 0; i < len; ++i){\n    result[i] = xs[(len - 1 | 0) - i | 0];\n  }\n  return result;\n}\n\nfunction make(l, f) {\n  if (l <= 0) {\n    return [];\n  }\n  var res = new Array(l);\n  for(var i = 0; i < l; ++i){\n    res[i] = f;\n  }\n  return res;\n}\n\nfunction makeByU(l, f) {\n  if (l <= 0) {\n    return [];\n  }\n  var res = new Array(l);\n  for(var i = 0; i < l; ++i){\n    res[i] = f(i);\n  }\n  return res;\n}\n\nfunction makeBy(l, f) {\n  return makeByU(l, Curry.__1(f));\n}\n\nfunction makeByAndShuffleU(l, f) {\n  var u = makeByU(l, f);\n  shuffleInPlace(u);\n  return u;\n}\n\nfunction makeByAndShuffle(l, f) {\n  return makeByAndShuffleU(l, Curry.__1(f));\n}\n\nfunction range(start, finish) {\n  var cut = finish - start | 0;\n  if (cut < 0) {\n    return [];\n  }\n  var arr = new Array(cut + 1 | 0);\n  for(var i = 0; i <= cut; ++i){\n    arr[i] = start + i | 0;\n  }\n  return arr;\n}\n\nfunction rangeBy(start, finish, step) {\n  var cut = finish - start | 0;\n  if (cut < 0 || step <= 0) {\n    return [];\n  }\n  var nb = (cut / step | 0) + 1 | 0;\n  var arr = new Array(nb);\n  var cur = start;\n  for(var i = 0; i < nb; ++i){\n    arr[i] = cur;\n    cur = cur + step | 0;\n  }\n  return arr;\n}\n\nfunction zip(xs, ys) {\n  var lenx = xs.length;\n  var leny = ys.length;\n  var len = lenx < leny ? lenx : leny;\n  var s = new Array(len);\n  for(var i = 0; i < len; ++i){\n    s[i] = [\n      xs[i],\n      ys[i]\n    ];\n  }\n  return s;\n}\n\nfunction zipByU(xs, ys, f) {\n  var lenx = xs.length;\n  var leny = ys.length;\n  var len = lenx < leny ? lenx : leny;\n  var s = new Array(len);\n  for(var i = 0; i < len; ++i){\n    s[i] = f(xs[i], ys[i]);\n  }\n  return s;\n}\n\nfunction zipBy(xs, ys, f) {\n  return zipByU(xs, ys, Curry.__2(f));\n}\n\nfunction concat(a1, a2) {\n  var l1 = a1.length;\n  var l2 = a2.length;\n  var a1a2 = new Array(l1 + l2 | 0);\n  for(var i = 0; i < l1; ++i){\n    a1a2[i] = a1[i];\n  }\n  for(var i$1 = 0; i$1 < l2; ++i$1){\n    a1a2[l1 + i$1 | 0] = a2[i$1];\n  }\n  return a1a2;\n}\n\nfunction concatMany(arrs) {\n  var lenArrs = arrs.length;\n  var totalLen = 0;\n  for(var i = 0; i < lenArrs; ++i){\n    totalLen = totalLen + arrs[i].length | 0;\n  }\n  var result = new Array(totalLen);\n  totalLen = 0;\n  for(var j = 0; j < lenArrs; ++j){\n    var cur = arrs[j];\n    for(var k = 0 ,k_finish = cur.length; k < k_finish; ++k){\n      result[totalLen] = cur[k];\n      totalLen = totalLen + 1 | 0;\n    }\n  }\n  return result;\n}\n\nfunction slice(a, offset, len) {\n  if (len <= 0) {\n    return [];\n  }\n  var lena = a.length;\n  var ofs = offset < 0 ? Caml_primitive.caml_int_max(lena + offset | 0, 0) : offset;\n  var hasLen = lena - ofs | 0;\n  var copyLength = hasLen < len ? hasLen : len;\n  if (copyLength <= 0) {\n    return [];\n  }\n  var result = new Array(copyLength);\n  for(var i = 0; i < copyLength; ++i){\n    result[i] = a[ofs + i | 0];\n  }\n  return result;\n}\n\nfunction sliceToEnd(a, offset) {\n  var lena = a.length;\n  var ofs = offset < 0 ? Caml_primitive.caml_int_max(lena + offset | 0, 0) : offset;\n  var len = lena - ofs | 0;\n  var result = new Array(len);\n  for(var i = 0; i < len; ++i){\n    result[i] = a[ofs + i | 0];\n  }\n  return result;\n}\n\nfunction fill(a, offset, len, v) {\n  if (len <= 0) {\n    return ;\n  }\n  var lena = a.length;\n  var ofs = offset < 0 ? Caml_primitive.caml_int_max(lena + offset | 0, 0) : offset;\n  var hasLen = lena - ofs | 0;\n  var fillLength = hasLen < len ? hasLen : len;\n  if (fillLength <= 0) {\n    return ;\n  }\n  for(var i = ofs ,i_finish = ofs + fillLength | 0; i < i_finish; ++i){\n    a[i] = v;\n  }\n  \n}\n\nfunction blitUnsafe(a1, srcofs1, a2, srcofs2, blitLength) {\n  if (srcofs2 <= srcofs1) {\n    for(var j = 0; j < blitLength; ++j){\n      a2[j + srcofs2 | 0] = a1[j + srcofs1 | 0];\n    }\n    return ;\n  }\n  for(var j$1 = blitLength - 1 | 0; j$1 >= 0; --j$1){\n    a2[j$1 + srcofs2 | 0] = a1[j$1 + srcofs1 | 0];\n  }\n  \n}\n\nfunction blit(a1, ofs1, a2, ofs2, len) {\n  var lena1 = a1.length;\n  var lena2 = a2.length;\n  var srcofs1 = ofs1 < 0 ? Caml_primitive.caml_int_max(lena1 + ofs1 | 0, 0) : ofs1;\n  var srcofs2 = ofs2 < 0 ? Caml_primitive.caml_int_max(lena2 + ofs2 | 0, 0) : ofs2;\n  var blitLength = Caml_primitive.caml_int_min(len, Caml_primitive.caml_int_min(lena1 - srcofs1 | 0, lena2 - srcofs2 | 0));\n  if (srcofs2 <= srcofs1) {\n    for(var j = 0; j < blitLength; ++j){\n      a2[j + srcofs2 | 0] = a1[j + srcofs1 | 0];\n    }\n    return ;\n  }\n  for(var j$1 = blitLength - 1 | 0; j$1 >= 0; --j$1){\n    a2[j$1 + srcofs2 | 0] = a1[j$1 + srcofs1 | 0];\n  }\n  \n}\n\nfunction forEachU(a, f) {\n  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){\n    f(a[i]);\n  }\n  \n}\n\nfunction forEach(a, f) {\n  return forEachU(a, Curry.__1(f));\n}\n\nfunction mapU(a, f) {\n  var l = a.length;\n  var r = new Array(l);\n  for(var i = 0; i < l; ++i){\n    r[i] = f(a[i]);\n  }\n  return r;\n}\n\nfunction map(a, f) {\n  return mapU(a, Curry.__1(f));\n}\n\nfunction getByU(a, p) {\n  var l = a.length;\n  var i = 0;\n  var r;\n  while(r === undefined && i < l) {\n    var v = a[i];\n    if (p(v)) {\n      r = Caml_option.some(v);\n    }\n    i = i + 1 | 0;\n  };\n  return r;\n}\n\nfunction getBy(a, p) {\n  return getByU(a, Curry.__1(p));\n}\n\nfunction getIndexByU(a, p) {\n  var l = a.length;\n  var i = 0;\n  var r;\n  while(r === undefined && i < l) {\n    var v = a[i];\n    if (p(v)) {\n      r = i;\n    }\n    i = i + 1 | 0;\n  };\n  return r;\n}\n\nfunction getIndexBy(a, p) {\n  return getIndexByU(a, Curry.__1(p));\n}\n\nfunction keepU(a, f) {\n  var l = a.length;\n  var r = new Array(l);\n  var j = 0;\n  for(var i = 0; i < l; ++i){\n    var v = a[i];\n    if (f(v)) {\n      r[j] = v;\n      j = j + 1 | 0;\n    }\n    \n  }\n  r.length = j;\n  return r;\n}\n\nfunction keep(a, f) {\n  return keepU(a, Curry.__1(f));\n}\n\nfunction keepWithIndexU(a, f) {\n  var l = a.length;\n  var r = new Array(l);\n  var j = 0;\n  for(var i = 0; i < l; ++i){\n    var v = a[i];\n    if (f(v, i)) {\n      r[j] = v;\n      j = j + 1 | 0;\n    }\n    \n  }\n  r.length = j;\n  return r;\n}\n\nfunction keepWithIndex(a, f) {\n  return keepWithIndexU(a, Curry.__2(f));\n}\n\nfunction keepMapU(a, f) {\n  var l = a.length;\n  var r = new Array(l);\n  var j = 0;\n  for(var i = 0; i < l; ++i){\n    var v = a[i];\n    var v$1 = f(v);\n    if (v$1 !== undefined) {\n      r[j] = Caml_option.valFromOption(v$1);\n      j = j + 1 | 0;\n    }\n    \n  }\n  r.length = j;\n  return r;\n}\n\nfunction keepMap(a, f) {\n  return keepMapU(a, Curry.__1(f));\n}\n\nfunction forEachWithIndexU(a, f) {\n  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){\n    f(i, a[i]);\n  }\n  \n}\n\nfunction forEachWithIndex(a, f) {\n  return forEachWithIndexU(a, Curry.__2(f));\n}\n\nfunction mapWithIndexU(a, f) {\n  var l = a.length;\n  var r = new Array(l);\n  for(var i = 0; i < l; ++i){\n    r[i] = f(i, a[i]);\n  }\n  return r;\n}\n\nfunction mapWithIndex(a, f) {\n  return mapWithIndexU(a, Curry.__2(f));\n}\n\nfunction reduceU(a, x, f) {\n  var r = x;\n  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){\n    r = f(r, a[i]);\n  }\n  return r;\n}\n\nfunction reduce(a, x, f) {\n  return reduceU(a, x, Curry.__2(f));\n}\n\nfunction reduceReverseU(a, x, f) {\n  var r = x;\n  for(var i = a.length - 1 | 0; i >= 0; --i){\n    r = f(r, a[i]);\n  }\n  return r;\n}\n\nfunction reduceReverse(a, x, f) {\n  return reduceReverseU(a, x, Curry.__2(f));\n}\n\nfunction reduceReverse2U(a, b, x, f) {\n  var r = x;\n  var len = Caml_primitive.caml_int_min(a.length, b.length);\n  for(var i = len - 1 | 0; i >= 0; --i){\n    r = f(r, a[i], b[i]);\n  }\n  return r;\n}\n\nfunction reduceReverse2(a, b, x, f) {\n  return reduceReverse2U(a, b, x, Curry.__3(f));\n}\n\nfunction reduceWithIndexU(a, x, f) {\n  var r = x;\n  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){\n    r = f(r, a[i], i);\n  }\n  return r;\n}\n\nfunction reduceWithIndex(a, x, f) {\n  return reduceWithIndexU(a, x, Curry.__3(f));\n}\n\nfunction everyU(arr, b) {\n  var len = arr.length;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    if (i === len) {\n      return true;\n    }\n    if (!b(arr[i])) {\n      return false;\n    }\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction every(arr, f) {\n  return everyU(arr, Curry.__1(f));\n}\n\nfunction someU(arr, b) {\n  var len = arr.length;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    if (i === len) {\n      return false;\n    }\n    if (b(arr[i])) {\n      return true;\n    }\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction some(arr, f) {\n  return someU(arr, Curry.__1(f));\n}\n\nfunction everyAux2(arr1, arr2, _i, b, len) {\n  while(true) {\n    var i = _i;\n    if (i === len) {\n      return true;\n    }\n    if (!b(arr1[i], arr2[i])) {\n      return false;\n    }\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction every2U(a, b, p) {\n  return everyAux2(a, b, 0, p, Caml_primitive.caml_int_min(a.length, b.length));\n}\n\nfunction every2(a, b, p) {\n  return every2U(a, b, Curry.__2(p));\n}\n\nfunction some2U(a, b, p) {\n  var _i = 0;\n  var len = Caml_primitive.caml_int_min(a.length, b.length);\n  while(true) {\n    var i = _i;\n    if (i === len) {\n      return false;\n    }\n    if (p(a[i], b[i])) {\n      return true;\n    }\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction some2(a, b, p) {\n  return some2U(a, b, Curry.__2(p));\n}\n\nfunction eqU(a, b, p) {\n  var lena = a.length;\n  var lenb = b.length;\n  if (lena === lenb) {\n    return everyAux2(a, b, 0, p, lena);\n  } else {\n    return false;\n  }\n}\n\nfunction eq(a, b, p) {\n  return eqU(a, b, Curry.__2(p));\n}\n\nfunction cmpU(a, b, p) {\n  var lena = a.length;\n  var lenb = b.length;\n  if (lena > lenb) {\n    return 1;\n  } else if (lena < lenb) {\n    return -1;\n  } else {\n    var _i = 0;\n    while(true) {\n      var i = _i;\n      if (i === lena) {\n        return 0;\n      }\n      var c = p(a[i], b[i]);\n      if (c !== 0) {\n        return c;\n      }\n      _i = i + 1 | 0;\n      continue ;\n    };\n  }\n}\n\nfunction cmp(a, b, p) {\n  return cmpU(a, b, Curry.__2(p));\n}\n\nfunction partitionU(a, f) {\n  var l = a.length;\n  var i = 0;\n  var j = 0;\n  var a1 = new Array(l);\n  var a2 = new Array(l);\n  for(var ii = 0; ii < l; ++ii){\n    var v = a[ii];\n    if (f(v)) {\n      a1[i] = v;\n      i = i + 1 | 0;\n    } else {\n      a2[j] = v;\n      j = j + 1 | 0;\n    }\n  }\n  a1.length = i;\n  a2.length = j;\n  return [\n          a1,\n          a2\n        ];\n}\n\nfunction partition(a, f) {\n  return partitionU(a, Curry.__1(f));\n}\n\nfunction unzip(a) {\n  var l = a.length;\n  var a1 = new Array(l);\n  var a2 = new Array(l);\n  for(var i = 0; i < l; ++i){\n    var match = a[i];\n    a1[i] = match[0];\n    a2[i] = match[1];\n  }\n  return [\n          a1,\n          a2\n        ];\n}\n\nfunction joinWithU(a, sep, toString) {\n  var l = a.length;\n  if (l === 0) {\n    return \"\";\n  }\n  var lastIndex = l - 1 | 0;\n  var _i = 0;\n  var _res = \"\";\n  while(true) {\n    var res = _res;\n    var i = _i;\n    if (i === lastIndex) {\n      return res + toString(a[i]);\n    }\n    _res = res + (toString(a[i]) + sep);\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction joinWith(a, sep, toString) {\n  return joinWithU(a, sep, Curry.__1(toString));\n}\n\nexport {\n  get ,\n  getExn ,\n  set ,\n  setExn ,\n  shuffleInPlace ,\n  shuffle ,\n  reverseInPlace ,\n  reverse ,\n  make ,\n  range ,\n  rangeBy ,\n  makeByU ,\n  makeBy ,\n  makeByAndShuffleU ,\n  makeByAndShuffle ,\n  zip ,\n  zipByU ,\n  zipBy ,\n  unzip ,\n  concat ,\n  concatMany ,\n  slice ,\n  sliceToEnd ,\n  fill ,\n  blit ,\n  blitUnsafe ,\n  forEachU ,\n  forEach ,\n  mapU ,\n  map ,\n  getByU ,\n  getBy ,\n  getIndexByU ,\n  getIndexBy ,\n  keepU ,\n  keep ,\n  keepWithIndexU ,\n  keepWithIndex ,\n  keepMapU ,\n  keepMap ,\n  forEachWithIndexU ,\n  forEachWithIndex ,\n  mapWithIndexU ,\n  mapWithIndex ,\n  partitionU ,\n  partition ,\n  reduceU ,\n  reduce ,\n  reduceReverseU ,\n  reduceReverse ,\n  reduceReverse2U ,\n  reduceReverse2 ,\n  reduceWithIndexU ,\n  reduceWithIndex ,\n  joinWithU ,\n  joinWith ,\n  someU ,\n  some ,\n  everyU ,\n  every ,\n  every2U ,\n  every2 ,\n  some2U ,\n  some2 ,\n  cmpU ,\n  cmp ,\n  eqU ,\n  eq ,\n  \n}\n/* No side effect */\n","\n\n\nvar id = {\n  contents: 0\n};\n\nfunction create(str) {\n  id.contents = id.contents + 1 | 0;\n  return str + (\"/\" + id.contents);\n}\n\nfunction caml_is_extension(e) {\n  if (e == null) {\n    return false;\n  } else {\n    return typeof e.RE_EXN_ID === \"string\";\n  }\n}\n\nfunction caml_exn_slot_name(x) {\n  return x.RE_EXN_ID;\n}\n\nexport {\n  id ,\n  create ,\n  caml_is_extension ,\n  caml_exn_slot_name ,\n  \n}\n/* No side effect */\n","// Generated by ReScript, PLEASE EDIT WITH CARE\n\nimport * as Belt_Array from \"bs-platform/lib/es6/belt_Array.js\";\nimport * as Caml_option from \"bs-platform/lib/es6/caml_option.js\";\n\nfunction map(param, f) {\n  return /* NonEmpty */{\n          _0: f(param._0),\n          _1: Belt_Array.mapU(param._1, f)\n        };\n}\n\nvar NonEmpty = {\n  map: map\n};\n\nfunction $$location(x) {\n  return {\n          character: x + 1 | 0\n        };\n}\n\nfunction nameToJson(x) {\n  if (typeof x === \"number\") {\n    if (x === /* Match */0) {\n      return \"match\";\n    } else {\n      return \"map\";\n    }\n  }\n  switch (x.TAG | 0) {\n    case /* Component */0 :\n        var x$1 = x._0;\n        if (x$1 !== undefined) {\n          return x$1;\n        } else {\n          return null;\n        }\n    case /* Section */1 :\n        return \"section: \" + x.component + \"#\" + x.section;\n    case /* Index */2 :\n        return x._0;\n    \n  }\n}\n\nvar Stack = {\n  nameToJson: nameToJson\n};\n\nvar Errors = {\n  $$location: $$location,\n  Stack: Stack\n};\n\nvar Result = {};\n\nfunction toString(x) {\n  switch (x.TAG | 0) {\n    case /* Text */0 :\n        return \"[text]: \" + x._1;\n    case /* Comment */1 :\n        return \"{*\" + x._1 + \"*}\";\n    case /* String */2 :\n        return \"\\\"\" + x._1 + \"\\\"\";\n    case /* Number */3 :\n        return String(x._1);\n    case /* True */4 :\n        return \"true\";\n    case /* False */5 :\n        return \"false\";\n    case /* Null */6 :\n        return \"null\";\n    case /* Comma */7 :\n        return \",\";\n    case /* Colon */8 :\n        return \":\";\n    case /* OpenBracket */9 :\n        return \"[\";\n    case /* CloseBracket */10 :\n        return \"]\";\n    case /* OpenBrace */11 :\n        return \"{\";\n    case /* CloseBrace */12 :\n        return \"}\";\n    case /* Spread */13 :\n        return \"...\";\n    case /* Slash */15 :\n        return \"/\";\n    case /* Block */16 :\n        return \"#\";\n    case /* Equals */17 :\n        return \"=\";\n    case /* ComponentName */14 :\n    case /* Identifier */18 :\n        return x._1;\n    case /* Tilde */19 :\n        return \"~\";\n    case /* Question */20 :\n        return \"?\";\n    case /* Ampersand */21 :\n        return \"&\";\n    case /* Echo */22 :\n        return \"{{\";\n    case /* EndOfFile */23 :\n        return \"[end of file]\";\n    \n  }\n}\n\nfunction toLocation(x) {\n  return x._0;\n}\n\nvar Token = {\n  toString: toString,\n  toLocation: toLocation\n};\n\nfunction make(x) {\n  return {\n          data: x,\n          acutis_is_valid: \"ACUTIS_IS_VALID\"\n        };\n}\n\nfunction validate(x) {\n  if (x.acutis_is_valid === \"ACUTIS_IS_VALID\") {\n    return Caml_option.some(x.data);\n  }\n  \n}\n\nvar Valid = {\n  make: make,\n  validate: validate\n};\n\nfunction toString$1(x) {\n  var variant = x.NAME;\n  if (variant === \"Object\") {\n    return \"object\";\n  } else if (variant === \"Binding\") {\n    return \"binding: `\" + x.VAL[1] + \"`\";\n  } else if (variant === \"Number\") {\n    return \"number\";\n  } else if (variant === \"True\" || variant === \"False\") {\n    return \"boolean\";\n  } else if (variant === \"Array\" || variant === \"ArrayWithTailBinding\") {\n    return \"array\";\n  } else if (variant === \"Null\") {\n    return \"null\";\n  } else {\n    return \"string\";\n  }\n}\n\nfunction toLocation$1(x) {\n  var variant = x.NAME;\n  if (variant === \"True\" || variant === \"Null\" || variant === \"False\") {\n    return x.VAL;\n  } else {\n    return x.VAL[0];\n  }\n}\n\nvar Ast_Pattern = {\n  toString: toString$1,\n  toLocation: toLocation$1\n};\n\nvar Echo = {};\n\nvar Ast = {\n  Echo: Echo\n};\n\nexport {\n  NonEmpty ,\n  Errors ,\n  Result ,\n  Token ,\n  Valid ,\n  Ast_Pattern ,\n  Ast ,\n  \n}\n/* No side effect */\n","// Generated by ReScript, PLEASE EDIT WITH CARE\n\nimport * as Belt_List from \"bs-platform/lib/es6/belt_List.js\";\nimport * as Belt_Array from \"bs-platform/lib/es6/belt_Array.js\";\nimport * as Caml_option from \"bs-platform/lib/es6/caml_option.js\";\nimport * as Caml_exceptions from \"bs-platform/lib/es6/caml_exceptions.js\";\nimport * as Acutis_Types$AcutisLang from \"./Acutis_Types.bs.js\";\n\nfunction stackToPath(x) {\n  return Belt_Array.mapU(Belt_List.toArray(x), Acutis_Types$AcutisLang.Errors.Stack.nameToJson);\n}\n\nvar CompileError = Caml_exceptions.create(\"Debug-AcutisLang.CompileError\");\n\nfunction unexpectedEofExn(loc, name) {\n  throw {\n        RE_EXN_ID: CompileError,\n        _1: {\n          message: \"Unexpected end of file.\",\n          kind: \"Syntax\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: [name !== undefined ? name : null],\n          exn: undefined\n        },\n        Error: new Error()\n      };\n}\n\nfunction unterminatedCommentExn(loc, name) {\n  throw {\n        RE_EXN_ID: CompileError,\n        _1: {\n          message: \"Unterminated comment.\",\n          kind: \"Syntax\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: [name !== undefined ? name : null],\n          exn: undefined\n        },\n        Error: new Error()\n      };\n}\n\nfunction unterminatedStringExn(loc, name) {\n  throw {\n        RE_EXN_ID: CompileError,\n        _1: {\n          message: \"Unterminated string.\",\n          kind: \"Syntax\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: [name !== undefined ? name : null],\n          exn: undefined\n        },\n        Error: new Error()\n      };\n}\n\nfunction illegalIdentifierExn(loc, name, identifier) {\n  throw {\n        RE_EXN_ID: CompileError,\n        _1: {\n          message: \"\\\"\" + identifier + \"\\\" is an illegal identifier name.\",\n          kind: \"Parse\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: [name !== undefined ? name : null],\n          exn: undefined\n        },\n        Error: new Error()\n      };\n}\n\nfunction invalidCharacterExn(loc, name, character) {\n  throw {\n        RE_EXN_ID: CompileError,\n        _1: {\n          message: \"Invalid character: \\\"\" + character + \"\\\".\",\n          kind: \"Syntax\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: [name !== undefined ? name : null],\n          exn: undefined\n        },\n        Error: new Error()\n      };\n}\n\nfunction unexpectedCharacterExn(loc, name, character, expected) {\n  throw {\n        RE_EXN_ID: CompileError,\n        _1: {\n          message: \"Unexpected character: \\\"\" + character + \"\\\". Expected: \\\"\" + expected + \"\\\".\",\n          kind: \"Syntax\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: [name !== undefined ? name : null],\n          exn: undefined\n        },\n        Error: new Error()\n      };\n}\n\nfunction unexpectedTokenExn(t, name) {\n  throw {\n        RE_EXN_ID: CompileError,\n        _1: {\n          message: \"Unexpected token: \\\"\" + Acutis_Types$AcutisLang.Token.toString(t) + \"\\\".\",\n          kind: \"Parse\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(Acutis_Types$AcutisLang.Token.toLocation(t)),\n          path: [name !== undefined ? name : null],\n          exn: undefined\n        },\n        Error: new Error()\n      };\n}\n\nfunction badMapTypeParseExn(t, name) {\n  throw {\n        RE_EXN_ID: CompileError,\n        _1: {\n          message: \"Bad map type: \\\"\" + Acutis_Types$AcutisLang.Ast_Pattern.toString(t) + \"\\\". I can only map bindings and arrays.\",\n          kind: \"Parse\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(Acutis_Types$AcutisLang.Ast_Pattern.toLocation(t)),\n          path: [name !== undefined ? name : null],\n          exn: undefined\n        },\n        Error: new Error()\n      };\n}\n\nfunction jsonTaggedTToString(x) {\n  if (typeof x === \"number\") {\n    switch (x) {\n      case /* JSONFalse */0 :\n      case /* JSONTrue */1 :\n          return \"boolean\";\n      case /* JSONNull */2 :\n          return \"null\";\n      \n    }\n  } else {\n    switch (x.TAG | 0) {\n      case /* JSONString */0 :\n          return \"string\";\n      case /* JSONNumber */1 :\n          return \"number\";\n      case /* JSONObject */2 :\n          return \"object\";\n      case /* JSONArray */3 :\n          return \"array\";\n      \n    }\n  }\n}\n\nfunction componentDoesNotExist(loc, component, stack) {\n  return {\n          message: \"Component \\\"\" + component + \"\\\" does not exist.\",\n          kind: \"Render\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nfunction patternTypeMismatch(data, pattern, stack) {\n  var data$1 = jsonTaggedTToString(data);\n  var type_ = Acutis_Types$AcutisLang.Ast_Pattern.toString(pattern);\n  return {\n          message: \"This pattern is type \" + type_ + \" but the data is type \" + data$1 + \".\",\n          kind: \"Type\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(Acutis_Types$AcutisLang.Ast_Pattern.toLocation(pattern)),\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nfunction bindingTypeMismatch(data, pattern, binding, stack) {\n  var data$1 = jsonTaggedTToString(data);\n  var p = Acutis_Types$AcutisLang.Ast_Pattern.toString(pattern);\n  return {\n          message: \"\\\"\" + binding + \"\\\" is type \" + p + \" but the data is type \" + data$1 + \".\",\n          kind: \"Type\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(Acutis_Types$AcutisLang.Ast_Pattern.toLocation(pattern)),\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nfunction nameBoundMultipleTimes(loc, binding, stack) {\n  return {\n          message: \"\\\"\" + binding + \"\\\" is bound multiple times in this pattern.\",\n          kind: \"Pattern\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nfunction noMatchFound(loc, stack) {\n  return {\n          message: \"None of the patterns match the data. Consider a catch-all case to avoid this.\",\n          kind: \"Pattern\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nfunction patternNumberMismatch(loc, stack) {\n  return {\n          message: \"The number of patterns does not match the number of data.\",\n          kind: \"Pattern\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nfunction badEchoType(loc, binding, type_, stack) {\n  var type_$1 = jsonTaggedTToString(type_);\n  return {\n          message: \"\\\"\" + binding + \"\\\" is type \" + type_$1 + \". I can only echo strings and numbers.\",\n          kind: \"Render\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nfunction bindingDoesNotExist(loc, binding, stack) {\n  return {\n          message: \"Binding \\\"\" + binding + \"\\\" does not exist.\",\n          kind: \"Render\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nfunction childDoesNotExist(loc, child, stack) {\n  return {\n          message: \"Template child \\\"\" + child + \"\\\" does not exist.\",\n          kind: \"Render\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nfunction badMapType(loc, binding, type_, stack) {\n  var type_$1 = jsonTaggedTToString(type_);\n  return {\n          message: \"\\\"\" + binding + \"\\\" is a \" + type_$1 + \". I can only map arrays.\",\n          kind: \"Type\",\n          location: Acutis_Types$AcutisLang.Errors.$$location(loc),\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nfunction invalidInput(stack) {\n  return {\n          message: \"A template AST was not valid. Did you forget to compile one?\",\n          kind: \"Render\",\n          location: undefined,\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nfunction compileExn(e, name) {\n  return {\n          message: \"An exception was thrown while rendering this template. This is probably due to malformed input.\",\n          kind: \"Compile\",\n          location: undefined,\n          path: [name !== undefined ? name : null],\n          exn: Caml_option.some(e)\n        };\n}\n\nfunction componentExn(e, stack) {\n  return {\n          message: \"An exception was thrown while rendering a template component.\",\n          kind: \"Render\",\n          location: undefined,\n          path: stackToPath(stack),\n          exn: Caml_option.some(e)\n        };\n}\n\nfunction customError(message, stack) {\n  return {\n          message: message,\n          kind: \"Render\",\n          location: undefined,\n          path: stackToPath(stack),\n          exn: undefined\n        };\n}\n\nexport {\n  stackToPath ,\n  CompileError ,\n  unexpectedEofExn ,\n  unterminatedCommentExn ,\n  unterminatedStringExn ,\n  illegalIdentifierExn ,\n  invalidCharacterExn ,\n  unexpectedCharacterExn ,\n  unexpectedTokenExn ,\n  badMapTypeParseExn ,\n  jsonTaggedTToString ,\n  componentDoesNotExist ,\n  patternTypeMismatch ,\n  bindingTypeMismatch ,\n  nameBoundMultipleTimes ,\n  noMatchFound ,\n  patternNumberMismatch ,\n  badEchoType ,\n  bindingDoesNotExist ,\n  childDoesNotExist ,\n  badMapType ,\n  invalidInput ,\n  compileExn ,\n  componentExn ,\n  customError ,\n  \n}\n/* No side effect */\n","\n\nimport * as Curry from \"./curry.js\";\nimport * as Belt_Array from \"./belt_Array.js\";\nimport * as Caml_option from \"./caml_option.js\";\nimport * as Belt_SortArray from \"./belt_SortArray.js\";\n\nfunction head(x) {\n  if (x) {\n    return Caml_option.some(x.hd);\n  }\n  \n}\n\nfunction headExn(x) {\n  if (x) {\n    return x.hd;\n  }\n  throw {\n        RE_EXN_ID: \"Not_found\",\n        Error: new Error()\n      };\n}\n\nfunction tail(x) {\n  if (x) {\n    return x.tl;\n  }\n  \n}\n\nfunction tailExn(x) {\n  if (x) {\n    return x.tl;\n  }\n  throw {\n        RE_EXN_ID: \"Not_found\",\n        Error: new Error()\n      };\n}\n\nfunction add(xs, x) {\n  return {\n          hd: x,\n          tl: xs\n        };\n}\n\nfunction get(x, n) {\n  if (n < 0) {\n    return ;\n  } else {\n    var _x = x;\n    var _n = n;\n    while(true) {\n      var n$1 = _n;\n      var x$1 = _x;\n      if (!x$1) {\n        return ;\n      }\n      if (n$1 === 0) {\n        return Caml_option.some(x$1.hd);\n      }\n      _n = n$1 - 1 | 0;\n      _x = x$1.tl;\n      continue ;\n    };\n  }\n}\n\nfunction getExn(x, n) {\n  if (n < 0) {\n    throw {\n          RE_EXN_ID: \"Not_found\",\n          Error: new Error()\n        };\n  }\n  var _x = x;\n  var _n = n;\n  while(true) {\n    var n$1 = _n;\n    var x$1 = _x;\n    if (x$1) {\n      if (n$1 === 0) {\n        return x$1.hd;\n      }\n      _n = n$1 - 1 | 0;\n      _x = x$1.tl;\n      continue ;\n    }\n    throw {\n          RE_EXN_ID: \"Not_found\",\n          Error: new Error()\n        };\n  };\n}\n\nfunction partitionAux(p, _cell, _precX, _precY) {\n  while(true) {\n    var precY = _precY;\n    var precX = _precX;\n    var cell = _cell;\n    if (!cell) {\n      return ;\n    }\n    var t = cell.tl;\n    var h = cell.hd;\n    var next = {\n      hd: h,\n      tl: /* [] */0\n    };\n    if (p(h)) {\n      precX.tl = next;\n      _precX = next;\n      _cell = t;\n      continue ;\n    }\n    precY.tl = next;\n    _precY = next;\n    _cell = t;\n    continue ;\n  };\n}\n\nfunction splitAux(_cell, _precX, _precY) {\n  while(true) {\n    var precY = _precY;\n    var precX = _precX;\n    var cell = _cell;\n    if (!cell) {\n      return ;\n    }\n    var match = cell.hd;\n    var nextA = {\n      hd: match[0],\n      tl: /* [] */0\n    };\n    var nextB = {\n      hd: match[1],\n      tl: /* [] */0\n    };\n    precX.tl = nextA;\n    precY.tl = nextB;\n    _precY = nextB;\n    _precX = nextA;\n    _cell = cell.tl;\n    continue ;\n  };\n}\n\nfunction copyAuxCont(_cellX, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cellX = _cellX;\n    if (!cellX) {\n      return prec;\n    }\n    var next = {\n      hd: cellX.hd,\n      tl: /* [] */0\n    };\n    prec.tl = next;\n    _prec = next;\n    _cellX = cellX.tl;\n    continue ;\n  };\n}\n\nfunction copyAuxWitFilter(f, _cellX, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cellX = _cellX;\n    if (!cellX) {\n      return ;\n    }\n    var t = cellX.tl;\n    var h = cellX.hd;\n    if (f(h)) {\n      var next = {\n        hd: h,\n        tl: /* [] */0\n      };\n      prec.tl = next;\n      _prec = next;\n      _cellX = t;\n      continue ;\n    }\n    _cellX = t;\n    continue ;\n  };\n}\n\nfunction copyAuxWithFilterIndex(f, _cellX, _prec, _i) {\n  while(true) {\n    var i = _i;\n    var prec = _prec;\n    var cellX = _cellX;\n    if (!cellX) {\n      return ;\n    }\n    var t = cellX.tl;\n    var h = cellX.hd;\n    if (f(h, i)) {\n      var next = {\n        hd: h,\n        tl: /* [] */0\n      };\n      prec.tl = next;\n      _i = i + 1 | 0;\n      _prec = next;\n      _cellX = t;\n      continue ;\n    }\n    _i = i + 1 | 0;\n    _cellX = t;\n    continue ;\n  };\n}\n\nfunction copyAuxWitFilterMap(f, _cellX, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cellX = _cellX;\n    if (!cellX) {\n      return ;\n    }\n    var t = cellX.tl;\n    var h = f(cellX.hd);\n    if (h !== undefined) {\n      var next = {\n        hd: Caml_option.valFromOption(h),\n        tl: /* [] */0\n      };\n      prec.tl = next;\n      _prec = next;\n      _cellX = t;\n      continue ;\n    }\n    _cellX = t;\n    continue ;\n  };\n}\n\nfunction removeAssocAuxWithMap(_cellX, x, _prec, f) {\n  while(true) {\n    var prec = _prec;\n    var cellX = _cellX;\n    if (!cellX) {\n      return false;\n    }\n    var t = cellX.tl;\n    var h = cellX.hd;\n    if (f(h[0], x)) {\n      prec.tl = t;\n      return true;\n    }\n    var next = {\n      hd: h,\n      tl: /* [] */0\n    };\n    prec.tl = next;\n    _prec = next;\n    _cellX = t;\n    continue ;\n  };\n}\n\nfunction setAssocAuxWithMap(_cellX, x, k, _prec, eq) {\n  while(true) {\n    var prec = _prec;\n    var cellX = _cellX;\n    if (!cellX) {\n      return false;\n    }\n    var t = cellX.tl;\n    var h = cellX.hd;\n    if (eq(h[0], x)) {\n      prec.tl = {\n        hd: [\n          x,\n          k\n        ],\n        tl: t\n      };\n      return true;\n    }\n    var next = {\n      hd: h,\n      tl: /* [] */0\n    };\n    prec.tl = next;\n    _prec = next;\n    _cellX = t;\n    continue ;\n  };\n}\n\nfunction copyAuxWithMap(_cellX, _prec, f) {\n  while(true) {\n    var prec = _prec;\n    var cellX = _cellX;\n    if (!cellX) {\n      return ;\n    }\n    var next = {\n      hd: f(cellX.hd),\n      tl: /* [] */0\n    };\n    prec.tl = next;\n    _prec = next;\n    _cellX = cellX.tl;\n    continue ;\n  };\n}\n\nfunction zipAux(_cellX, _cellY, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cellY = _cellY;\n    var cellX = _cellX;\n    if (!cellX) {\n      return ;\n    }\n    if (!cellY) {\n      return ;\n    }\n    var next = {\n      hd: [\n        cellX.hd,\n        cellY.hd\n      ],\n      tl: /* [] */0\n    };\n    prec.tl = next;\n    _prec = next;\n    _cellY = cellY.tl;\n    _cellX = cellX.tl;\n    continue ;\n  };\n}\n\nfunction copyAuxWithMap2(f, _cellX, _cellY, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cellY = _cellY;\n    var cellX = _cellX;\n    if (!cellX) {\n      return ;\n    }\n    if (!cellY) {\n      return ;\n    }\n    var next = {\n      hd: f(cellX.hd, cellY.hd),\n      tl: /* [] */0\n    };\n    prec.tl = next;\n    _prec = next;\n    _cellY = cellY.tl;\n    _cellX = cellX.tl;\n    continue ;\n  };\n}\n\nfunction copyAuxWithMapI(f, _i, _cellX, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cellX = _cellX;\n    var i = _i;\n    if (!cellX) {\n      return ;\n    }\n    var next = {\n      hd: f(i, cellX.hd),\n      tl: /* [] */0\n    };\n    prec.tl = next;\n    _prec = next;\n    _cellX = cellX.tl;\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction takeAux(_n, _cell, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cell = _cell;\n    var n = _n;\n    if (n === 0) {\n      return true;\n    }\n    if (!cell) {\n      return false;\n    }\n    var cell$1 = {\n      hd: cell.hd,\n      tl: /* [] */0\n    };\n    prec.tl = cell$1;\n    _prec = cell$1;\n    _cell = cell.tl;\n    _n = n - 1 | 0;\n    continue ;\n  };\n}\n\nfunction splitAtAux(_n, _cell, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cell = _cell;\n    var n = _n;\n    if (n === 0) {\n      return cell;\n    }\n    if (!cell) {\n      return ;\n    }\n    var cell$1 = {\n      hd: cell.hd,\n      tl: /* [] */0\n    };\n    prec.tl = cell$1;\n    _prec = cell$1;\n    _cell = cell.tl;\n    _n = n - 1 | 0;\n    continue ;\n  };\n}\n\nfunction take(lst, n) {\n  if (n < 0) {\n    return ;\n  }\n  if (n === 0) {\n    return /* [] */0;\n  }\n  if (!lst) {\n    return ;\n  }\n  var cell = {\n    hd: lst.hd,\n    tl: /* [] */0\n  };\n  var has = takeAux(n - 1 | 0, lst.tl, cell);\n  if (has) {\n    return cell;\n  }\n  \n}\n\nfunction drop(lst, n) {\n  if (n < 0) {\n    return ;\n  } else {\n    var _l = lst;\n    var _n = n;\n    while(true) {\n      var n$1 = _n;\n      var l = _l;\n      if (n$1 === 0) {\n        return l;\n      }\n      if (!l) {\n        return ;\n      }\n      _n = n$1 - 1 | 0;\n      _l = l.tl;\n      continue ;\n    };\n  }\n}\n\nfunction splitAt(lst, n) {\n  if (n < 0) {\n    return ;\n  }\n  if (n === 0) {\n    return [\n            /* [] */0,\n            lst\n          ];\n  }\n  if (!lst) {\n    return ;\n  }\n  var cell = {\n    hd: lst.hd,\n    tl: /* [] */0\n  };\n  var rest = splitAtAux(n - 1 | 0, lst.tl, cell);\n  if (rest !== undefined) {\n    return [\n            cell,\n            rest\n          ];\n  }\n  \n}\n\nfunction concat(xs, ys) {\n  if (!xs) {\n    return ys;\n  }\n  var cell = {\n    hd: xs.hd,\n    tl: /* [] */0\n  };\n  copyAuxCont(xs.tl, cell).tl = ys;\n  return cell;\n}\n\nfunction mapU(xs, f) {\n  if (!xs) {\n    return /* [] */0;\n  }\n  var cell = {\n    hd: f(xs.hd),\n    tl: /* [] */0\n  };\n  copyAuxWithMap(xs.tl, cell, f);\n  return cell;\n}\n\nfunction map(xs, f) {\n  return mapU(xs, Curry.__1(f));\n}\n\nfunction zipByU(l1, l2, f) {\n  if (!l1) {\n    return /* [] */0;\n  }\n  if (!l2) {\n    return /* [] */0;\n  }\n  var cell = {\n    hd: f(l1.hd, l2.hd),\n    tl: /* [] */0\n  };\n  copyAuxWithMap2(f, l1.tl, l2.tl, cell);\n  return cell;\n}\n\nfunction zipBy(l1, l2, f) {\n  return zipByU(l1, l2, Curry.__2(f));\n}\n\nfunction mapWithIndexU(xs, f) {\n  if (!xs) {\n    return /* [] */0;\n  }\n  var cell = {\n    hd: f(0, xs.hd),\n    tl: /* [] */0\n  };\n  copyAuxWithMapI(f, 1, xs.tl, cell);\n  return cell;\n}\n\nfunction mapWithIndex(xs, f) {\n  return mapWithIndexU(xs, Curry.__2(f));\n}\n\nfunction makeByU(n, f) {\n  if (n <= 0) {\n    return /* [] */0;\n  }\n  var headX = {\n    hd: f(0),\n    tl: /* [] */0\n  };\n  var cur = headX;\n  var i = 1;\n  while(i < n) {\n    var v = {\n      hd: f(i),\n      tl: /* [] */0\n    };\n    cur.tl = v;\n    cur = v;\n    i = i + 1 | 0;\n  };\n  return headX;\n}\n\nfunction makeBy(n, f) {\n  return makeByU(n, Curry.__1(f));\n}\n\nfunction make(n, v) {\n  if (n <= 0) {\n    return /* [] */0;\n  }\n  var headX = {\n    hd: v,\n    tl: /* [] */0\n  };\n  var cur = headX;\n  var i = 1;\n  while(i < n) {\n    var v$1 = {\n      hd: v,\n      tl: /* [] */0\n    };\n    cur.tl = v$1;\n    cur = v$1;\n    i = i + 1 | 0;\n  };\n  return headX;\n}\n\nfunction length(xs) {\n  var _x = xs;\n  var _acc = 0;\n  while(true) {\n    var acc = _acc;\n    var x = _x;\n    if (!x) {\n      return acc;\n    }\n    _acc = acc + 1 | 0;\n    _x = x.tl;\n    continue ;\n  };\n}\n\nfunction fillAux(arr, _i, _x) {\n  while(true) {\n    var x = _x;\n    var i = _i;\n    if (!x) {\n      return ;\n    }\n    arr[i] = x.hd;\n    _x = x.tl;\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction fromArray(a) {\n  var _i = a.length - 1 | 0;\n  var _res = /* [] */0;\n  while(true) {\n    var res = _res;\n    var i = _i;\n    if (i < 0) {\n      return res;\n    }\n    _res = {\n      hd: a[i],\n      tl: res\n    };\n    _i = i - 1 | 0;\n    continue ;\n  };\n}\n\nfunction toArray(x) {\n  var len = length(x);\n  var arr = new Array(len);\n  fillAux(arr, 0, x);\n  return arr;\n}\n\nfunction shuffle(xs) {\n  var v = toArray(xs);\n  Belt_Array.shuffleInPlace(v);\n  return fromArray(v);\n}\n\nfunction reverseConcat(_l1, _l2) {\n  while(true) {\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      return l2;\n    }\n    _l2 = {\n      hd: l1.hd,\n      tl: l2\n    };\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction reverse(l) {\n  return reverseConcat(l, /* [] */0);\n}\n\nfunction flattenAux(_prec, _xs) {\n  while(true) {\n    var xs = _xs;\n    var prec = _prec;\n    if (xs) {\n      _xs = xs.tl;\n      _prec = copyAuxCont(xs.hd, prec);\n      continue ;\n    }\n    prec.tl = /* [] */0;\n    return ;\n  };\n}\n\nfunction flatten(_xs) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return /* [] */0;\n    }\n    var match = xs.hd;\n    if (match) {\n      var cell = {\n        hd: match.hd,\n        tl: /* [] */0\n      };\n      flattenAux(copyAuxCont(match.tl, cell), xs.tl);\n      return cell;\n    }\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction concatMany(xs) {\n  var len = xs.length;\n  if (len === 1) {\n    return xs[0];\n  }\n  if (len === 0) {\n    return /* [] */0;\n  }\n  var len$1 = xs.length;\n  var v = xs[len$1 - 1 | 0];\n  for(var i = len$1 - 2 | 0; i >= 0; --i){\n    v = concat(xs[i], v);\n  }\n  return v;\n}\n\nfunction mapReverseU(l, f) {\n  var _accu = /* [] */0;\n  var _xs = l;\n  while(true) {\n    var xs = _xs;\n    var accu = _accu;\n    if (!xs) {\n      return accu;\n    }\n    _xs = xs.tl;\n    _accu = {\n      hd: f(xs.hd),\n      tl: accu\n    };\n    continue ;\n  };\n}\n\nfunction mapReverse(l, f) {\n  return mapReverseU(l, Curry.__1(f));\n}\n\nfunction forEachU(_xs, f) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return ;\n    }\n    f(xs.hd);\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction forEach(xs, f) {\n  return forEachU(xs, Curry.__1(f));\n}\n\nfunction forEachWithIndexU(l, f) {\n  var _xs = l;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    var xs = _xs;\n    if (!xs) {\n      return ;\n    }\n    f(i, xs.hd);\n    _i = i + 1 | 0;\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction forEachWithIndex(l, f) {\n  return forEachWithIndexU(l, Curry.__2(f));\n}\n\nfunction reduceU(_l, _accu, f) {\n  while(true) {\n    var accu = _accu;\n    var l = _l;\n    if (!l) {\n      return accu;\n    }\n    _accu = f(accu, l.hd);\n    _l = l.tl;\n    continue ;\n  };\n}\n\nfunction reduce(l, accu, f) {\n  return reduceU(l, accu, Curry.__2(f));\n}\n\nfunction reduceReverseUnsafeU(l, accu, f) {\n  if (l) {\n    return f(reduceReverseUnsafeU(l.tl, accu, f), l.hd);\n  } else {\n    return accu;\n  }\n}\n\nfunction reduceReverseU(l, acc, f) {\n  var len = length(l);\n  if (len < 1000) {\n    return reduceReverseUnsafeU(l, acc, f);\n  } else {\n    return Belt_Array.reduceReverseU(toArray(l), acc, f);\n  }\n}\n\nfunction reduceReverse(l, accu, f) {\n  return reduceReverseU(l, accu, Curry.__2(f));\n}\n\nfunction reduceWithIndexU(l, acc, f) {\n  var _l = l;\n  var _acc = acc;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    var acc$1 = _acc;\n    var l$1 = _l;\n    if (!l$1) {\n      return acc$1;\n    }\n    _i = i + 1 | 0;\n    _acc = f(acc$1, l$1.hd, i);\n    _l = l$1.tl;\n    continue ;\n  };\n}\n\nfunction reduceWithIndex(l, acc, f) {\n  return reduceWithIndexU(l, acc, Curry.__3(f));\n}\n\nfunction mapReverse2U(l1, l2, f) {\n  var _l1 = l1;\n  var _l2 = l2;\n  var _accu = /* [] */0;\n  while(true) {\n    var accu = _accu;\n    var l2$1 = _l2;\n    var l1$1 = _l1;\n    if (!l1$1) {\n      return accu;\n    }\n    if (!l2$1) {\n      return accu;\n    }\n    _accu = {\n      hd: f(l1$1.hd, l2$1.hd),\n      tl: accu\n    };\n    _l2 = l2$1.tl;\n    _l1 = l1$1.tl;\n    continue ;\n  };\n}\n\nfunction mapReverse2(l1, l2, f) {\n  return mapReverse2U(l1, l2, Curry.__2(f));\n}\n\nfunction forEach2U(_l1, _l2, f) {\n  while(true) {\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      return ;\n    }\n    if (!l2) {\n      return ;\n    }\n    f(l1.hd, l2.hd);\n    _l2 = l2.tl;\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction forEach2(l1, l2, f) {\n  return forEach2U(l1, l2, Curry.__2(f));\n}\n\nfunction reduce2U(_l1, _l2, _accu, f) {\n  while(true) {\n    var accu = _accu;\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      return accu;\n    }\n    if (!l2) {\n      return accu;\n    }\n    _accu = f(accu, l1.hd, l2.hd);\n    _l2 = l2.tl;\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction reduce2(l1, l2, acc, f) {\n  return reduce2U(l1, l2, acc, Curry.__3(f));\n}\n\nfunction reduceReverse2UnsafeU(l1, l2, accu, f) {\n  if (l1 && l2) {\n    return f(reduceReverse2UnsafeU(l1.tl, l2.tl, accu, f), l1.hd, l2.hd);\n  } else {\n    return accu;\n  }\n}\n\nfunction reduceReverse2U(l1, l2, acc, f) {\n  var len = length(l1);\n  if (len < 1000) {\n    return reduceReverse2UnsafeU(l1, l2, acc, f);\n  } else {\n    return Belt_Array.reduceReverse2U(toArray(l1), toArray(l2), acc, f);\n  }\n}\n\nfunction reduceReverse2(l1, l2, acc, f) {\n  return reduceReverse2U(l1, l2, acc, Curry.__3(f));\n}\n\nfunction everyU(_xs, p) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return true;\n    }\n    if (!p(xs.hd)) {\n      return false;\n    }\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction every(xs, p) {\n  return everyU(xs, Curry.__1(p));\n}\n\nfunction someU(_xs, p) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return false;\n    }\n    if (p(xs.hd)) {\n      return true;\n    }\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction some(xs, p) {\n  return someU(xs, Curry.__1(p));\n}\n\nfunction every2U(_l1, _l2, p) {\n  while(true) {\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      return true;\n    }\n    if (!l2) {\n      return true;\n    }\n    if (!p(l1.hd, l2.hd)) {\n      return false;\n    }\n    _l2 = l2.tl;\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction every2(l1, l2, p) {\n  return every2U(l1, l2, Curry.__2(p));\n}\n\nfunction cmpByLength(_l1, _l2) {\n  while(true) {\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      if (l2) {\n        return -1;\n      } else {\n        return 0;\n      }\n    }\n    if (!l2) {\n      return 1;\n    }\n    _l2 = l2.tl;\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction cmpU(_l1, _l2, p) {\n  while(true) {\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      if (l2) {\n        return -1;\n      } else {\n        return 0;\n      }\n    }\n    if (!l2) {\n      return 1;\n    }\n    var c = p(l1.hd, l2.hd);\n    if (c !== 0) {\n      return c;\n    }\n    _l2 = l2.tl;\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction cmp(l1, l2, f) {\n  return cmpU(l1, l2, Curry.__2(f));\n}\n\nfunction eqU(_l1, _l2, p) {\n  while(true) {\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      if (l2) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n    if (!l2) {\n      return false;\n    }\n    if (!p(l1.hd, l2.hd)) {\n      return false;\n    }\n    _l2 = l2.tl;\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction eq(l1, l2, f) {\n  return eqU(l1, l2, Curry.__2(f));\n}\n\nfunction some2U(_l1, _l2, p) {\n  while(true) {\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      return false;\n    }\n    if (!l2) {\n      return false;\n    }\n    if (p(l1.hd, l2.hd)) {\n      return true;\n    }\n    _l2 = l2.tl;\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction some2(l1, l2, p) {\n  return some2U(l1, l2, Curry.__2(p));\n}\n\nfunction hasU(_xs, x, eq) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return false;\n    }\n    if (eq(xs.hd, x)) {\n      return true;\n    }\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction has(xs, x, eq) {\n  return hasU(xs, x, Curry.__2(eq));\n}\n\nfunction getAssocU(_xs, x, eq) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return ;\n    }\n    var match = xs.hd;\n    if (eq(match[0], x)) {\n      return Caml_option.some(match[1]);\n    }\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction getAssoc(xs, x, eq) {\n  return getAssocU(xs, x, Curry.__2(eq));\n}\n\nfunction hasAssocU(_xs, x, eq) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return false;\n    }\n    if (eq(xs.hd[0], x)) {\n      return true;\n    }\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction hasAssoc(xs, x, eq) {\n  return hasAssocU(xs, x, Curry.__2(eq));\n}\n\nfunction removeAssocU(xs, x, eq) {\n  if (!xs) {\n    return /* [] */0;\n  }\n  var l = xs.tl;\n  var pair = xs.hd;\n  if (eq(pair[0], x)) {\n    return l;\n  }\n  var cell = {\n    hd: pair,\n    tl: /* [] */0\n  };\n  var removed = removeAssocAuxWithMap(l, x, cell, eq);\n  if (removed) {\n    return cell;\n  } else {\n    return xs;\n  }\n}\n\nfunction removeAssoc(xs, x, eq) {\n  return removeAssocU(xs, x, Curry.__2(eq));\n}\n\nfunction setAssocU(xs, x, k, eq) {\n  if (!xs) {\n    return {\n            hd: [\n              x,\n              k\n            ],\n            tl: /* [] */0\n          };\n  }\n  var l = xs.tl;\n  var pair = xs.hd;\n  if (eq(pair[0], x)) {\n    return {\n            hd: [\n              x,\n              k\n            ],\n            tl: l\n          };\n  }\n  var cell = {\n    hd: pair,\n    tl: /* [] */0\n  };\n  var replaced = setAssocAuxWithMap(l, x, k, cell, eq);\n  if (replaced) {\n    return cell;\n  } else {\n    return {\n            hd: [\n              x,\n              k\n            ],\n            tl: xs\n          };\n  }\n}\n\nfunction setAssoc(xs, x, k, eq) {\n  return setAssocU(xs, x, k, Curry.__2(eq));\n}\n\nfunction sortU(xs, cmp) {\n  var arr = toArray(xs);\n  Belt_SortArray.stableSortInPlaceByU(arr, cmp);\n  return fromArray(arr);\n}\n\nfunction sort(xs, cmp) {\n  return sortU(xs, Curry.__2(cmp));\n}\n\nfunction getByU(_xs, p) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return ;\n    }\n    var x = xs.hd;\n    if (p(x)) {\n      return Caml_option.some(x);\n    }\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction getBy(xs, p) {\n  return getByU(xs, Curry.__1(p));\n}\n\nfunction keepU(_xs, p) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return /* [] */0;\n    }\n    var t = xs.tl;\n    var h = xs.hd;\n    if (p(h)) {\n      var cell = {\n        hd: h,\n        tl: /* [] */0\n      };\n      copyAuxWitFilter(p, t, cell);\n      return cell;\n    }\n    _xs = t;\n    continue ;\n  };\n}\n\nfunction keep(xs, p) {\n  return keepU(xs, Curry.__1(p));\n}\n\nfunction keepWithIndexU(xs, p) {\n  var _xs = xs;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    var xs$1 = _xs;\n    if (!xs$1) {\n      return /* [] */0;\n    }\n    var t = xs$1.tl;\n    var h = xs$1.hd;\n    if (p(h, i)) {\n      var cell = {\n        hd: h,\n        tl: /* [] */0\n      };\n      copyAuxWithFilterIndex(p, t, cell, i + 1 | 0);\n      return cell;\n    }\n    _i = i + 1 | 0;\n    _xs = t;\n    continue ;\n  };\n}\n\nfunction keepWithIndex(xs, p) {\n  return keepWithIndexU(xs, Curry.__2(p));\n}\n\nfunction keepMapU(_xs, p) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return /* [] */0;\n    }\n    var t = xs.tl;\n    var h = p(xs.hd);\n    if (h !== undefined) {\n      var cell = {\n        hd: Caml_option.valFromOption(h),\n        tl: /* [] */0\n      };\n      copyAuxWitFilterMap(p, t, cell);\n      return cell;\n    }\n    _xs = t;\n    continue ;\n  };\n}\n\nfunction keepMap(xs, p) {\n  return keepMapU(xs, Curry.__1(p));\n}\n\nfunction partitionU(l, p) {\n  if (!l) {\n    return [\n            /* [] */0,\n            /* [] */0\n          ];\n  }\n  var h = l.hd;\n  var nextX = {\n    hd: h,\n    tl: /* [] */0\n  };\n  var nextY = {\n    hd: h,\n    tl: /* [] */0\n  };\n  var b = p(h);\n  partitionAux(p, l.tl, nextX, nextY);\n  if (b) {\n    return [\n            nextX,\n            nextY.tl\n          ];\n  } else {\n    return [\n            nextX.tl,\n            nextY\n          ];\n  }\n}\n\nfunction partition(l, p) {\n  return partitionU(l, Curry.__1(p));\n}\n\nfunction unzip(xs) {\n  if (!xs) {\n    return [\n            /* [] */0,\n            /* [] */0\n          ];\n  }\n  var match = xs.hd;\n  var cellX = {\n    hd: match[0],\n    tl: /* [] */0\n  };\n  var cellY = {\n    hd: match[1],\n    tl: /* [] */0\n  };\n  splitAux(xs.tl, cellX, cellY);\n  return [\n          cellX,\n          cellY\n        ];\n}\n\nfunction zip(l1, l2) {\n  if (!l1) {\n    return /* [] */0;\n  }\n  if (!l2) {\n    return /* [] */0;\n  }\n  var cell = {\n    hd: [\n      l1.hd,\n      l2.hd\n    ],\n    tl: /* [] */0\n  };\n  zipAux(l1.tl, l2.tl, cell);\n  return cell;\n}\n\nvar size = length;\n\nvar filter = keep;\n\nvar filterWithIndex = keepWithIndex;\n\nexport {\n  length ,\n  size ,\n  head ,\n  headExn ,\n  tail ,\n  tailExn ,\n  add ,\n  get ,\n  getExn ,\n  make ,\n  makeByU ,\n  makeBy ,\n  shuffle ,\n  drop ,\n  take ,\n  splitAt ,\n  concat ,\n  concatMany ,\n  reverseConcat ,\n  flatten ,\n  mapU ,\n  map ,\n  zip ,\n  zipByU ,\n  zipBy ,\n  mapWithIndexU ,\n  mapWithIndex ,\n  fromArray ,\n  toArray ,\n  reverse ,\n  mapReverseU ,\n  mapReverse ,\n  forEachU ,\n  forEach ,\n  forEachWithIndexU ,\n  forEachWithIndex ,\n  reduceU ,\n  reduce ,\n  reduceWithIndexU ,\n  reduceWithIndex ,\n  reduceReverseU ,\n  reduceReverse ,\n  mapReverse2U ,\n  mapReverse2 ,\n  forEach2U ,\n  forEach2 ,\n  reduce2U ,\n  reduce2 ,\n  reduceReverse2U ,\n  reduceReverse2 ,\n  everyU ,\n  every ,\n  someU ,\n  some ,\n  every2U ,\n  every2 ,\n  some2U ,\n  some2 ,\n  cmpByLength ,\n  cmpU ,\n  cmp ,\n  eqU ,\n  eq ,\n  hasU ,\n  has ,\n  getByU ,\n  getBy ,\n  keepU ,\n  keep ,\n  filter ,\n  keepWithIndexU ,\n  keepWithIndex ,\n  filterWithIndex ,\n  keepMapU ,\n  keepMap ,\n  partitionU ,\n  partition ,\n  unzip ,\n  getAssocU ,\n  getAssoc ,\n  hasAssocU ,\n  hasAssoc ,\n  removeAssocU ,\n  removeAssoc ,\n  setAssocU ,\n  setAssoc ,\n  sortU ,\n  sort ,\n  \n}\n/* No side effect */\n","\n\nimport * as Curry from \"./curry.js\";\nimport * as Caml_option from \"./caml_option.js\";\n\nfunction make(param) {\n  return {\n          length: 0,\n          first: undefined,\n          last: undefined\n        };\n}\n\nfunction clear(q) {\n  q.length = 0;\n  q.first = undefined;\n  q.last = undefined;\n  \n}\n\nfunction add(q, x) {\n  var cell = {\n    content: x,\n    next: undefined\n  };\n  var last = q.last;\n  if (last !== undefined) {\n    q.length = q.length + 1 | 0;\n    last.next = cell;\n    q.last = cell;\n  } else {\n    q.length = 1;\n    q.first = cell;\n    q.last = cell;\n  }\n  \n}\n\nfunction peek(q) {\n  var v = q.first;\n  if (v !== undefined) {\n    return Caml_option.some(v.content);\n  }\n  \n}\n\nfunction peekUndefined(q) {\n  var v = q.first;\n  if (v !== undefined) {\n    return v.content;\n  }\n  \n}\n\nfunction peekExn(q) {\n  var v = q.first;\n  if (v !== undefined) {\n    return v.content;\n  }\n  throw {\n        RE_EXN_ID: \"Not_found\",\n        Error: new Error()\n      };\n}\n\nfunction pop(q) {\n  var x = q.first;\n  if (x === undefined) {\n    return ;\n  }\n  var next = x.next;\n  if (next === undefined) {\n    clear(q);\n    return Caml_option.some(x.content);\n  } else {\n    q.length = q.length - 1 | 0;\n    q.first = next;\n    return Caml_option.some(x.content);\n  }\n}\n\nfunction popExn(q) {\n  var x = q.first;\n  if (x !== undefined) {\n    var next = x.next;\n    if (next === undefined) {\n      clear(q);\n      return x.content;\n    } else {\n      q.length = q.length - 1 | 0;\n      q.first = next;\n      return x.content;\n    }\n  }\n  throw {\n        RE_EXN_ID: \"Not_found\",\n        Error: new Error()\n      };\n}\n\nfunction popUndefined(q) {\n  var x = q.first;\n  if (x === undefined) {\n    return ;\n  }\n  var next = x.next;\n  if (next === undefined) {\n    clear(q);\n    return x.content;\n  } else {\n    q.length = q.length - 1 | 0;\n    q.first = next;\n    return x.content;\n  }\n}\n\nfunction copy(q) {\n  var qRes = {\n    length: q.length,\n    first: undefined,\n    last: undefined\n  };\n  var _prev;\n  var _cell = q.first;\n  while(true) {\n    var cell = _cell;\n    var prev = _prev;\n    if (cell !== undefined) {\n      var content = cell.content;\n      var res = {\n        content: content,\n        next: undefined\n      };\n      if (prev !== undefined) {\n        prev.next = res;\n      } else {\n        qRes.first = res;\n      }\n      _cell = cell.next;\n      _prev = res;\n      continue ;\n    }\n    qRes.last = prev;\n    return qRes;\n  };\n}\n\nfunction mapU(q, f) {\n  var qRes = {\n    length: q.length,\n    first: undefined,\n    last: undefined\n  };\n  var _prev;\n  var _cell = q.first;\n  while(true) {\n    var cell = _cell;\n    var prev = _prev;\n    if (cell !== undefined) {\n      var content = f(cell.content);\n      var res = {\n        content: content,\n        next: undefined\n      };\n      if (prev !== undefined) {\n        prev.next = res;\n      } else {\n        qRes.first = res;\n      }\n      _cell = cell.next;\n      _prev = res;\n      continue ;\n    }\n    qRes.last = prev;\n    return qRes;\n  };\n}\n\nfunction map(q, f) {\n  return mapU(q, Curry.__1(f));\n}\n\nfunction isEmpty(q) {\n  return q.length === 0;\n}\n\nfunction size(q) {\n  return q.length;\n}\n\nfunction forEachU(q, f) {\n  var _cell = q.first;\n  while(true) {\n    var cell = _cell;\n    if (cell === undefined) {\n      return ;\n    }\n    f(cell.content);\n    _cell = cell.next;\n    continue ;\n  };\n}\n\nfunction forEach(q, f) {\n  return forEachU(q, Curry.__1(f));\n}\n\nfunction reduceU(q, accu, f) {\n  var _accu = accu;\n  var _cell = q.first;\n  while(true) {\n    var cell = _cell;\n    var accu$1 = _accu;\n    if (cell === undefined) {\n      return accu$1;\n    }\n    var accu$2 = f(accu$1, cell.content);\n    _cell = cell.next;\n    _accu = accu$2;\n    continue ;\n  };\n}\n\nfunction reduce(q, accu, f) {\n  return reduceU(q, accu, Curry.__2(f));\n}\n\nfunction transfer(q1, q2) {\n  if (q1.length <= 0) {\n    return ;\n  }\n  var l = q2.last;\n  if (l !== undefined) {\n    q2.length = q2.length + q1.length | 0;\n    l.next = q1.first;\n    q2.last = q1.last;\n    return clear(q1);\n  } else {\n    q2.length = q1.length;\n    q2.first = q1.first;\n    q2.last = q1.last;\n    return clear(q1);\n  }\n}\n\nfunction fillAux(_i, arr, _cell) {\n  while(true) {\n    var cell = _cell;\n    var i = _i;\n    if (cell === undefined) {\n      return ;\n    }\n    arr[i] = cell.content;\n    _cell = cell.next;\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction toArray(x) {\n  var v = new Array(x.length);\n  fillAux(0, v, x.first);\n  return v;\n}\n\nfunction fromArray(arr) {\n  var q = {\n    length: 0,\n    first: undefined,\n    last: undefined\n  };\n  for(var i = 0 ,i_finish = arr.length; i < i_finish; ++i){\n    add(q, arr[i]);\n  }\n  return q;\n}\n\nexport {\n  make ,\n  clear ,\n  isEmpty ,\n  fromArray ,\n  add ,\n  peek ,\n  peekUndefined ,\n  peekExn ,\n  pop ,\n  popUndefined ,\n  popExn ,\n  copy ,\n  size ,\n  mapU ,\n  map ,\n  forEachU ,\n  forEach ,\n  reduceU ,\n  reduce ,\n  transfer ,\n  toArray ,\n  \n}\n/* No side effect */\n","// Generated by ReScript, PLEASE EDIT WITH CARE\n\nimport * as Belt_Float from \"bs-platform/lib/es6/belt_Float.js\";\nimport * as Debug$AcutisLang from \"./Debug.bs.js\";\nimport * as Belt_MutableQueue from \"bs-platform/lib/es6/belt_MutableQueue.js\";\n\nfunction peekCharAt(source, x) {\n  return source.str.charAt(source.position + x | 0);\n}\n\nfunction peekChar(source) {\n  return source.str.charAt(source.position);\n}\n\nfunction skipChar(source) {\n  source.position = source.position + 1 | 0;\n  \n}\n\nfunction readChar(source) {\n  var c = peekChar(source);\n  skipChar(source);\n  return c;\n}\n\nfunction peek(source, until) {\n  var position = source.position;\n  while(!until(source.str.charAt(position))) {\n    position = position + 1 | 0;\n  };\n  return position;\n}\n\nfunction skipBy(source, x) {\n  source.position = source.position + x | 0;\n  \n}\n\nfunction readSubstring(source, until) {\n  var start = source.position;\n  var end = peek(source, until);\n  source.position = end;\n  return source.str.slice(start, end);\n}\n\nfunction readSubstringBy(source, x) {\n  var start = source.position;\n  source.position = source.position + x | 0;\n  return source.str.slice(start, source.position);\n}\n\nfunction endOfNumber(c) {\n  switch (c) {\n    case \"+\" :\n    case \"-\" :\n    case \".\" :\n    case \"0\" :\n    case \"1\" :\n    case \"2\" :\n    case \"3\" :\n    case \"4\" :\n    case \"5\" :\n    case \"6\" :\n    case \"7\" :\n    case \"8\" :\n    case \"9\" :\n    case \"E\" :\n    case \"e\" :\n        return false;\n    default:\n      return true;\n  }\n}\n\nfunction readText(source, tokens) {\n  var loc = source.position;\n  var _position = 0;\n  while(true) {\n    var position = _position;\n    var match = peekCharAt(source, position);\n    switch (match) {\n      case \"\" :\n          Belt_MutableQueue.add(tokens, {\n                TAG: /* Text */0,\n                _0: loc,\n                _1: readSubstringBy(source, position)\n              });\n          return /* EndMode */3;\n      case \"{\" :\n          var match$1 = peekCharAt(source, position + 1 | 0);\n          switch (match$1) {\n            case \"%\" :\n                Belt_MutableQueue.add(tokens, {\n                      TAG: /* Text */0,\n                      _0: loc,\n                      _1: readSubstringBy(source, position)\n                    });\n                skipBy(source, 2);\n                return /* ExpressionMode */1;\n            case \"*\" :\n                Belt_MutableQueue.add(tokens, {\n                      TAG: /* Text */0,\n                      _0: loc,\n                      _1: readSubstringBy(source, position)\n                    });\n                skipBy(source, 2);\n                return /* CommentMode */2;\n            case \"{\" :\n                Belt_MutableQueue.add(tokens, {\n                      TAG: /* Text */0,\n                      _0: loc,\n                      _1: readSubstringBy(source, position)\n                    });\n                skipBy(source, 2);\n                return /* EchoMode */0;\n            default:\n              _position = position + 2 | 0;\n              continue ;\n          }\n      default:\n        _position = position + 1 | 0;\n        continue ;\n    }\n  };\n}\n\nfunction readComment(source, name) {\n  var loc = source.position;\n  var _position = 0;\n  var _nested = 0;\n  while(true) {\n    var nested = _nested;\n    var position = _position;\n    var match = peekCharAt(source, position);\n    switch (match) {\n      case \"\" :\n          return Debug$AcutisLang.unterminatedCommentExn(loc, name);\n      case \"*\" :\n          var match$1 = peekCharAt(source, position + 1 | 0);\n          if (match$1 === \"}\") {\n            if (nested === 0) {\n              var result = readSubstringBy(source, position);\n              skipBy(source, 2);\n              return result;\n            }\n            _nested = nested - 1 | 0;\n            _position = position + 2 | 0;\n            continue ;\n          }\n          _position = position + 2 | 0;\n          continue ;\n      case \"{\" :\n          var match$2 = peekCharAt(source, position + 1 | 0);\n          if (match$2 === \"*\") {\n            _nested = nested + 1 | 0;\n            _position = position + 2 | 0;\n            continue ;\n          }\n          _position = position + 1 | 0;\n          continue ;\n      default:\n        _position = position + 1 | 0;\n        continue ;\n    }\n  };\n}\n\nvar unescapeQuotes = /\\\\\"/g;\n\nfunction readJsonString(source, name) {\n  var loc = source.position;\n  var _position = 0;\n  while(true) {\n    var position = _position;\n    var match = peekCharAt(source, position);\n    switch (match) {\n      case \"\" :\n          return Debug$AcutisLang.unterminatedStringExn(loc, name);\n      case \"\\\"\" :\n          var result = readSubstringBy(source, position).replace(unescapeQuotes, \"\\\"\");\n          skipChar(source);\n          return result;\n      case \"\\\\\" :\n          var match$1 = peekCharAt(source, position + 1 | 0);\n          switch (match$1) {\n            case \"\\\"\" :\n            case \"\\\\\" :\n                _position = position + 2 | 0;\n                continue ;\n            default:\n              _position = position + 1 | 0;\n              continue ;\n          }\n      default:\n        _position = position + 1 | 0;\n        continue ;\n    }\n  };\n}\n\nfunction readNumber(source, name) {\n  var loc = source.position;\n  var num = readSubstring(source, endOfNumber);\n  var num$1 = Belt_Float.fromString(num);\n  if (num$1 !== undefined) {\n    return num$1;\n  } else {\n    return Debug$AcutisLang.illegalIdentifierExn(loc, name, num);\n  }\n}\n\nvar identifierChar = /^[a-zA-Z0-9_]$/;\n\nfunction endOfIdentifier(s) {\n  return !identifierChar.test(s);\n}\n\nvar identifierStartChar = /^[a-z_]$/;\n\nvar componentStart = /^[A-Z]$/;\n\nfunction readIdentifier(source, loc) {\n  var s = readSubstring(source, endOfIdentifier);\n  switch (s) {\n    case \"false\" :\n        return {\n                TAG: /* False */5,\n                _0: loc\n              };\n    case \"null\" :\n        return {\n                TAG: /* Null */6,\n                _0: loc\n              };\n    case \"true\" :\n        return {\n                TAG: /* True */4,\n                _0: loc\n              };\n    default:\n      return {\n              TAG: /* Identifier */18,\n              _0: loc,\n              _1: s\n            };\n  }\n}\n\nfunction makeExpression(source, tokens, name, until) {\n  var loop = true;\n  while(loop) {\n    var loc = source.position;\n    var c = peekChar(source);\n    var exit = 0;\n    if (c === until) {\n      skipChar(source);\n      loop = false;\n    } else {\n      switch (c) {\n        case \"\" :\n            Debug$AcutisLang.unexpectedEofExn(loc, name);\n            break;\n        case \"\\t\" :\n        case \"\\n\" :\n        case \"\\r\" :\n        case \" \" :\n            skipChar(source);\n            break;\n        case \"\\\"\" :\n            skipChar(source);\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* String */2,\n                  _0: loc,\n                  _1: readJsonString(source, name)\n                });\n            break;\n        case \"#\" :\n            skipChar(source);\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* Block */16,\n                  _0: loc\n                });\n            break;\n        case \"&\" :\n            skipChar(source);\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* Ampersand */21,\n                  _0: loc\n                });\n            break;\n        case \",\" :\n            skipChar(source);\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* Comma */7,\n                  _0: loc\n                });\n            break;\n        case \".\" :\n            var c$1 = readSubstringBy(source, 3);\n            if (c$1 === \"...\") {\n              Belt_MutableQueue.add(tokens, {\n                    TAG: /* Spread */13,\n                    _0: loc\n                  });\n            } else {\n              Debug$AcutisLang.unexpectedCharacterExn(loc, name, c$1, \"...\");\n            }\n            break;\n        case \"/\" :\n            skipChar(source);\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* Slash */15,\n                  _0: loc\n                });\n            break;\n        case \"-\" :\n        case \"0\" :\n        case \"1\" :\n        case \"2\" :\n        case \"3\" :\n        case \"4\" :\n        case \"5\" :\n        case \"6\" :\n        case \"7\" :\n        case \"8\" :\n        case \"9\" :\n            exit = 1;\n            break;\n        case \":\" :\n            skipChar(source);\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* Colon */8,\n                  _0: loc\n                });\n            break;\n        case \"=\" :\n            skipChar(source);\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* Equals */17,\n                  _0: loc\n                });\n            break;\n        case \"?\" :\n            skipChar(source);\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* Question */20,\n                  _0: loc\n                });\n            break;\n        case \"[\" :\n            skipChar(source);\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* OpenBracket */9,\n                  _0: loc\n                });\n            break;\n        case \"]\" :\n            skipChar(source);\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* CloseBracket */10,\n                  _0: loc\n                });\n            break;\n        case \"{\" :\n            skipChar(source);\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* OpenBrace */11,\n                  _0: loc\n                });\n            break;\n        case \"}\" :\n            skipChar(source);\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* CloseBrace */12,\n                  _0: loc\n                });\n            break;\n        case \"~\" :\n            skipChar(source);\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* Tilde */19,\n                  _0: loc\n                });\n            break;\n        default:\n          if (identifierStartChar.test(c)) {\n            Belt_MutableQueue.add(tokens, readIdentifier(source, loc));\n          } else if (componentStart.test(c)) {\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* ComponentName */14,\n                  _0: loc,\n                  _1: readSubstring(source, endOfIdentifier)\n                });\n          } else {\n            Debug$AcutisLang.invalidCharacterExn(loc, name, c);\n          }\n      }\n    }\n    if (exit === 1) {\n      Belt_MutableQueue.add(tokens, {\n            TAG: /* Number */3,\n            _0: loc,\n            _1: readNumber(source, name)\n          });\n    }\n    \n  };\n  \n}\n\nfunction make(name, str) {\n  var source = {\n    str: str,\n    position: 0\n  };\n  var tokens = Belt_MutableQueue.make(undefined);\n  var _mode = readText(source, tokens);\n  while(true) {\n    var mode = _mode;\n    switch (mode) {\n      case /* EchoMode */0 :\n          var echoLoc = source.position;\n          if (peekChar(source) === \"~\") {\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* Tilde */19,\n                  _0: source.position\n                });\n            skipChar(source);\n          }\n          Belt_MutableQueue.add(tokens, {\n                TAG: /* Echo */22,\n                _0: echoLoc\n              });\n          makeExpression(source, tokens, name, \"}\");\n          var c = readChar(source);\n          if (c !== \"}\") {\n            return Debug$AcutisLang.unexpectedCharacterExn(source.position, name, c, \"}\");\n          }\n          _mode = readText(source, tokens);\n          continue ;\n      case /* ExpressionMode */1 :\n          makeExpression(source, tokens, name, \"%\");\n          var c$1 = readChar(source);\n          if (c$1 !== \"}\") {\n            return Debug$AcutisLang.unexpectedCharacterExn(source.position, name, c$1, \"}\");\n          }\n          _mode = readText(source, tokens);\n          continue ;\n      case /* CommentMode */2 :\n          var loc = source.position;\n          Belt_MutableQueue.add(tokens, {\n                TAG: /* Comment */1,\n                _0: loc,\n                _1: readComment(source, name)\n              });\n          _mode = readText(source, tokens);\n          continue ;\n      case /* EndMode */3 :\n          Belt_MutableQueue.add(tokens, {\n                TAG: /* EndOfFile */23,\n                _0: source.position\n              });\n          return {\n                  tokens: tokens,\n                  name: name\n                };\n      \n    }\n  };\n}\n\nfunction peekExn(x) {\n  return Belt_MutableQueue.peekExn(x.tokens);\n}\n\nfunction popExn(x) {\n  return Belt_MutableQueue.popExn(x.tokens);\n}\n\nfunction name(x) {\n  return x.name;\n}\n\nfunction debugToArray(x) {\n  return Belt_MutableQueue.toArray(x.tokens);\n}\n\nexport {\n  make ,\n  peekExn ,\n  popExn ,\n  name ,\n  debugToArray ,\n  \n}\n/* No side effect */\n","\n\n\nfunction fromString(i) {\n  var i$1 = parseFloat(i);\n  if (isNaN(i$1)) {\n    return ;\n  } else {\n    return i$1;\n  }\n}\n\nexport {\n  fromString ,\n  \n}\n/* No side effect */\n","\n\nimport * as Caml_option from \"./caml_option.js\";\nimport * as Caml_exceptions from \"./caml_exceptions.js\";\n\nvar $$Error = Caml_exceptions.create(\"Caml_js_exceptions.Error\");\n\nfunction internalToOCamlException(e) {\n  if (Caml_exceptions.caml_is_extension(e)) {\n    return e;\n  } else {\n    return {\n            RE_EXN_ID: $$Error,\n            _1: e\n          };\n  }\n}\n\nfunction caml_as_js_exn(exn) {\n  if (exn.RE_EXN_ID === $$Error) {\n    return Caml_option.some(exn._1);\n  }\n  \n}\n\nexport {\n  $$Error ,\n  internalToOCamlException ,\n  caml_as_js_exn ,\n  \n}\n/* No side effect */\n","// Generated by ReScript, PLEASE EDIT WITH CARE\n\nimport * as Debug$AcutisLang from \"./Debug.bs.js\";\nimport * as Lexer$AcutisLang from \"./Lexer.bs.js\";\nimport * as Belt_MutableQueue from \"bs-platform/lib/es6/belt_MutableQueue.js\";\nimport * as Caml_js_exceptions from \"bs-platform/lib/es6/caml_js_exceptions.js\";\nimport * as Acutis_Types$AcutisLang from \"./Acutis_Types.bs.js\";\n\nfunction parseNode(t, tokens) {\n  switch (t.TAG | 0) {\n    case /* String */2 :\n        return {\n                NAME: \"String\",\n                VAL: [\n                  t._0,\n                  t._1\n                ]\n              };\n    case /* Number */3 :\n        return {\n                NAME: \"Number\",\n                VAL: [\n                  t._0,\n                  t._1\n                ]\n              };\n    case /* True */4 :\n        return {\n                NAME: \"True\",\n                VAL: t._0\n              };\n    case /* False */5 :\n        return {\n                NAME: \"False\",\n                VAL: t._0\n              };\n    case /* Null */6 :\n        return {\n                NAME: \"Null\",\n                VAL: t._0\n              };\n    case /* OpenBracket */9 :\n        var loc = t._0;\n        var t$1 = Lexer$AcutisLang.popExn(tokens);\n        if (t$1.TAG === /* CloseBracket */10) {\n          return {\n                  NAME: \"Array\",\n                  VAL: [\n                    loc,\n                    []\n                  ]\n                };\n        } else {\n          var q = Belt_MutableQueue.make(undefined);\n          Belt_MutableQueue.add(q, parseNode(t$1, tokens));\n          var _param;\n          while(true) {\n            var t$2 = Lexer$AcutisLang.popExn(tokens);\n            switch (t$2.TAG | 0) {\n              case /* Comma */7 :\n                  var t$3 = Lexer$AcutisLang.popExn(tokens);\n                  if (t$3.TAG === /* Spread */13) {\n                    var t$4 = Lexer$AcutisLang.popExn(tokens);\n                    if (t$4.TAG !== /* Identifier */18) {\n                      return Debug$AcutisLang.unexpectedTokenExn(t$4, Lexer$AcutisLang.name(tokens));\n                    }\n                    var t$5 = Lexer$AcutisLang.popExn(tokens);\n                    if (t$5.TAG === /* CloseBracket */10) {\n                      return {\n                              NAME: \"ArrayWithTailBinding\",\n                              VAL: [\n                                loc,\n                                Belt_MutableQueue.toArray(q),\n                                {\n                                  NAME: \"Binding\",\n                                  VAL: [\n                                    t$4._0,\n                                    t$4._1\n                                  ]\n                                }\n                              ]\n                            };\n                    } else {\n                      return Debug$AcutisLang.unexpectedTokenExn(t$5, Lexer$AcutisLang.name(tokens));\n                    }\n                  }\n                  Belt_MutableQueue.add(q, parseNode(t$3, tokens));\n                  _param = undefined;\n                  continue ;\n              case /* CloseBracket */10 :\n                  return {\n                          NAME: \"Array\",\n                          VAL: [\n                            loc,\n                            Belt_MutableQueue.toArray(q)\n                          ]\n                        };\n              default:\n                return Debug$AcutisLang.unexpectedTokenExn(t$2, Lexer$AcutisLang.name(tokens));\n            }\n          };\n        }\n    case /* OpenBrace */11 :\n        var loc$1 = t._0;\n        var t$6 = Lexer$AcutisLang.popExn(tokens);\n        if (t$6.TAG === /* CloseBrace */12) {\n          return {\n                  NAME: \"Object\",\n                  VAL: [\n                    loc$1,\n                    []\n                  ]\n                };\n        } else {\n          var q$1 = Belt_MutableQueue.make(undefined);\n          Belt_MutableQueue.add(q$1, parseObjectKeyValue(t$6, tokens));\n          var _param$1;\n          while(true) {\n            var t$7 = Lexer$AcutisLang.popExn(tokens);\n            switch (t$7.TAG | 0) {\n              case /* Comma */7 :\n                  Belt_MutableQueue.add(q$1, parseObjectKeyValue(Lexer$AcutisLang.popExn(tokens), tokens));\n                  _param$1 = undefined;\n                  continue ;\n              case /* CloseBrace */12 :\n                  return {\n                          NAME: \"Object\",\n                          VAL: [\n                            loc$1,\n                            Belt_MutableQueue.toArray(q$1)\n                          ]\n                        };\n              default:\n                return Debug$AcutisLang.unexpectedTokenExn(t$7, Lexer$AcutisLang.name(tokens));\n            }\n          };\n        }\n    case /* Identifier */18 :\n        return {\n                NAME: \"Binding\",\n                VAL: [\n                  t._0,\n                  t._1\n                ]\n              };\n    default:\n      return Debug$AcutisLang.unexpectedTokenExn(t, Lexer$AcutisLang.name(tokens));\n  }\n}\n\nfunction parseObjectKeyValue(t, tokens) {\n  switch (t.TAG | 0) {\n    case /* String */2 :\n        var t$1 = Lexer$AcutisLang.popExn(tokens);\n        if (t$1.TAG === /* Colon */8) {\n          return [\n                  t._1,\n                  parseNode(Lexer$AcutisLang.popExn(tokens), tokens)\n                ];\n        } else {\n          return Debug$AcutisLang.unexpectedTokenExn(t$1, Lexer$AcutisLang.name(tokens));\n        }\n    case /* Identifier */18 :\n        var key = t._1;\n        var match = Lexer$AcutisLang.peekExn(tokens);\n        if (match.TAG !== /* Colon */8) {\n          return [\n                  key,\n                  {\n                    NAME: \"Binding\",\n                    VAL: [\n                      t._0,\n                      key\n                    ]\n                  }\n                ];\n        }\n        Lexer$AcutisLang.popExn(tokens);\n        return [\n                key,\n                parseNode(Lexer$AcutisLang.popExn(tokens), tokens)\n              ];\n    default:\n      return Debug$AcutisLang.unexpectedTokenExn(t, Lexer$AcutisLang.name(tokens));\n  }\n}\n\nfunction make(tokens) {\n  var head = parseNode(Lexer$AcutisLang.popExn(tokens), tokens);\n  var q = Belt_MutableQueue.make(undefined);\n  var _param;\n  while(true) {\n    var match = Lexer$AcutisLang.peekExn(tokens);\n    if (match.TAG !== /* Comma */7) {\n      return /* NonEmpty */{\n              _0: head,\n              _1: Belt_MutableQueue.toArray(q)\n            };\n    }\n    Lexer$AcutisLang.popExn(tokens);\n    Belt_MutableQueue.add(q, parseNode(Lexer$AcutisLang.popExn(tokens), tokens));\n    _param = undefined;\n    continue ;\n  };\n}\n\nfunction parseBindingName(tokens) {\n  var t = Lexer$AcutisLang.popExn(tokens);\n  if (t.TAG === /* Identifier */18) {\n    return [\n            t._0,\n            t._1\n          ];\n  } else {\n    return Debug$AcutisLang.unexpectedTokenExn(t, Lexer$AcutisLang.name(tokens));\n  }\n}\n\nfunction parseCommaSequence(tokens) {\n  var head = parseBindingName(tokens);\n  var q = Belt_MutableQueue.make(undefined);\n  var _param;\n  while(true) {\n    var match = Lexer$AcutisLang.peekExn(tokens);\n    if (match.TAG !== /* Comma */7) {\n      return /* NonEmpty */{\n              _0: head,\n              _1: Belt_MutableQueue.toArray(q)\n            };\n    }\n    Lexer$AcutisLang.popExn(tokens);\n    Belt_MutableQueue.add(q, parseBindingName(tokens));\n    _param = undefined;\n    continue ;\n  };\n}\n\nfunction parseEchoAux(t, tokens, esc) {\n  switch (t.TAG | 0) {\n    case /* String */2 :\n        return {\n                TAG: /* String */2,\n                _0: t._1,\n                _1: esc\n              };\n    case /* Number */3 :\n        return {\n                TAG: /* Number */3,\n                _0: t._1,\n                _1: esc\n              };\n    case /* Identifier */18 :\n        return {\n                TAG: /* Binding */0,\n                _0: t._0,\n                _1: t._1,\n                _2: esc\n              };\n    default:\n      return Debug$AcutisLang.unexpectedTokenExn(t, Lexer$AcutisLang.name(tokens));\n  }\n}\n\nfunction parseEcho(tokens) {\n  var t = Lexer$AcutisLang.popExn(tokens);\n  switch (t.TAG | 0) {\n    case /* ComponentName */14 :\n        return {\n                TAG: /* Child */1,\n                _0: t._0,\n                _1: t._1\n              };\n    case /* Ampersand */21 :\n        return parseEchoAux(Lexer$AcutisLang.popExn(tokens), tokens, /* NoEscape */0);\n    default:\n      return parseEchoAux(t, tokens, /* Escape */1);\n  }\n}\n\nfunction parseEchoes(tokens) {\n  var head = parseEcho(tokens);\n  var q = Belt_MutableQueue.make(undefined);\n  var _param;\n  while(true) {\n    var t = Lexer$AcutisLang.popExn(tokens);\n    switch (t.TAG | 0) {\n      case /* Text */0 :\n      case /* Tilde */19 :\n          return [\n                  t,\n                  /* NonEmpty */{\n                    _0: head,\n                    _1: Belt_MutableQueue.toArray(q)\n                  }\n                ];\n      case /* Question */20 :\n          Belt_MutableQueue.add(q, parseEcho(tokens));\n          _param = undefined;\n          continue ;\n      default:\n        return Debug$AcutisLang.unexpectedTokenExn(t, Lexer$AcutisLang.name(tokens));\n    }\n  };\n}\n\nfunction endOfMatchMap(t) {\n  switch (t.TAG | 0) {\n    case /* Slash */15 :\n        return true;\n    case /* Identifier */18 :\n        if (t._1 === \"with\") {\n          return true;\n        } else {\n          return false;\n        }\n    default:\n      return false;\n  }\n}\n\nfunction endOfFile(t) {\n  if (t.TAG === /* EndOfFile */23) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction slash(t) {\n  if (t.TAG === /* Slash */15) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction parse(t, tokens, until) {\n  var q = Belt_MutableQueue.make(undefined);\n  var _t = t;\n  while(true) {\n    var t$1 = _t;\n    if (until(t$1)) {\n      return [\n              t$1,\n              Belt_MutableQueue.toArray(q)\n            ];\n    }\n    switch (t$1.TAG | 0) {\n      case /* Text */0 :\n          var x = t$1._1;\n          var t$2 = Lexer$AcutisLang.popExn(tokens);\n          if (t$2.TAG === /* Tilde */19) {\n            Belt_MutableQueue.add(q, {\n                  TAG: /* Text */0,\n                  _0: x,\n                  _1: /* TrimEnd */1\n                });\n            _t = Lexer$AcutisLang.popExn(tokens);\n            continue ;\n          }\n          Belt_MutableQueue.add(q, {\n                TAG: /* Text */0,\n                _0: x,\n                _1: /* NoTrim */3\n              });\n          _t = t$2;\n          continue ;\n      case /* Comment */1 :\n          _t = Lexer$AcutisLang.popExn(tokens);\n          continue ;\n      case /* ComponentName */14 :\n          Belt_MutableQueue.add(q, parseComponent(t$1._0, t$1._1, tokens));\n          _t = Lexer$AcutisLang.popExn(tokens);\n          continue ;\n      case /* Identifier */18 :\n          var loc = t$1._0;\n          switch (t$1._1) {\n            case \"map\" :\n                var x$1 = parseNode(Lexer$AcutisLang.popExn(tokens), tokens);\n                var variant = x$1.NAME;\n                var pattern = variant === \"Array\" || variant === \"ArrayWithTailBinding\" || variant === \"Binding\" ? x$1 : Debug$AcutisLang.badMapTypeParseExn(x$1, Lexer$AcutisLang.name(tokens));\n                var withs = parseWithBlocks(tokens, \"map\");\n                Belt_MutableQueue.add(q, {\n                      TAG: /* Map */3,\n                      _0: loc,\n                      _1: pattern,\n                      _2: withs\n                    });\n                _t = Lexer$AcutisLang.popExn(tokens);\n                continue ;\n            case \"match\" :\n                var identifiers = parseCommaSequence(tokens);\n                var withs$1 = parseWithBlocks(tokens, \"match\");\n                Belt_MutableQueue.add(q, {\n                      TAG: /* Match */2,\n                      _0: loc,\n                      _1: identifiers,\n                      _2: withs$1\n                    });\n                _t = Lexer$AcutisLang.popExn(tokens);\n                continue ;\n            default:\n              return Debug$AcutisLang.unexpectedTokenExn(t$1, Lexer$AcutisLang.name(tokens));\n          }\n      case /* Tilde */19 :\n          var t$3 = Lexer$AcutisLang.popExn(tokens);\n          if (t$3.TAG !== /* Text */0) {\n            return Debug$AcutisLang.unexpectedTokenExn(t$3, Lexer$AcutisLang.name(tokens));\n          }\n          var x$2 = t$3._1;\n          var t$4 = Lexer$AcutisLang.popExn(tokens);\n          if (t$4.TAG === /* Tilde */19) {\n            Belt_MutableQueue.add(q, {\n                  TAG: /* Text */0,\n                  _0: x$2,\n                  _1: /* TrimBoth */2\n                });\n            _t = Lexer$AcutisLang.popExn(tokens);\n            continue ;\n          }\n          Belt_MutableQueue.add(q, {\n                TAG: /* Text */0,\n                _0: x$2,\n                _1: /* TrimStart */0\n              });\n          _t = t$4;\n          continue ;\n      case /* Echo */22 :\n          var match = parseEchoes(tokens);\n          Belt_MutableQueue.add(q, {\n                TAG: /* Echo */1,\n                _0: t$1._0,\n                _1: match[1]\n              });\n          _t = match[0];\n          continue ;\n      default:\n        return Debug$AcutisLang.unexpectedTokenExn(t$1, Lexer$AcutisLang.name(tokens));\n    }\n  };\n}\n\nfunction parseWithBlock(tokens) {\n  var head = make(tokens);\n  var q = Belt_MutableQueue.make(undefined);\n  var _param;\n  while(true) {\n    var t = Lexer$AcutisLang.popExn(tokens);\n    if (t.TAG === /* Identifier */18 && t._1 === \"with\") {\n      Belt_MutableQueue.add(q, make(tokens));\n      _param = undefined;\n      continue ;\n    }\n    var match = parse(t, tokens, endOfMatchMap);\n    return [\n            match[0],\n            {\n              patterns: /* NonEmpty */{\n                _0: head,\n                _1: Belt_MutableQueue.toArray(q)\n              },\n              ast: match[1]\n            }\n          ];\n  };\n}\n\nfunction parseWithBlocks(tokens, block) {\n  var t = Lexer$AcutisLang.popExn(tokens);\n  if (t.TAG !== /* Identifier */18) {\n    return Debug$AcutisLang.unexpectedTokenExn(t, Lexer$AcutisLang.name(tokens));\n  }\n  if (t._1 !== \"with\") {\n    return Debug$AcutisLang.unexpectedTokenExn(t, Lexer$AcutisLang.name(tokens));\n  }\n  var match = parseWithBlock(tokens);\n  var head = match[1];\n  var q = Belt_MutableQueue.make(undefined);\n  var _t = match[0];\n  while(true) {\n    var t$1 = _t;\n    if (t$1.TAG === /* Slash */15) {\n      var t$2 = Lexer$AcutisLang.popExn(tokens);\n      if (t$2.TAG === /* Identifier */18 && t$2._1 === block) {\n        return /* NonEmpty */{\n                _0: head,\n                _1: Belt_MutableQueue.toArray(q)\n              };\n      } else {\n        return Debug$AcutisLang.unexpectedTokenExn(t$2, Lexer$AcutisLang.name(tokens));\n      }\n    }\n    var match$1 = parseWithBlock(tokens);\n    Belt_MutableQueue.add(q, match$1[1]);\n    _t = match$1[0];\n    continue ;\n  };\n}\n\nfunction parseComponent(loc, name, tokens) {\n  var match = parseProps(tokens);\n  var children = match[2];\n  var props = match[1];\n  var t = match[0];\n  if (t.TAG === /* Slash */15) {\n    return {\n            TAG: /* Component */4,\n            loc: loc,\n            name: name,\n            props: Belt_MutableQueue.toArray(props),\n            children: Belt_MutableQueue.toArray(children)\n          };\n  }\n  var match$1 = parse(t, tokens, slash);\n  var t$1 = Lexer$AcutisLang.popExn(tokens);\n  if (t$1.TAG === /* ComponentName */14 && name === t$1._1) {\n    Belt_MutableQueue.add(children, [\n          \"Children\",\n          {\n            TAG: /* ChildBlock */1,\n            _0: match$1[1]\n          }\n        ]);\n    return {\n            TAG: /* Component */4,\n            loc: loc,\n            name: name,\n            props: Belt_MutableQueue.toArray(props),\n            children: Belt_MutableQueue.toArray(children)\n          };\n  } else {\n    return Debug$AcutisLang.unexpectedTokenExn(t$1, Lexer$AcutisLang.name(tokens));\n  }\n}\n\nfunction parseProps(tokens) {\n  var props = Belt_MutableQueue.make(undefined);\n  var children = Belt_MutableQueue.make(undefined);\n  var _t = Lexer$AcutisLang.popExn(tokens);\n  while(true) {\n    var t = _t;\n    switch (t.TAG | 0) {\n      case /* ComponentName */14 :\n          var name = t._1;\n          var t$1 = Lexer$AcutisLang.popExn(tokens);\n          if (t$1.TAG === /* Equals */17) {\n            var t$2 = Lexer$AcutisLang.popExn(tokens);\n            switch (t$2.TAG | 0) {\n              case /* ComponentName */14 :\n                  Belt_MutableQueue.add(children, [\n                        name,\n                        {\n                          TAG: /* ChildName */0,\n                          _0: t$2._1\n                        }\n                      ]);\n                  _t = Lexer$AcutisLang.popExn(tokens);\n                  continue ;\n              case /* Block */16 :\n                  var match = parse(Lexer$AcutisLang.popExn(tokens), tokens, slash);\n                  var t$3 = Lexer$AcutisLang.popExn(tokens);\n                  if (t$3.TAG !== /* Block */16) {\n                    return Debug$AcutisLang.unexpectedTokenExn(t$3, Lexer$AcutisLang.name(tokens));\n                  }\n                  Belt_MutableQueue.add(children, [\n                        name,\n                        {\n                          TAG: /* ChildBlock */1,\n                          _0: match[1]\n                        }\n                      ]);\n                  _t = Lexer$AcutisLang.popExn(tokens);\n                  continue ;\n              default:\n                return Debug$AcutisLang.unexpectedTokenExn(t$2, Lexer$AcutisLang.name(tokens));\n            }\n          } else {\n            Belt_MutableQueue.add(children, [\n                  name,\n                  {\n                    TAG: /* ChildName */0,\n                    _0: name\n                  }\n                ]);\n            _t = t$1;\n            continue ;\n          }\n      case /* Identifier */18 :\n          var key = t._1;\n          var t$4 = Lexer$AcutisLang.popExn(tokens);\n          if (t$4.TAG === /* Equals */17) {\n            var prop = parseNode(Lexer$AcutisLang.popExn(tokens), tokens);\n            Belt_MutableQueue.add(props, [\n                  key,\n                  prop\n                ]);\n            _t = Lexer$AcutisLang.popExn(tokens);\n            continue ;\n          }\n          Belt_MutableQueue.add(props, [\n                key,\n                {\n                  NAME: \"Binding\",\n                  VAL: [\n                    t._0,\n                    key\n                  ]\n                }\n              ]);\n          _t = t$4;\n          continue ;\n      default:\n        return [\n                t,\n                props,\n                children\n              ];\n    }\n  };\n}\n\nfunction makeAst(name, source) {\n  try {\n    var tokens = Lexer$AcutisLang.make(name, source);\n    var match = parse(Lexer$AcutisLang.popExn(tokens), tokens, endOfFile);\n    return Acutis_Types$AcutisLang.Valid.make({\n                NAME: \"data\",\n                VAL: {\n                  ast: match[1],\n                  name: name\n                }\n              });\n  }\n  catch (raw_e){\n    var e = Caml_js_exceptions.internalToOCamlException(raw_e);\n    if (e.RE_EXN_ID === Debug$AcutisLang.CompileError) {\n      return Acutis_Types$AcutisLang.Valid.make({\n                  NAME: \"errors\",\n                  VAL: e._1\n                });\n    } else {\n      return Acutis_Types$AcutisLang.Valid.make({\n                  NAME: \"errors\",\n                  VAL: Debug$AcutisLang.compileExn(e, name)\n                });\n    }\n  }\n}\n\nfunction make$1(name, source) {\n  var ast = makeAst(name, source);\n  return function (env, props, templates) {\n    return env.render(ast, props, templates);\n  };\n}\n\nfunction makeAst$1(source, name) {\n  return makeAst(name, source);\n}\n\nfunction make$2(source, name) {\n  return make$1(name, source);\n}\n\nvar Js = {\n  makeAst: makeAst$1,\n  make: make$2\n};\n\nvar Pattern = {\n  make: make\n};\n\nexport {\n  Pattern ,\n  makeAst ,\n  make$1 as make,\n  Js ,\n  \n}\n/* No side effect */\n","\n\nimport * as Caml_option from \"./caml_option.js\";\n\nfunction get(dict, k) {\n  if ((k in dict)) {\n    return Caml_option.some(dict[k]);\n  }\n  \n}\n\nvar unsafeDeleteKey = (function (dict,key){\n      delete dict[key];\n     });\n\nfunction entries(dict) {\n  var keys = Object.keys(dict);\n  var l = keys.length;\n  var values = new Array(l);\n  for(var i = 0; i < l; ++i){\n    var key = keys[i];\n    values[i] = [\n      key,\n      dict[key]\n    ];\n  }\n  return values;\n}\n\nfunction values(dict) {\n  var keys = Object.keys(dict);\n  var l = keys.length;\n  var values$1 = new Array(l);\n  for(var i = 0; i < l; ++i){\n    values$1[i] = dict[keys[i]];\n  }\n  return values$1;\n}\n\nfunction fromList(entries) {\n  var dict = {};\n  var _param = entries;\n  while(true) {\n    var param = _param;\n    if (!param) {\n      return dict;\n    }\n    var match = param.hd;\n    dict[match[0]] = match[1];\n    _param = param.tl;\n    continue ;\n  };\n}\n\nfunction fromArray(entries) {\n  var dict = {};\n  var l = entries.length;\n  for(var i = 0; i < l; ++i){\n    var match = entries[i];\n    dict[match[0]] = match[1];\n  }\n  return dict;\n}\n\nfunction map(f, source) {\n  var target = {};\n  var keys = Object.keys(source);\n  var l = keys.length;\n  for(var i = 0; i < l; ++i){\n    var key = keys[i];\n    target[key] = f(source[key]);\n  }\n  return target;\n}\n\nexport {\n  get ,\n  unsafeDeleteKey ,\n  entries ,\n  values ,\n  fromList ,\n  fromArray ,\n  map ,\n  \n}\n/* No side effect */\n","\n\nimport * as Caml_option from \"./caml_option.js\";\n\nfunction classify(x) {\n  var ty = typeof x;\n  if (ty === \"string\") {\n    return {\n            TAG: /* JSONString */0,\n            _0: x\n          };\n  } else if (ty === \"number\") {\n    return {\n            TAG: /* JSONNumber */1,\n            _0: x\n          };\n  } else if (ty === \"boolean\") {\n    if (x === true) {\n      return /* JSONTrue */1;\n    } else {\n      return /* JSONFalse */0;\n    }\n  } else if (x === null) {\n    return /* JSONNull */2;\n  } else if (Array.isArray(x)) {\n    return {\n            TAG: /* JSONArray */3,\n            _0: x\n          };\n  } else {\n    return {\n            TAG: /* JSONObject */2,\n            _0: x\n          };\n  }\n}\n\nfunction test(x, v) {\n  switch (v) {\n    case /* String */0 :\n        return typeof x === \"string\";\n    case /* Number */1 :\n        return typeof x === \"number\";\n    case /* Object */2 :\n        if (x !== null && typeof x === \"object\") {\n          return !Array.isArray(x);\n        } else {\n          return false;\n        }\n    case /* Array */3 :\n        return Array.isArray(x);\n    case /* Boolean */4 :\n        return typeof x === \"boolean\";\n    case /* Null */5 :\n        return x === null;\n    \n  }\n}\n\nfunction decodeString(json) {\n  if (typeof json === \"string\") {\n    return json;\n  }\n  \n}\n\nfunction decodeNumber(json) {\n  if (typeof json === \"number\") {\n    return json;\n  }\n  \n}\n\nfunction decodeObject(json) {\n  if (typeof json === \"object\" && !Array.isArray(json) && json !== null) {\n    return Caml_option.some(json);\n  }\n  \n}\n\nfunction decodeArray(json) {\n  if (Array.isArray(json)) {\n    return json;\n  }\n  \n}\n\nfunction decodeBoolean(json) {\n  if (typeof json === \"boolean\") {\n    return json;\n  }\n  \n}\n\nfunction decodeNull(json) {\n  if (json === null) {\n    return null;\n  }\n  \n}\n\nvar patch = (function (json) {\n  var x = [json];\n  var q = [{ kind: 0, i: 0, parent: x }];\n  while (q.length !== 0) {\n    // begin pop the stack\n    var cur = q[q.length - 1];\n    if (cur.kind === 0) {\n      cur.val = cur.parent[cur.i]; // patch the undefined value for array\n      if (++cur.i === cur.parent.length) {\n        q.pop();\n      }\n    } else {\n      q.pop();\n    }\n    // finish\n    var task = cur.val;\n    if (typeof task === \"object\") {\n      if (Array.isArray(task) && task.length !== 0) {\n        q.push({ kind: 0, i: 0, parent: task, val: undefined });\n      } else {\n        for (var k in task) {\n          if (k === \"RE_PRIVATE_NONE\") {\n            if (cur.kind === 0) {\n              cur.parent[cur.i - 1] = undefined;\n            } else {\n              cur.parent[cur.i] = undefined;\n            }\n            continue;\n          }\n          q.push({ kind: 1, i: k, parent: task, val: task[k] });\n        }\n      }\n    }\n  }\n  return x[0];\n});\n\nfunction serializeExn(x) {\n  return (function(obj){\n  var output= JSON.stringify(obj,function(_,value){\n      if(value===undefined){\n          return {RE_PRIVATE_NONE : true}\n      }\n    return value\n  });\n  \n if(output === undefined){\n   // JSON.stringify will raise TypeError when it detects cylic objects\n   throw new TypeError(\"output is undefined\")\n }\n return output \n })(x);\n}\n\nfunction deserializeUnsafe(s) {\n  return patch(JSON.parse(s));\n}\n\nexport {\n  classify ,\n  test ,\n  decodeString ,\n  decodeNumber ,\n  decodeObject ,\n  decodeArray ,\n  decodeBoolean ,\n  decodeNull ,\n  deserializeUnsafe ,\n  serializeExn ,\n  \n}\n/* No side effect */\n","\n\nimport * as Curry from \"./curry.js\";\n\nfunction getExn(x) {\n  if (x.TAG === /* Ok */0) {\n    return x._0;\n  }\n  throw {\n        RE_EXN_ID: \"Not_found\",\n        Error: new Error()\n      };\n}\n\nfunction mapWithDefaultU(opt, $$default, f) {\n  if (opt.TAG === /* Ok */0) {\n    return f(opt._0);\n  } else {\n    return $$default;\n  }\n}\n\nfunction mapWithDefault(opt, $$default, f) {\n  return mapWithDefaultU(opt, $$default, Curry.__1(f));\n}\n\nfunction mapU(opt, f) {\n  if (opt.TAG === /* Ok */0) {\n    return {\n            TAG: /* Ok */0,\n            _0: f(opt._0)\n          };\n  } else {\n    return {\n            TAG: /* Error */1,\n            _0: opt._0\n          };\n  }\n}\n\nfunction map(opt, f) {\n  return mapU(opt, Curry.__1(f));\n}\n\nfunction flatMapU(opt, f) {\n  if (opt.TAG === /* Ok */0) {\n    return f(opt._0);\n  } else {\n    return {\n            TAG: /* Error */1,\n            _0: opt._0\n          };\n  }\n}\n\nfunction flatMap(opt, f) {\n  return flatMapU(opt, Curry.__1(f));\n}\n\nfunction getWithDefault(opt, $$default) {\n  if (opt.TAG === /* Ok */0) {\n    return opt._0;\n  } else {\n    return $$default;\n  }\n}\n\nfunction isOk(param) {\n  if (param.TAG === /* Ok */0) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction isError(param) {\n  if (param.TAG === /* Ok */0) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nfunction eqU(a, b, f) {\n  if (a.TAG === /* Ok */0) {\n    if (b.TAG === /* Ok */0) {\n      return f(a._0, b._0);\n    } else {\n      return false;\n    }\n  } else if (b.TAG === /* Ok */0) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nfunction eq(a, b, f) {\n  return eqU(a, b, Curry.__2(f));\n}\n\nfunction cmpU(a, b, f) {\n  if (a.TAG === /* Ok */0) {\n    if (b.TAG === /* Ok */0) {\n      return f(a._0, b._0);\n    } else {\n      return 1;\n    }\n  } else if (b.TAG === /* Ok */0) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nfunction cmp(a, b, f) {\n  return cmpU(a, b, Curry.__2(f));\n}\n\nexport {\n  getExn ,\n  mapWithDefaultU ,\n  mapWithDefault ,\n  mapU ,\n  map ,\n  flatMapU ,\n  flatMap ,\n  getWithDefault ,\n  isOk ,\n  isError ,\n  eqU ,\n  eq ,\n  cmpU ,\n  cmp ,\n  \n}\n/* No side effect */\n","\n\nimport * as Curry from \"./curry.js\";\nimport * as Caml_option from \"./caml_option.js\";\nimport * as Belt_SortArray from \"./belt_SortArray.js\";\n\nfunction treeHeight(n) {\n  if (n !== undefined) {\n    return n.h;\n  } else {\n    return 0;\n  }\n}\n\nfunction copy(n) {\n  if (n !== undefined) {\n    return {\n            k: n.k,\n            v: n.v,\n            h: n.h,\n            l: copy(n.l),\n            r: copy(n.r)\n          };\n  } else {\n    return n;\n  }\n}\n\nfunction create(l, x, d, r) {\n  var hl = treeHeight(l);\n  var hr = treeHeight(r);\n  return {\n          k: x,\n          v: d,\n          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0,\n          l: l,\n          r: r\n        };\n}\n\nfunction singleton(x, d) {\n  return {\n          k: x,\n          v: d,\n          h: 1,\n          l: undefined,\n          r: undefined\n        };\n}\n\nfunction heightGe(l, r) {\n  if (r !== undefined) {\n    if (l !== undefined) {\n      return l.h >= r.h;\n    } else {\n      return false;\n    }\n  } else {\n    return true;\n  }\n}\n\nfunction updateValue(n, newValue) {\n  if (n.v === newValue) {\n    return n;\n  } else {\n    return {\n            k: n.k,\n            v: newValue,\n            h: n.h,\n            l: n.l,\n            r: n.r\n          };\n  }\n}\n\nfunction bal(l, x, d, r) {\n  var hl = l !== undefined ? l.h : 0;\n  var hr = r !== undefined ? r.h : 0;\n  if (hl > (hr + 2 | 0)) {\n    var ll = l.l;\n    var lr = l.r;\n    if (treeHeight(ll) >= treeHeight(lr)) {\n      return create(ll, l.k, l.v, create(lr, x, d, r));\n    } else {\n      return create(create(ll, l.k, l.v, lr.l), lr.k, lr.v, create(lr.r, x, d, r));\n    }\n  }\n  if (hr <= (hl + 2 | 0)) {\n    return {\n            k: x,\n            v: d,\n            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0,\n            l: l,\n            r: r\n          };\n  }\n  var rl = r.l;\n  var rr = r.r;\n  if (treeHeight(rr) >= treeHeight(rl)) {\n    return create(create(l, x, d, rl), r.k, r.v, rr);\n  } else {\n    return create(create(l, x, d, rl.l), rl.k, rl.v, create(rl.r, r.k, r.v, rr));\n  }\n}\n\nfunction minKey0Aux(_n) {\n  while(true) {\n    var n = _n;\n    var n$1 = n.l;\n    if (n$1 === undefined) {\n      return n.k;\n    }\n    _n = n$1;\n    continue ;\n  };\n}\n\nfunction minKey(n) {\n  if (n !== undefined) {\n    return Caml_option.some(minKey0Aux(n));\n  }\n  \n}\n\nfunction minKeyUndefined(n) {\n  if (n !== undefined) {\n    return minKey0Aux(n);\n  }\n  \n}\n\nfunction maxKey0Aux(_n) {\n  while(true) {\n    var n = _n;\n    var n$1 = n.r;\n    if (n$1 === undefined) {\n      return n.k;\n    }\n    _n = n$1;\n    continue ;\n  };\n}\n\nfunction maxKey(n) {\n  if (n !== undefined) {\n    return Caml_option.some(maxKey0Aux(n));\n  }\n  \n}\n\nfunction maxKeyUndefined(n) {\n  if (n !== undefined) {\n    return maxKey0Aux(n);\n  }\n  \n}\n\nfunction minKV0Aux(_n) {\n  while(true) {\n    var n = _n;\n    var n$1 = n.l;\n    if (n$1 === undefined) {\n      return [\n              n.k,\n              n.v\n            ];\n    }\n    _n = n$1;\n    continue ;\n  };\n}\n\nfunction minimum(n) {\n  if (n !== undefined) {\n    return minKV0Aux(n);\n  }\n  \n}\n\nfunction minUndefined(n) {\n  if (n !== undefined) {\n    return minKV0Aux(n);\n  }\n  \n}\n\nfunction maxKV0Aux(_n) {\n  while(true) {\n    var n = _n;\n    var n$1 = n.r;\n    if (n$1 === undefined) {\n      return [\n              n.k,\n              n.v\n            ];\n    }\n    _n = n$1;\n    continue ;\n  };\n}\n\nfunction maximum(n) {\n  if (n !== undefined) {\n    return maxKV0Aux(n);\n  }\n  \n}\n\nfunction maxUndefined(n) {\n  if (n !== undefined) {\n    return maxKV0Aux(n);\n  }\n  \n}\n\nfunction removeMinAuxWithRef(n, kr, vr) {\n  var ln = n.l;\n  if (ln !== undefined) {\n    return bal(removeMinAuxWithRef(ln, kr, vr), n.k, n.v, n.r);\n  } else {\n    kr.contents = n.k;\n    vr.contents = n.v;\n    return n.r;\n  }\n}\n\nfunction isEmpty(x) {\n  return x === undefined;\n}\n\nfunction stackAllLeft(_v, _s) {\n  while(true) {\n    var s = _s;\n    var v = _v;\n    if (v === undefined) {\n      return s;\n    }\n    _s = {\n      hd: v,\n      tl: s\n    };\n    _v = v.l;\n    continue ;\n  };\n}\n\nfunction findFirstByU(n, p) {\n  if (n === undefined) {\n    return ;\n  }\n  var left = findFirstByU(n.l, p);\n  if (left !== undefined) {\n    return left;\n  }\n  var v = n.k;\n  var d = n.v;\n  var pvd = p(v, d);\n  if (pvd) {\n    return [\n            v,\n            d\n          ];\n  }\n  var right = findFirstByU(n.r, p);\n  if (right !== undefined) {\n    return right;\n  }\n  \n}\n\nfunction findFirstBy(n, p) {\n  return findFirstByU(n, Curry.__2(p));\n}\n\nfunction forEachU(_n, f) {\n  while(true) {\n    var n = _n;\n    if (n === undefined) {\n      return ;\n    }\n    forEachU(n.l, f);\n    f(n.k, n.v);\n    _n = n.r;\n    continue ;\n  };\n}\n\nfunction forEach(n, f) {\n  return forEachU(n, Curry.__2(f));\n}\n\nfunction mapU(n, f) {\n  if (n === undefined) {\n    return ;\n  }\n  var newLeft = mapU(n.l, f);\n  var newD = f(n.v);\n  var newRight = mapU(n.r, f);\n  return {\n          k: n.k,\n          v: newD,\n          h: n.h,\n          l: newLeft,\n          r: newRight\n        };\n}\n\nfunction map(n, f) {\n  return mapU(n, Curry.__1(f));\n}\n\nfunction mapWithKeyU(n, f) {\n  if (n === undefined) {\n    return ;\n  }\n  var key = n.k;\n  var newLeft = mapWithKeyU(n.l, f);\n  var newD = f(key, n.v);\n  var newRight = mapWithKeyU(n.r, f);\n  return {\n          k: key,\n          v: newD,\n          h: n.h,\n          l: newLeft,\n          r: newRight\n        };\n}\n\nfunction mapWithKey(n, f) {\n  return mapWithKeyU(n, Curry.__2(f));\n}\n\nfunction reduceU(_m, _accu, f) {\n  while(true) {\n    var accu = _accu;\n    var m = _m;\n    if (m === undefined) {\n      return accu;\n    }\n    var v = m.k;\n    var d = m.v;\n    var l = m.l;\n    var r = m.r;\n    _accu = f(reduceU(l, accu, f), v, d);\n    _m = r;\n    continue ;\n  };\n}\n\nfunction reduce(m, accu, f) {\n  return reduceU(m, accu, Curry.__3(f));\n}\n\nfunction everyU(_n, p) {\n  while(true) {\n    var n = _n;\n    if (n === undefined) {\n      return true;\n    }\n    if (!p(n.k, n.v)) {\n      return false;\n    }\n    if (!everyU(n.l, p)) {\n      return false;\n    }\n    _n = n.r;\n    continue ;\n  };\n}\n\nfunction every(n, p) {\n  return everyU(n, Curry.__2(p));\n}\n\nfunction someU(_n, p) {\n  while(true) {\n    var n = _n;\n    if (n === undefined) {\n      return false;\n    }\n    if (p(n.k, n.v)) {\n      return true;\n    }\n    if (someU(n.l, p)) {\n      return true;\n    }\n    _n = n.r;\n    continue ;\n  };\n}\n\nfunction some(n, p) {\n  return someU(n, Curry.__2(p));\n}\n\nfunction addMinElement(n, k, v) {\n  if (n !== undefined) {\n    return bal(addMinElement(n.l, k, v), n.k, n.v, n.r);\n  } else {\n    return singleton(k, v);\n  }\n}\n\nfunction addMaxElement(n, k, v) {\n  if (n !== undefined) {\n    return bal(n.l, n.k, n.v, addMaxElement(n.r, k, v));\n  } else {\n    return singleton(k, v);\n  }\n}\n\nfunction join(ln, v, d, rn) {\n  if (ln === undefined) {\n    return addMinElement(rn, v, d);\n  }\n  if (rn === undefined) {\n    return addMaxElement(ln, v, d);\n  }\n  var lv = ln.k;\n  var ld = ln.v;\n  var lh = ln.h;\n  var ll = ln.l;\n  var lr = ln.r;\n  var rv = rn.k;\n  var rd = rn.v;\n  var rh = rn.h;\n  var rl = rn.l;\n  var rr = rn.r;\n  if (lh > (rh + 2 | 0)) {\n    return bal(ll, lv, ld, join(lr, v, d, rn));\n  } else if (rh > (lh + 2 | 0)) {\n    return bal(join(ln, v, d, rl), rv, rd, rr);\n  } else {\n    return create(ln, v, d, rn);\n  }\n}\n\nfunction concat(t1, t2) {\n  if (t1 === undefined) {\n    return t2;\n  }\n  if (t2 === undefined) {\n    return t1;\n  }\n  var kr = {\n    contents: t2.k\n  };\n  var vr = {\n    contents: t2.v\n  };\n  var t2r = removeMinAuxWithRef(t2, kr, vr);\n  return join(t1, kr.contents, vr.contents, t2r);\n}\n\nfunction concatOrJoin(t1, v, d, t2) {\n  if (d !== undefined) {\n    return join(t1, v, Caml_option.valFromOption(d), t2);\n  } else {\n    return concat(t1, t2);\n  }\n}\n\nfunction keepSharedU(n, p) {\n  if (n === undefined) {\n    return ;\n  }\n  var v = n.k;\n  var d = n.v;\n  var newLeft = keepSharedU(n.l, p);\n  var pvd = p(v, d);\n  var newRight = keepSharedU(n.r, p);\n  if (pvd) {\n    return join(newLeft, v, d, newRight);\n  } else {\n    return concat(newLeft, newRight);\n  }\n}\n\nfunction keepShared(n, p) {\n  return keepSharedU(n, Curry.__2(p));\n}\n\nfunction keepMapU(n, p) {\n  if (n === undefined) {\n    return ;\n  }\n  var v = n.k;\n  var d = n.v;\n  var newLeft = keepMapU(n.l, p);\n  var pvd = p(v, d);\n  var newRight = keepMapU(n.r, p);\n  if (pvd !== undefined) {\n    return join(newLeft, v, Caml_option.valFromOption(pvd), newRight);\n  } else {\n    return concat(newLeft, newRight);\n  }\n}\n\nfunction keepMap(n, p) {\n  return keepMapU(n, Curry.__2(p));\n}\n\nfunction partitionSharedU(n, p) {\n  if (n === undefined) {\n    return [\n            undefined,\n            undefined\n          ];\n  }\n  var key = n.k;\n  var value = n.v;\n  var match = partitionSharedU(n.l, p);\n  var lf = match[1];\n  var lt = match[0];\n  var pvd = p(key, value);\n  var match$1 = partitionSharedU(n.r, p);\n  var rf = match$1[1];\n  var rt = match$1[0];\n  if (pvd) {\n    return [\n            join(lt, key, value, rt),\n            concat(lf, rf)\n          ];\n  } else {\n    return [\n            concat(lt, rt),\n            join(lf, key, value, rf)\n          ];\n  }\n}\n\nfunction partitionShared(n, p) {\n  return partitionSharedU(n, Curry.__2(p));\n}\n\nfunction lengthNode(n) {\n  var l = n.l;\n  var r = n.r;\n  var sizeL = l !== undefined ? lengthNode(l) : 0;\n  var sizeR = r !== undefined ? lengthNode(r) : 0;\n  return (1 + sizeL | 0) + sizeR | 0;\n}\n\nfunction size(n) {\n  if (n !== undefined) {\n    return lengthNode(n);\n  } else {\n    return 0;\n  }\n}\n\nfunction toListAux(_n, _accu) {\n  while(true) {\n    var accu = _accu;\n    var n = _n;\n    if (n === undefined) {\n      return accu;\n    }\n    var k = n.k;\n    var v = n.v;\n    var l = n.l;\n    var r = n.r;\n    _accu = {\n      hd: [\n        k,\n        v\n      ],\n      tl: toListAux(r, accu)\n    };\n    _n = l;\n    continue ;\n  };\n}\n\nfunction toList(s) {\n  return toListAux(s, /* [] */0);\n}\n\nfunction checkInvariantInternal(_v) {\n  while(true) {\n    var v = _v;\n    if (v === undefined) {\n      return ;\n    }\n    var l = v.l;\n    var r = v.r;\n    var diff = treeHeight(l) - treeHeight(r) | 0;\n    if (!(diff <= 2 && diff >= -2)) {\n      throw {\n            RE_EXN_ID: \"Assert_failure\",\n            _1: [\n              \"belt_internalAVLtree.ml\",\n              373,\n              4\n            ],\n            Error: new Error()\n          };\n    }\n    checkInvariantInternal(l);\n    _v = r;\n    continue ;\n  };\n}\n\nfunction fillArrayKey(_n, _i, arr) {\n  while(true) {\n    var i = _i;\n    var n = _n;\n    var v = n.k;\n    var l = n.l;\n    var r = n.r;\n    var next = l !== undefined ? fillArrayKey(l, i, arr) : i;\n    arr[next] = v;\n    var rnext = next + 1 | 0;\n    if (r === undefined) {\n      return rnext;\n    }\n    _i = rnext;\n    _n = r;\n    continue ;\n  };\n}\n\nfunction fillArrayValue(_n, _i, arr) {\n  while(true) {\n    var i = _i;\n    var n = _n;\n    var l = n.l;\n    var r = n.r;\n    var next = l !== undefined ? fillArrayValue(l, i, arr) : i;\n    arr[next] = n.v;\n    var rnext = next + 1 | 0;\n    if (r === undefined) {\n      return rnext;\n    }\n    _i = rnext;\n    _n = r;\n    continue ;\n  };\n}\n\nfunction fillArray(_n, _i, arr) {\n  while(true) {\n    var i = _i;\n    var n = _n;\n    var l = n.l;\n    var v = n.k;\n    var r = n.r;\n    var next = l !== undefined ? fillArray(l, i, arr) : i;\n    arr[next] = [\n      v,\n      n.v\n    ];\n    var rnext = next + 1 | 0;\n    if (r === undefined) {\n      return rnext;\n    }\n    _i = rnext;\n    _n = r;\n    continue ;\n  };\n}\n\nfunction toArray(n) {\n  if (n === undefined) {\n    return [];\n  }\n  var size = lengthNode(n);\n  var v = new Array(size);\n  fillArray(n, 0, v);\n  return v;\n}\n\nfunction keysToArray(n) {\n  if (n === undefined) {\n    return [];\n  }\n  var size = lengthNode(n);\n  var v = new Array(size);\n  fillArrayKey(n, 0, v);\n  return v;\n}\n\nfunction valuesToArray(n) {\n  if (n === undefined) {\n    return [];\n  }\n  var size = lengthNode(n);\n  var v = new Array(size);\n  fillArrayValue(n, 0, v);\n  return v;\n}\n\nfunction fromSortedArrayRevAux(arr, off, len) {\n  switch (len) {\n    case 0 :\n        return ;\n    case 1 :\n        var match = arr[off];\n        return singleton(match[0], match[1]);\n    case 2 :\n        var match_0 = arr[off];\n        var match_1 = arr[off - 1 | 0];\n        var match$1 = match_1;\n        var match$2 = match_0;\n        return {\n                k: match$1[0],\n                v: match$1[1],\n                h: 2,\n                l: singleton(match$2[0], match$2[1]),\n                r: undefined\n              };\n    case 3 :\n        var match_0$1 = arr[off];\n        var match_1$1 = arr[off - 1 | 0];\n        var match_2 = arr[off - 2 | 0];\n        var match$3 = match_2;\n        var match$4 = match_1$1;\n        var match$5 = match_0$1;\n        return {\n                k: match$4[0],\n                v: match$4[1],\n                h: 2,\n                l: singleton(match$5[0], match$5[1]),\n                r: singleton(match$3[0], match$3[1])\n              };\n    default:\n      var nl = len / 2 | 0;\n      var left = fromSortedArrayRevAux(arr, off, nl);\n      var match$6 = arr[off - nl | 0];\n      var right = fromSortedArrayRevAux(arr, (off - nl | 0) - 1 | 0, (len - nl | 0) - 1 | 0);\n      return create(left, match$6[0], match$6[1], right);\n  }\n}\n\nfunction fromSortedArrayAux(arr, off, len) {\n  switch (len) {\n    case 0 :\n        return ;\n    case 1 :\n        var match = arr[off];\n        return singleton(match[0], match[1]);\n    case 2 :\n        var match_0 = arr[off];\n        var match_1 = arr[off + 1 | 0];\n        var match$1 = match_1;\n        var match$2 = match_0;\n        return {\n                k: match$1[0],\n                v: match$1[1],\n                h: 2,\n                l: singleton(match$2[0], match$2[1]),\n                r: undefined\n              };\n    case 3 :\n        var match_0$1 = arr[off];\n        var match_1$1 = arr[off + 1 | 0];\n        var match_2 = arr[off + 2 | 0];\n        var match$3 = match_2;\n        var match$4 = match_1$1;\n        var match$5 = match_0$1;\n        return {\n                k: match$4[0],\n                v: match$4[1],\n                h: 2,\n                l: singleton(match$5[0], match$5[1]),\n                r: singleton(match$3[0], match$3[1])\n              };\n    default:\n      var nl = len / 2 | 0;\n      var left = fromSortedArrayAux(arr, off, nl);\n      var match$6 = arr[off + nl | 0];\n      var right = fromSortedArrayAux(arr, (off + nl | 0) + 1 | 0, (len - nl | 0) - 1 | 0);\n      return create(left, match$6[0], match$6[1], right);\n  }\n}\n\nfunction fromSortedArrayUnsafe(arr) {\n  return fromSortedArrayAux(arr, 0, arr.length);\n}\n\nfunction cmpU(s1, s2, kcmp, vcmp) {\n  var len1 = size(s1);\n  var len2 = size(s2);\n  if (len1 === len2) {\n    var _e1 = stackAllLeft(s1, /* [] */0);\n    var _e2 = stackAllLeft(s2, /* [] */0);\n    while(true) {\n      var e2 = _e2;\n      var e1 = _e1;\n      if (!e1) {\n        return 0;\n      }\n      if (!e2) {\n        return 0;\n      }\n      var h2 = e2.hd;\n      var h1 = e1.hd;\n      var c = kcmp(h1.k, h2.k);\n      if (c !== 0) {\n        return c;\n      }\n      var cx = vcmp(h1.v, h2.v);\n      if (cx !== 0) {\n        return cx;\n      }\n      _e2 = stackAllLeft(h2.r, e2.tl);\n      _e1 = stackAllLeft(h1.r, e1.tl);\n      continue ;\n    };\n  } else if (len1 < len2) {\n    return -1;\n  } else {\n    return 1;\n  }\n}\n\nfunction cmp(s1, s2, kcmp, vcmp) {\n  return cmpU(s1, s2, kcmp, Curry.__2(vcmp));\n}\n\nfunction eqU(s1, s2, kcmp, veq) {\n  var len1 = size(s1);\n  var len2 = size(s2);\n  if (len1 === len2) {\n    var _e1 = stackAllLeft(s1, /* [] */0);\n    var _e2 = stackAllLeft(s2, /* [] */0);\n    while(true) {\n      var e2 = _e2;\n      var e1 = _e1;\n      if (!e1) {\n        return true;\n      }\n      if (!e2) {\n        return true;\n      }\n      var h2 = e2.hd;\n      var h1 = e1.hd;\n      if (!(kcmp(h1.k, h2.k) === 0 && veq(h1.v, h2.v))) {\n        return false;\n      }\n      _e2 = stackAllLeft(h2.r, e2.tl);\n      _e1 = stackAllLeft(h1.r, e1.tl);\n      continue ;\n    };\n  } else {\n    return false;\n  }\n}\n\nfunction eq(s1, s2, kcmp, veq) {\n  return eqU(s1, s2, kcmp, Curry.__2(veq));\n}\n\nfunction get(_n, x, cmp) {\n  while(true) {\n    var n = _n;\n    if (n === undefined) {\n      return ;\n    }\n    var v = n.k;\n    var c = cmp(x, v);\n    if (c === 0) {\n      return Caml_option.some(n.v);\n    }\n    _n = c < 0 ? n.l : n.r;\n    continue ;\n  };\n}\n\nfunction getUndefined(_n, x, cmp) {\n  while(true) {\n    var n = _n;\n    if (n === undefined) {\n      return ;\n    }\n    var v = n.k;\n    var c = cmp(x, v);\n    if (c === 0) {\n      return n.v;\n    }\n    _n = c < 0 ? n.l : n.r;\n    continue ;\n  };\n}\n\nfunction getExn(_n, x, cmp) {\n  while(true) {\n    var n = _n;\n    if (n !== undefined) {\n      var v = n.k;\n      var c = cmp(x, v);\n      if (c === 0) {\n        return n.v;\n      }\n      _n = c < 0 ? n.l : n.r;\n      continue ;\n    }\n    throw {\n          RE_EXN_ID: \"Not_found\",\n          Error: new Error()\n        };\n  };\n}\n\nfunction getWithDefault(_n, x, def, cmp) {\n  while(true) {\n    var n = _n;\n    if (n === undefined) {\n      return def;\n    }\n    var v = n.k;\n    var c = cmp(x, v);\n    if (c === 0) {\n      return n.v;\n    }\n    _n = c < 0 ? n.l : n.r;\n    continue ;\n  };\n}\n\nfunction has(_n, x, cmp) {\n  while(true) {\n    var n = _n;\n    if (n === undefined) {\n      return false;\n    }\n    var v = n.k;\n    var c = cmp(x, v);\n    if (c === 0) {\n      return true;\n    }\n    _n = c < 0 ? n.l : n.r;\n    continue ;\n  };\n}\n\nfunction rotateWithLeftChild(k2) {\n  var k1 = k2.l;\n  k2.l = k1.r;\n  k1.r = k2;\n  var hlk2 = treeHeight(k2.l);\n  var hrk2 = treeHeight(k2.r);\n  k2.h = (\n    hlk2 > hrk2 ? hlk2 : hrk2\n  ) + 1 | 0;\n  var hlk1 = treeHeight(k1.l);\n  var hk2 = k2.h;\n  k1.h = (\n    hlk1 > hk2 ? hlk1 : hk2\n  ) + 1 | 0;\n  return k1;\n}\n\nfunction rotateWithRightChild(k1) {\n  var k2 = k1.r;\n  k1.r = k2.l;\n  k2.l = k1;\n  var hlk1 = treeHeight(k1.l);\n  var hrk1 = treeHeight(k1.r);\n  k1.h = (\n    hlk1 > hrk1 ? hlk1 : hrk1\n  ) + 1 | 0;\n  var hrk2 = treeHeight(k2.r);\n  var hk1 = k1.h;\n  k2.h = (\n    hrk2 > hk1 ? hrk2 : hk1\n  ) + 1 | 0;\n  return k2;\n}\n\nfunction doubleWithLeftChild(k3) {\n  var x = k3.l;\n  var v = rotateWithRightChild(x);\n  k3.l = v;\n  return rotateWithLeftChild(k3);\n}\n\nfunction doubleWithRightChild(k2) {\n  var x = k2.r;\n  var v = rotateWithLeftChild(x);\n  k2.r = v;\n  return rotateWithRightChild(k2);\n}\n\nfunction heightUpdateMutate(t) {\n  var hlt = treeHeight(t.l);\n  var hrt = treeHeight(t.r);\n  t.h = (\n    hlt > hrt ? hlt : hrt\n  ) + 1 | 0;\n  return t;\n}\n\nfunction balMutate(nt) {\n  var l = nt.l;\n  var r = nt.r;\n  var hl = treeHeight(l);\n  var hr = treeHeight(r);\n  if (hl > (2 + hr | 0)) {\n    var ll = l.l;\n    var lr = l.r;\n    if (heightGe(ll, lr)) {\n      return heightUpdateMutate(rotateWithLeftChild(nt));\n    } else {\n      return heightUpdateMutate(doubleWithLeftChild(nt));\n    }\n  }\n  if (hr > (2 + hl | 0)) {\n    var rl = r.l;\n    var rr = r.r;\n    if (heightGe(rr, rl)) {\n      return heightUpdateMutate(rotateWithRightChild(nt));\n    } else {\n      return heightUpdateMutate(doubleWithRightChild(nt));\n    }\n  }\n  nt.h = (\n    hl > hr ? hl : hr\n  ) + 1 | 0;\n  return nt;\n}\n\nfunction updateMutate(t, x, data, cmp) {\n  if (t === undefined) {\n    return singleton(x, data);\n  }\n  var k = t.k;\n  var c = cmp(x, k);\n  if (c === 0) {\n    t.v = data;\n    return t;\n  }\n  var l = t.l;\n  var r = t.r;\n  if (c < 0) {\n    var ll = updateMutate(l, x, data, cmp);\n    t.l = ll;\n  } else {\n    t.r = updateMutate(r, x, data, cmp);\n  }\n  return balMutate(t);\n}\n\nfunction fromArray(xs, cmp) {\n  var len = xs.length;\n  if (len === 0) {\n    return ;\n  }\n  var next = Belt_SortArray.strictlySortedLengthU(xs, (function (param, param$1) {\n          return cmp(param[0], param$1[0]) < 0;\n        }));\n  var result;\n  if (next >= 0) {\n    result = fromSortedArrayAux(xs, 0, next);\n  } else {\n    next = -next | 0;\n    result = fromSortedArrayRevAux(xs, next - 1 | 0, next);\n  }\n  for(var i = next; i < len; ++i){\n    var match = xs[i];\n    result = updateMutate(result, match[0], match[1], cmp);\n  }\n  return result;\n}\n\nfunction removeMinAuxWithRootMutate(nt, n) {\n  var rn = n.r;\n  var ln = n.l;\n  if (ln !== undefined) {\n    n.l = removeMinAuxWithRootMutate(nt, ln);\n    return balMutate(n);\n  } else {\n    nt.k = n.k;\n    nt.v = n.v;\n    return rn;\n  }\n}\n\nexport {\n  copy ,\n  create ,\n  bal ,\n  singleton ,\n  updateValue ,\n  minKey ,\n  minKeyUndefined ,\n  maxKey ,\n  maxKeyUndefined ,\n  minimum ,\n  minUndefined ,\n  maximum ,\n  maxUndefined ,\n  removeMinAuxWithRef ,\n  isEmpty ,\n  stackAllLeft ,\n  findFirstByU ,\n  findFirstBy ,\n  forEachU ,\n  forEach ,\n  mapU ,\n  map ,\n  mapWithKeyU ,\n  mapWithKey ,\n  reduceU ,\n  reduce ,\n  everyU ,\n  every ,\n  someU ,\n  some ,\n  join ,\n  concat ,\n  concatOrJoin ,\n  keepSharedU ,\n  keepShared ,\n  keepMapU ,\n  keepMap ,\n  partitionSharedU ,\n  partitionShared ,\n  lengthNode ,\n  size ,\n  toList ,\n  checkInvariantInternal ,\n  fillArray ,\n  toArray ,\n  keysToArray ,\n  valuesToArray ,\n  fromSortedArrayAux ,\n  fromSortedArrayRevAux ,\n  fromSortedArrayUnsafe ,\n  cmpU ,\n  cmp ,\n  eqU ,\n  eq ,\n  get ,\n  getUndefined ,\n  getWithDefault ,\n  getExn ,\n  has ,\n  fromArray ,\n  updateMutate ,\n  balMutate ,\n  removeMinAuxWithRootMutate ,\n  \n}\n/* No side effect */\n","\n\nimport * as Curry from \"./curry.js\";\nimport * as Caml_option from \"./caml_option.js\";\nimport * as Belt_internalAVLtree from \"./belt_internalAVLtree.js\";\nimport * as Belt_internalMapString from \"./belt_internalMapString.js\";\n\nfunction set(t, newK, newD) {\n  if (t === undefined) {\n    return Belt_internalAVLtree.singleton(newK, newD);\n  }\n  var k = t.k;\n  if (newK === k) {\n    return Belt_internalAVLtree.updateValue(t, newD);\n  }\n  var v = t.v;\n  if (newK < k) {\n    return Belt_internalAVLtree.bal(set(t.l, newK, newD), k, v, t.r);\n  } else {\n    return Belt_internalAVLtree.bal(t.l, k, v, set(t.r, newK, newD));\n  }\n}\n\nfunction updateU(t, x, f) {\n  if (t !== undefined) {\n    var k = t.k;\n    if (x === k) {\n      var data = f(Caml_option.some(t.v));\n      if (data !== undefined) {\n        return Belt_internalAVLtree.updateValue(t, Caml_option.valFromOption(data));\n      }\n      var l = t.l;\n      var r = t.r;\n      if (l === undefined) {\n        return r;\n      }\n      if (r === undefined) {\n        return l;\n      }\n      var kr = {\n        contents: r.k\n      };\n      var vr = {\n        contents: r.v\n      };\n      var r$1 = Belt_internalAVLtree.removeMinAuxWithRef(r, kr, vr);\n      return Belt_internalAVLtree.bal(l, kr.contents, vr.contents, r$1);\n    }\n    var v = t.v;\n    var l$1 = t.l;\n    var r$2 = t.r;\n    if (x < k) {\n      var ll = updateU(l$1, x, f);\n      if (l$1 === ll) {\n        return t;\n      } else {\n        return Belt_internalAVLtree.bal(ll, k, v, r$2);\n      }\n    }\n    var rr = updateU(r$2, x, f);\n    if (r$2 === rr) {\n      return t;\n    } else {\n      return Belt_internalAVLtree.bal(l$1, k, v, rr);\n    }\n  }\n  var data$1 = f(undefined);\n  if (data$1 !== undefined) {\n    return Belt_internalAVLtree.singleton(x, Caml_option.valFromOption(data$1));\n  } else {\n    return t;\n  }\n}\n\nfunction update(t, x, f) {\n  return updateU(t, x, Curry.__1(f));\n}\n\nfunction removeAux(n, x) {\n  var v = n.k;\n  var l = n.l;\n  var r = n.r;\n  if (x === v) {\n    if (l === undefined) {\n      return r;\n    }\n    if (r === undefined) {\n      return l;\n    }\n    var kr = {\n      contents: r.k\n    };\n    var vr = {\n      contents: r.v\n    };\n    var r$1 = Belt_internalAVLtree.removeMinAuxWithRef(r, kr, vr);\n    return Belt_internalAVLtree.bal(l, kr.contents, vr.contents, r$1);\n  }\n  if (x < v) {\n    if (l === undefined) {\n      return n;\n    }\n    var ll = removeAux(l, x);\n    if (ll === l) {\n      return n;\n    } else {\n      return Belt_internalAVLtree.bal(ll, v, n.v, r);\n    }\n  }\n  if (r === undefined) {\n    return n;\n  }\n  var rr = removeAux(r, x);\n  return Belt_internalAVLtree.bal(l, v, n.v, rr);\n}\n\nfunction remove(n, x) {\n  if (n !== undefined) {\n    return removeAux(n, x);\n  }\n  \n}\n\nfunction removeMany(t, keys) {\n  var len = keys.length;\n  if (t !== undefined) {\n    var _t = t;\n    var _i = 0;\n    while(true) {\n      var i = _i;\n      var t$1 = _t;\n      if (i >= len) {\n        return t$1;\n      }\n      var ele = keys[i];\n      var u = removeAux(t$1, ele);\n      if (u === undefined) {\n        return u;\n      }\n      _i = i + 1 | 0;\n      _t = u;\n      continue ;\n    };\n  }\n  \n}\n\nfunction mergeMany(h, arr) {\n  var len = arr.length;\n  var v = h;\n  for(var i = 0; i < len; ++i){\n    var match = arr[i];\n    v = set(v, match[0], match[1]);\n  }\n  return v;\n}\n\nvar empty;\n\nvar isEmpty = Belt_internalAVLtree.isEmpty;\n\nvar has = Belt_internalMapString.has;\n\nvar cmpU = Belt_internalMapString.cmpU;\n\nvar cmp = Belt_internalMapString.cmp;\n\nvar eqU = Belt_internalMapString.eqU;\n\nvar eq = Belt_internalMapString.eq;\n\nvar findFirstByU = Belt_internalAVLtree.findFirstByU;\n\nvar findFirstBy = Belt_internalAVLtree.findFirstBy;\n\nvar forEachU = Belt_internalAVLtree.forEachU;\n\nvar forEach = Belt_internalAVLtree.forEach;\n\nvar reduceU = Belt_internalAVLtree.reduceU;\n\nvar reduce = Belt_internalAVLtree.reduce;\n\nvar everyU = Belt_internalAVLtree.everyU;\n\nvar every = Belt_internalAVLtree.every;\n\nvar someU = Belt_internalAVLtree.someU;\n\nvar some = Belt_internalAVLtree.some;\n\nvar size = Belt_internalAVLtree.size;\n\nvar toList = Belt_internalAVLtree.toList;\n\nvar toArray = Belt_internalAVLtree.toArray;\n\nvar fromArray = Belt_internalMapString.fromArray;\n\nvar keysToArray = Belt_internalAVLtree.keysToArray;\n\nvar valuesToArray = Belt_internalAVLtree.valuesToArray;\n\nvar minKey = Belt_internalAVLtree.minKey;\n\nvar minKeyUndefined = Belt_internalAVLtree.minKeyUndefined;\n\nvar maxKey = Belt_internalAVLtree.maxKey;\n\nvar maxKeyUndefined = Belt_internalAVLtree.maxKeyUndefined;\n\nvar minimum = Belt_internalAVLtree.minimum;\n\nvar minUndefined = Belt_internalAVLtree.minUndefined;\n\nvar maximum = Belt_internalAVLtree.maximum;\n\nvar maxUndefined = Belt_internalAVLtree.maxUndefined;\n\nvar get = Belt_internalMapString.get;\n\nvar getUndefined = Belt_internalMapString.getUndefined;\n\nvar getWithDefault = Belt_internalMapString.getWithDefault;\n\nvar getExn = Belt_internalMapString.getExn;\n\nvar checkInvariantInternal = Belt_internalAVLtree.checkInvariantInternal;\n\nvar mergeU = Belt_internalMapString.mergeU;\n\nvar merge = Belt_internalMapString.merge;\n\nvar keepU = Belt_internalAVLtree.keepSharedU;\n\nvar keep = Belt_internalAVLtree.keepShared;\n\nvar partitionU = Belt_internalAVLtree.partitionSharedU;\n\nvar partition = Belt_internalAVLtree.partitionShared;\n\nvar split = Belt_internalMapString.split;\n\nvar mapU = Belt_internalAVLtree.mapU;\n\nvar map = Belt_internalAVLtree.map;\n\nvar mapWithKeyU = Belt_internalAVLtree.mapWithKeyU;\n\nvar mapWithKey = Belt_internalAVLtree.mapWithKey;\n\nexport {\n  empty ,\n  isEmpty ,\n  has ,\n  cmpU ,\n  cmp ,\n  eqU ,\n  eq ,\n  findFirstByU ,\n  findFirstBy ,\n  forEachU ,\n  forEach ,\n  reduceU ,\n  reduce ,\n  everyU ,\n  every ,\n  someU ,\n  some ,\n  size ,\n  toList ,\n  toArray ,\n  fromArray ,\n  keysToArray ,\n  valuesToArray ,\n  minKey ,\n  minKeyUndefined ,\n  maxKey ,\n  maxKeyUndefined ,\n  minimum ,\n  minUndefined ,\n  maximum ,\n  maxUndefined ,\n  get ,\n  getUndefined ,\n  getWithDefault ,\n  getExn ,\n  checkInvariantInternal ,\n  remove ,\n  removeMany ,\n  set ,\n  updateU ,\n  update ,\n  mergeU ,\n  merge ,\n  mergeMany ,\n  keepU ,\n  keep ,\n  partitionU ,\n  partition ,\n  split ,\n  mapU ,\n  map ,\n  mapWithKeyU ,\n  mapWithKey ,\n  \n}\n/* No side effect */\n","\n\nimport * as Curry from \"./curry.js\";\nimport * as Caml_option from \"./caml_option.js\";\nimport * as Belt_SortArray from \"./belt_SortArray.js\";\nimport * as Caml_primitive from \"./caml_primitive.js\";\nimport * as Belt_internalAVLtree from \"./belt_internalAVLtree.js\";\n\nfunction add(t, x, data) {\n  if (t === undefined) {\n    return Belt_internalAVLtree.singleton(x, data);\n  }\n  var k = t.k;\n  if (x === k) {\n    return Belt_internalAVLtree.updateValue(t, data);\n  }\n  var v = t.v;\n  if (x < k) {\n    return Belt_internalAVLtree.bal(add(t.l, x, data), k, v, t.r);\n  } else {\n    return Belt_internalAVLtree.bal(t.l, k, v, add(t.r, x, data));\n  }\n}\n\nfunction get(_n, x) {\n  while(true) {\n    var n = _n;\n    if (n === undefined) {\n      return ;\n    }\n    var v = n.k;\n    if (x === v) {\n      return Caml_option.some(n.v);\n    }\n    _n = x < v ? n.l : n.r;\n    continue ;\n  };\n}\n\nfunction getUndefined(_n, x) {\n  while(true) {\n    var n = _n;\n    if (n === undefined) {\n      return ;\n    }\n    var v = n.k;\n    if (x === v) {\n      return n.v;\n    }\n    _n = x < v ? n.l : n.r;\n    continue ;\n  };\n}\n\nfunction getExn(_n, x) {\n  while(true) {\n    var n = _n;\n    if (n !== undefined) {\n      var v = n.k;\n      if (x === v) {\n        return n.v;\n      }\n      _n = x < v ? n.l : n.r;\n      continue ;\n    }\n    throw {\n          RE_EXN_ID: \"Not_found\",\n          Error: new Error()\n        };\n  };\n}\n\nfunction getWithDefault(_n, x, def) {\n  while(true) {\n    var n = _n;\n    if (n === undefined) {\n      return def;\n    }\n    var v = n.k;\n    if (x === v) {\n      return n.v;\n    }\n    _n = x < v ? n.l : n.r;\n    continue ;\n  };\n}\n\nfunction has(_n, x) {\n  while(true) {\n    var n = _n;\n    if (n === undefined) {\n      return false;\n    }\n    var v = n.k;\n    if (x === v) {\n      return true;\n    }\n    _n = x < v ? n.l : n.r;\n    continue ;\n  };\n}\n\nfunction remove(n, x) {\n  if (n === undefined) {\n    return n;\n  }\n  var v = n.k;\n  var l = n.l;\n  var r = n.r;\n  if (x !== v) {\n    if (x < v) {\n      return Belt_internalAVLtree.bal(remove(l, x), v, n.v, r);\n    } else {\n      return Belt_internalAVLtree.bal(l, v, n.v, remove(r, x));\n    }\n  }\n  if (l === undefined) {\n    return r;\n  }\n  if (r === undefined) {\n    return l;\n  }\n  var kr = {\n    contents: r.k\n  };\n  var vr = {\n    contents: r.v\n  };\n  var r$1 = Belt_internalAVLtree.removeMinAuxWithRef(r, kr, vr);\n  return Belt_internalAVLtree.bal(l, kr.contents, vr.contents, r$1);\n}\n\nfunction splitAux(x, n) {\n  var v = n.k;\n  var d = n.v;\n  var l = n.l;\n  var r = n.r;\n  if (x === v) {\n    return [\n            l,\n            Caml_option.some(d),\n            r\n          ];\n  }\n  if (x < v) {\n    if (l === undefined) {\n      return [\n              undefined,\n              undefined,\n              n\n            ];\n    }\n    var match = splitAux(x, l);\n    return [\n            match[0],\n            match[1],\n            Belt_internalAVLtree.join(match[2], v, d, r)\n          ];\n  }\n  if (r === undefined) {\n    return [\n            n,\n            undefined,\n            undefined\n          ];\n  }\n  var match$1 = splitAux(x, r);\n  return [\n          Belt_internalAVLtree.join(l, v, d, match$1[0]),\n          match$1[1],\n          match$1[2]\n        ];\n}\n\nfunction split(x, n) {\n  if (n !== undefined) {\n    return splitAux(x, n);\n  } else {\n    return [\n            undefined,\n            undefined,\n            undefined\n          ];\n  }\n}\n\nfunction mergeU(s1, s2, f) {\n  if (s1 !== undefined) {\n    if (s1.h >= (\n        s2 !== undefined ? s2.h : 0\n      )) {\n      var v1 = s1.k;\n      var d1 = s1.v;\n      var l1 = s1.l;\n      var r1 = s1.r;\n      var match = split(v1, s2);\n      return Belt_internalAVLtree.concatOrJoin(mergeU(l1, match[0], f), v1, f(v1, Caml_option.some(d1), match[1]), mergeU(r1, match[2], f));\n    }\n    \n  } else if (s2 === undefined) {\n    return ;\n  }\n  var v2 = s2.k;\n  var d2 = s2.v;\n  var l2 = s2.l;\n  var r2 = s2.r;\n  var match$1 = split(v2, s1);\n  return Belt_internalAVLtree.concatOrJoin(mergeU(match$1[0], l2, f), v2, f(v2, match$1[1], Caml_option.some(d2)), mergeU(match$1[2], r2, f));\n}\n\nfunction merge(s1, s2, f) {\n  return mergeU(s1, s2, Curry.__3(f));\n}\n\nfunction compareAux(_e1, _e2, vcmp) {\n  while(true) {\n    var e2 = _e2;\n    var e1 = _e1;\n    if (!e1) {\n      return 0;\n    }\n    if (!e2) {\n      return 0;\n    }\n    var h2 = e2.hd;\n    var h1 = e1.hd;\n    var c = Caml_primitive.caml_string_compare(h1.k, h2.k);\n    if (c !== 0) {\n      return c;\n    }\n    var cx = vcmp(h1.v, h2.v);\n    if (cx !== 0) {\n      return cx;\n    }\n    _e2 = Belt_internalAVLtree.stackAllLeft(h2.r, e2.tl);\n    _e1 = Belt_internalAVLtree.stackAllLeft(h1.r, e1.tl);\n    continue ;\n  };\n}\n\nfunction cmpU(s1, s2, cmp) {\n  var len1 = Belt_internalAVLtree.size(s1);\n  var len2 = Belt_internalAVLtree.size(s2);\n  if (len1 === len2) {\n    return compareAux(Belt_internalAVLtree.stackAllLeft(s1, /* [] */0), Belt_internalAVLtree.stackAllLeft(s2, /* [] */0), cmp);\n  } else if (len1 < len2) {\n    return -1;\n  } else {\n    return 1;\n  }\n}\n\nfunction cmp(s1, s2, f) {\n  return cmpU(s1, s2, Curry.__2(f));\n}\n\nfunction eqAux(_e1, _e2, eq) {\n  while(true) {\n    var e2 = _e2;\n    var e1 = _e1;\n    if (!e1) {\n      return true;\n    }\n    if (!e2) {\n      return true;\n    }\n    var h2 = e2.hd;\n    var h1 = e1.hd;\n    if (!(h1.k === h2.k && eq(h1.v, h2.v))) {\n      return false;\n    }\n    _e2 = Belt_internalAVLtree.stackAllLeft(h2.r, e2.tl);\n    _e1 = Belt_internalAVLtree.stackAllLeft(h1.r, e1.tl);\n    continue ;\n  };\n}\n\nfunction eqU(s1, s2, eq) {\n  var len1 = Belt_internalAVLtree.size(s1);\n  var len2 = Belt_internalAVLtree.size(s2);\n  if (len1 === len2) {\n    return eqAux(Belt_internalAVLtree.stackAllLeft(s1, /* [] */0), Belt_internalAVLtree.stackAllLeft(s2, /* [] */0), eq);\n  } else {\n    return false;\n  }\n}\n\nfunction eq(s1, s2, f) {\n  return eqU(s1, s2, Curry.__2(f));\n}\n\nfunction addMutate(t, x, data) {\n  if (t === undefined) {\n    return Belt_internalAVLtree.singleton(x, data);\n  }\n  var k = t.k;\n  if (x === k) {\n    t.k = x;\n    t.v = data;\n    return t;\n  }\n  var l = t.l;\n  var r = t.r;\n  if (x < k) {\n    var ll = addMutate(l, x, data);\n    t.l = ll;\n  } else {\n    t.r = addMutate(r, x, data);\n  }\n  return Belt_internalAVLtree.balMutate(t);\n}\n\nfunction fromArray(xs) {\n  var len = xs.length;\n  if (len === 0) {\n    return ;\n  }\n  var next = Belt_SortArray.strictlySortedLengthU(xs, (function (param, param$1) {\n          return param[0] < param$1[0];\n        }));\n  var result;\n  if (next >= 0) {\n    result = Belt_internalAVLtree.fromSortedArrayAux(xs, 0, next);\n  } else {\n    next = -next | 0;\n    result = Belt_internalAVLtree.fromSortedArrayRevAux(xs, next - 1 | 0, next);\n  }\n  for(var i = next; i < len; ++i){\n    var match = xs[i];\n    result = addMutate(result, match[0], match[1]);\n  }\n  return result;\n}\n\nvar N;\n\nvar A;\n\nvar S;\n\nexport {\n  N ,\n  A ,\n  S ,\n  add ,\n  get ,\n  getUndefined ,\n  getExn ,\n  getWithDefault ,\n  has ,\n  remove ,\n  splitAux ,\n  split ,\n  mergeU ,\n  merge ,\n  compareAux ,\n  cmpU ,\n  cmp ,\n  eqAux ,\n  eqU ,\n  eq ,\n  addMutate ,\n  fromArray ,\n  \n}\n/* No side effect */\n","// Generated by ReScript, PLEASE EDIT WITH CARE\n\nimport * as Js_dict from \"bs-platform/lib/es6/js_dict.js\";\nimport * as Js_json from \"bs-platform/lib/es6/js_json.js\";\nimport * as Belt_Array from \"bs-platform/lib/es6/belt_Array.js\";\nimport * as Belt_Result from \"bs-platform/lib/es6/belt_Result.js\";\nimport * as Caml_option from \"bs-platform/lib/es6/caml_option.js\";\nimport * as Belt_MapString from \"bs-platform/lib/es6/belt_MapString.js\";\nimport * as Debug$AcutisLang from \"./Debug.bs.js\";\nimport * as Belt_MutableQueue from \"bs-platform/lib/es6/belt_MutableQueue.js\";\nimport * as Acutis_Types$AcutisLang from \"./Acutis_Types.bs.js\";\n\nfunction arrayToQueueResult(a, f) {\n  var q = Belt_MutableQueue.make(undefined);\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    var x = Belt_Array.get(a, i);\n    if (x === undefined) {\n      return {\n              TAG: /* Ok */0,\n              _0: q\n            };\n    }\n    var x$1 = f(Caml_option.valFromOption(x));\n    if (x$1.TAG !== /* Ok */0) {\n      return x$1;\n    }\n    Belt_MutableQueue.add(q, x$1._0);\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction toJson(pattern, props, stack) {\n  var variant = pattern.NAME;\n  if (variant === \"Object\") {\n    return Belt_Result.mapU(arrayToQueueResult(pattern.VAL[1], (function (param) {\n                      var k = param[0];\n                      return Belt_Result.mapU(toJson(param[1], props, stack), (function (v) {\n                                    return [\n                                            k,\n                                            v\n                                          ];\n                                  }));\n                    })), (function (q) {\n                  var d = {};\n                  Belt_MutableQueue.forEachU(q, (function (param) {\n                          d[param[0]] = param[1];\n                          \n                        }));\n                  return d;\n                }));\n  }\n  if (variant !== \"Binding\") {\n    if (variant === \"False\") {\n      return {\n              TAG: /* Ok */0,\n              _0: false\n            };\n    } else if (variant === \"Array\" || variant === \"ArrayWithTailBinding\") {\n      return Belt_Result.mapU(toArray(pattern, props, stack), (function (x) {\n                    return x;\n                  }));\n    } else if (variant === \"Null\") {\n      return {\n              TAG: /* Ok */0,\n              _0: null\n            };\n    } else if (variant === \"True\") {\n      return {\n              TAG: /* Ok */0,\n              _0: true\n            };\n    } else {\n      return {\n              TAG: /* Ok */0,\n              _0: pattern.VAL[1]\n            };\n    }\n  }\n  var match = pattern.VAL;\n  var binding = match[1];\n  var x = Js_dict.get(props, binding);\n  if (x !== undefined) {\n    return {\n            TAG: /* Ok */0,\n            _0: Caml_option.valFromOption(x)\n          };\n  } else {\n    return {\n            TAG: /* Error */1,\n            _0: Debug$AcutisLang.bindingDoesNotExist(match[0], binding, stack)\n          };\n  }\n}\n\nfunction toArray(pattern, props, stack) {\n  if (pattern.NAME === \"Array\") {\n    return Belt_Result.mapU(arrayToQueueResult(pattern.VAL[1], (function (x) {\n                      return toJson(x, props, stack);\n                    })), Belt_MutableQueue.toArray);\n  }\n  var match = pattern.VAL;\n  var match$1 = match[2].VAL;\n  var binding = match$1[1];\n  var data = Js_dict.get(props, binding);\n  if (data === undefined) {\n    return {\n            TAG: /* Error */1,\n            _0: Debug$AcutisLang.bindingDoesNotExist(match$1[0], binding, stack)\n          };\n  }\n  var binding$1 = Js_json.classify(Caml_option.valFromOption(data));\n  if (typeof binding$1 === \"number\") {\n    return {\n            TAG: /* Error */1,\n            _0: Debug$AcutisLang.bindingTypeMismatch(binding$1, pattern, binding, stack)\n          };\n  }\n  if (binding$1.TAG !== /* JSONArray */3) {\n    return {\n            TAG: /* Error */1,\n            _0: Debug$AcutisLang.bindingTypeMismatch(binding$1, pattern, binding, stack)\n          };\n  }\n  var binding$2 = binding$1._0;\n  return Belt_Result.mapU(arrayToQueueResult(match[1], (function (x) {\n                    return toJson(x, props, stack);\n                  })), (function (q) {\n                return Belt_Array.concat(Belt_MutableQueue.toArray(q), binding$2);\n              }));\n}\n\nfunction setBinding(bindings, identifier, json, loc) {\n  if (identifier === \"_\") {\n    return {\n            TAG: /* Ok */0,\n            _0: bindings\n          };\n  } else if (Belt_MapString.has(bindings, identifier)) {\n    return {\n            TAG: /* Error */1,\n            _0: {\n              TAG: /* TooManyBindings */1,\n              loc: loc,\n              binding: identifier\n            }\n          };\n  } else {\n    return {\n            TAG: /* Ok */0,\n            _0: Belt_MapString.set(bindings, identifier, json)\n          };\n  }\n}\n\nfunction testValue(pattern, json, bindings) {\n  var match = Js_json.classify(json);\n  var variant = pattern.NAME;\n  if (variant === \"Object\") {\n    var x = pattern.VAL[1];\n    if (x.length !== 0) {\n      if (typeof match === \"number\") {\n        if (match === /* JSONNull */2) {\n          return {\n                  TAG: /* Error */1,\n                  _0: /* NoMatch */0\n                };\n        } else {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* PatternTypeMismatch */0,\n                    data: match,\n                    pattern: pattern\n                  }\n                };\n        }\n      } else if (match.TAG === /* JSONObject */2) {\n        var obj = match._0;\n        var _bindings = bindings;\n        var _i = 0;\n        while(true) {\n          var i = _i;\n          var bindings$1 = _bindings;\n          var match$1 = Belt_Array.get(x, i);\n          if (match$1 === undefined) {\n            return {\n                    TAG: /* Ok */0,\n                    _0: bindings$1\n                  };\n          }\n          var json$1 = Js_dict.get(obj, match$1[0]);\n          if (json$1 === undefined) {\n            return {\n                    TAG: /* Error */1,\n                    _0: /* NoMatch */0\n                  };\n          }\n          var bindings$2 = testValue(match$1[1], Caml_option.valFromOption(json$1), bindings$1);\n          if (bindings$2.TAG !== /* Ok */0) {\n            return bindings$2;\n          }\n          _i = i + 1 | 0;\n          _bindings = bindings$2._0;\n          continue ;\n        };\n      } else {\n        return {\n                TAG: /* Error */1,\n                _0: {\n                  TAG: /* PatternTypeMismatch */0,\n                  data: match,\n                  pattern: pattern\n                }\n              };\n      }\n    } else if (typeof match === \"number\") {\n      if (match === /* JSONNull */2) {\n        return {\n                TAG: /* Error */1,\n                _0: /* NoMatch */0\n              };\n      } else {\n        return {\n                TAG: /* Error */1,\n                _0: {\n                  TAG: /* PatternTypeMismatch */0,\n                  data: match,\n                  pattern: pattern\n                }\n              };\n      }\n    } else if (match.TAG === /* JSONObject */2) {\n      if (Object.keys(match._0).length === 0) {\n        return {\n                TAG: /* Ok */0,\n                _0: bindings\n              };\n      } else {\n        return {\n                TAG: /* Error */1,\n                _0: /* NoMatch */0\n              };\n      }\n    } else {\n      return {\n              TAG: /* Error */1,\n              _0: {\n                TAG: /* PatternTypeMismatch */0,\n                data: match,\n                pattern: pattern\n              }\n            };\n    }\n  }\n  if (variant === \"Binding\") {\n    var match$2 = pattern.VAL;\n    return setBinding(bindings, match$2[1], json, match$2[0]);\n  }\n  if (variant === \"Number\") {\n    if (typeof match === \"number\") {\n      if (match === /* JSONNull */2) {\n        return {\n                TAG: /* Error */1,\n                _0: /* NoMatch */0\n              };\n      } else {\n        return {\n                TAG: /* Error */1,\n                _0: {\n                  TAG: /* PatternTypeMismatch */0,\n                  data: match,\n                  pattern: pattern\n                }\n              };\n      }\n    } else if (match.TAG === /* JSONNumber */1) {\n      if (pattern.VAL[1] === match._0) {\n        return {\n                TAG: /* Ok */0,\n                _0: bindings\n              };\n      } else {\n        return {\n                TAG: /* Error */1,\n                _0: /* NoMatch */0\n              };\n      }\n    } else {\n      return {\n              TAG: /* Error */1,\n              _0: {\n                TAG: /* PatternTypeMismatch */0,\n                data: match,\n                pattern: pattern\n              }\n            };\n    }\n  }\n  if (variant === \"False\") {\n    if (typeof match !== \"number\") {\n      return {\n              TAG: /* Error */1,\n              _0: {\n                TAG: /* PatternTypeMismatch */0,\n                data: match,\n                pattern: pattern\n              }\n            };\n    }\n    switch (match) {\n      case /* JSONFalse */0 :\n          return {\n                  TAG: /* Ok */0,\n                  _0: bindings\n                };\n      case /* JSONTrue */1 :\n      case /* JSONNull */2 :\n          return {\n                  TAG: /* Error */1,\n                  _0: /* NoMatch */0\n                };\n      \n    }\n  } else if (variant === \"ArrayWithTailBinding\") {\n    var match$3 = pattern.VAL;\n    var match$4 = match$3[2].VAL;\n    var binding = match$4[1];\n    var bindLoc = match$4[0];\n    var array = match$3[1];\n    if (typeof match === \"number\") {\n      if (match === /* JSONNull */2) {\n        return {\n                TAG: /* Error */1,\n                _0: /* NoMatch */0\n              };\n      } else {\n        return {\n                TAG: /* Error */1,\n                _0: {\n                  TAG: /* PatternTypeMismatch */0,\n                  data: match,\n                  pattern: pattern\n                }\n              };\n      }\n    }\n    if (match.TAG !== /* JSONArray */3) {\n      return {\n              TAG: /* Error */1,\n              _0: {\n                TAG: /* PatternTypeMismatch */0,\n                data: match,\n                pattern: pattern\n              }\n            };\n    }\n    var data = match._0;\n    return Belt_Result.flatMapU(testArray(array, data, bindings), (function (bindings) {\n                  return setBinding(bindings, binding, Belt_Array.sliceToEnd(data, array.length), bindLoc);\n                }));\n  } else {\n    if (variant === \"Null\") {\n      if (typeof match === \"number\" && match >= 2) {\n        return {\n                TAG: /* Ok */0,\n                _0: bindings\n              };\n      } else {\n        return {\n                TAG: /* Error */1,\n                _0: /* NoMatch */0\n              };\n      }\n    }\n    if (variant === \"True\") {\n      if (typeof match !== \"number\") {\n        return {\n                TAG: /* Error */1,\n                _0: {\n                  TAG: /* PatternTypeMismatch */0,\n                  data: match,\n                  pattern: pattern\n                }\n              };\n      }\n      switch (match) {\n        case /* JSONTrue */1 :\n            return {\n                    TAG: /* Ok */0,\n                    _0: bindings\n                  };\n        case /* JSONFalse */0 :\n        case /* JSONNull */2 :\n            return {\n                    TAG: /* Error */1,\n                    _0: /* NoMatch */0\n                  };\n        \n      }\n    } else {\n      if (variant !== \"Array\") {\n        if (typeof match === \"number\") {\n          if (match === /* JSONNull */2) {\n            return {\n                    TAG: /* Error */1,\n                    _0: /* NoMatch */0\n                  };\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: {\n                      TAG: /* PatternTypeMismatch */0,\n                      data: match,\n                      pattern: pattern\n                    }\n                  };\n          }\n        } else if (match.TAG === /* JSONString */0) {\n          if (pattern.VAL[1] === match._0) {\n            return {\n                    TAG: /* Ok */0,\n                    _0: bindings\n                  };\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: /* NoMatch */0\n                  };\n          }\n        } else {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* PatternTypeMismatch */0,\n                    data: match,\n                    pattern: pattern\n                  }\n                };\n        }\n      }\n      var x$1 = pattern.VAL[1];\n      if (x$1.length !== 0) {\n        if (typeof match === \"number\") {\n          if (match === /* JSONNull */2) {\n            return {\n                    TAG: /* Error */1,\n                    _0: /* NoMatch */0\n                  };\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: {\n                      TAG: /* PatternTypeMismatch */0,\n                      data: match,\n                      pattern: pattern\n                    }\n                  };\n          }\n        } else if (match.TAG === /* JSONArray */3) {\n          return testArray(x$1, match._0, bindings);\n        } else {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* PatternTypeMismatch */0,\n                    data: match,\n                    pattern: pattern\n                  }\n                };\n        }\n      } else if (typeof match === \"number\") {\n        if (match === /* JSONNull */2) {\n          return {\n                  TAG: /* Error */1,\n                  _0: /* NoMatch */0\n                };\n        } else {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* PatternTypeMismatch */0,\n                    data: match,\n                    pattern: pattern\n                  }\n                };\n        }\n      } else if (match.TAG === /* JSONArray */3) {\n        if (match._0.length !== 0) {\n          return {\n                  TAG: /* Error */1,\n                  _0: /* NoMatch */0\n                };\n        } else {\n          return {\n                  TAG: /* Ok */0,\n                  _0: bindings\n                };\n        }\n      } else {\n        return {\n                TAG: /* Error */1,\n                _0: {\n                  TAG: /* PatternTypeMismatch */0,\n                  data: match,\n                  pattern: pattern\n                }\n              };\n      }\n    }\n  }\n}\n\nfunction testArray(patterns, data, bindings) {\n  var _bindings = bindings;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    var bindings$1 = _bindings;\n    var pattern = Belt_Array.get(patterns, i);\n    if (pattern === undefined) {\n      return {\n              TAG: /* Ok */0,\n              _0: bindings$1\n            };\n    }\n    var json = Belt_Array.get(data, i);\n    if (json === undefined) {\n      return {\n              TAG: /* Error */1,\n              _0: /* NoMatch */0\n            };\n    }\n    var bindings$2 = testValue(pattern, Caml_option.valFromOption(json), bindings$1);\n    if (bindings$2.TAG !== /* Ok */0) {\n      return bindings$2;\n    }\n    _i = i + 1 | 0;\n    _bindings = bindings$2._0;\n    continue ;\n  };\n}\n\nfunction test(param, param$1) {\n  var jsonTail = param$1._1;\n  var patternTail = param._1;\n  var _pattern = param._0;\n  var _json = param$1._0;\n  var _bindings;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    var bindings = _bindings;\n    var json = _json;\n    var pattern = _pattern;\n    var bindings$1 = testValue(pattern, json, bindings);\n    if (bindings$1.TAG !== /* Ok */0) {\n      return bindings$1;\n    }\n    var bindings$2 = bindings$1._0;\n    var match = Belt_Array.get(patternTail, i);\n    var match$1 = Belt_Array.get(jsonTail, i);\n    if (match !== undefined) {\n      if (match$1 === undefined) {\n        return {\n                TAG: /* Error */1,\n                _0: /* PatternNumberMismatch */1\n              };\n      }\n      _i = i + 1 | 0;\n      _bindings = bindings$2;\n      _json = Caml_option.valFromOption(match$1);\n      _pattern = match;\n      continue ;\n    }\n    if (match$1 !== undefined) {\n      return {\n              TAG: /* Error */1,\n              _0: /* PatternNumberMismatch */1\n            };\n    }\n    var d = {};\n    Belt_MapString.forEachU(bindings$2, (function(d){\n        return function (k, v) {\n          d[k] = v;\n          \n        }\n        }(d)));\n    return {\n            TAG: /* Ok */0,\n            _0: d\n          };\n  };\n}\n\nfunction matchCase(param, jsonSequence) {\n  var f = param.f;\n  var match = param.patterns;\n  var tail = match._1;\n  var _pattern = match._0;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    var pattern = _pattern;\n    var bindings = test(pattern, jsonSequence);\n    if (bindings.TAG === /* Ok */0) {\n      return {\n              TAG: /* Ok */0,\n              _0: f(bindings._0)\n            };\n    }\n    var match$1 = bindings._0;\n    if (typeof match$1 !== \"number\") {\n      return bindings;\n    }\n    if (match$1 !== 0) {\n      return bindings;\n    }\n    var pattern$1 = Belt_Array.get(tail, i);\n    if (pattern$1 === undefined) {\n      return {\n              TAG: /* Error */1,\n              _0: /* NoMatch */0\n            };\n    }\n    _i = i + 1 | 0;\n    _pattern = pattern$1;\n    continue ;\n  };\n}\n\nfunction match(param, data) {\n  var tail = param._1;\n  var _pattern = param._0;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    var pattern = _pattern;\n    var x = matchCase(pattern, data);\n    if (x.TAG === /* Ok */0) {\n      return x;\n    }\n    var match$1 = x._0;\n    if (typeof match$1 !== \"number\") {\n      return x;\n    }\n    if (match$1 !== 0) {\n      return x;\n    }\n    var pattern$1 = Belt_Array.get(tail, i);\n    if (pattern$1 === undefined) {\n      return {\n              TAG: /* Error */1,\n              _0: /* NoMatch */0\n            };\n    }\n    _i = i + 1 | 0;\n    _pattern = pattern$1;\n    continue ;\n  };\n}\n\nfunction $$escape(c) {\n  switch (c) {\n    case \"\\\"\" :\n        return \"&quot;\";\n    case \"&\" :\n        return \"&amp;\";\n    case \"'\" :\n        return \"&apos;\";\n    case \"/\" :\n        return \"&#x2F;\";\n    case \"<\" :\n        return \"&lt;\";\n    case \"=\" :\n        return \"&#x3D;\";\n    case \">\" :\n        return \"&gt;\";\n    case \"`\" :\n        return \"&#x60;\";\n    default:\n      return c;\n  }\n}\n\nfunction $$escape$1(esc, str) {\n  if (esc) {\n    var _pos = 0;\n    var _result = \"\";\n    while(true) {\n      var result = _result;\n      var pos = _pos;\n      var c = str.charAt(pos);\n      if (c === \"\") {\n        return result;\n      }\n      _result = result + $$escape(c);\n      _pos = pos + 1 | 0;\n      continue ;\n    };\n  } else {\n    return str;\n  }\n}\n\nfunction getBindingOrNull(props, binding) {\n  var x = Js_dict.get(props, binding);\n  if (x !== undefined) {\n    return Caml_option.valFromOption(x);\n  } else {\n    return null;\n  }\n}\n\nfunction echoBinding(props, binding) {\n  var x = Js_json.classify(getBindingOrNull(props, binding));\n  if (typeof x === \"number\") {\n    return {\n            TAG: /* Error */1,\n            _0: x\n          };\n  }\n  switch (x.TAG | 0) {\n    case /* JSONString */0 :\n        return {\n                TAG: /* Ok */0,\n                _0: x._0\n              };\n    case /* JSONNumber */1 :\n        return {\n                TAG: /* Ok */0,\n                _0: String(x._0)\n              };\n    default:\n      return {\n              TAG: /* Error */1,\n              _0: x\n            };\n  }\n}\n\nfunction addImplicitIndexBinding(loc) {\n  return function (x) {\n    if (x._1.length !== 0) {\n      return x;\n    } else {\n      return /* NonEmpty */{\n              _0: x._0,\n              _1: [{\n                  NAME: \"Binding\",\n                  VAL: [\n                    loc,\n                    \"_\"\n                  ]\n                }]\n            };\n    }\n  };\n}\n\nfunction match$1(patterns, json, loc, stack) {\n  var x = match(patterns, json);\n  if (x.TAG === /* Ok */0) {\n    return x;\n  }\n  var match$2 = x._0;\n  if (typeof match$2 === \"number\") {\n    if (match$2 === /* NoMatch */0) {\n      return {\n              TAG: /* Error */1,\n              _0: Debug$AcutisLang.noMatchFound(loc, stack)\n            };\n    } else {\n      return {\n              TAG: /* Error */1,\n              _0: Debug$AcutisLang.patternNumberMismatch(loc, stack)\n            };\n    }\n  } else if (match$2.TAG === /* PatternTypeMismatch */0) {\n    return {\n            TAG: /* Error */1,\n            _0: Debug$AcutisLang.patternTypeMismatch(match$2.data, match$2.pattern, stack)\n          };\n  } else {\n    return {\n            TAG: /* Error */1,\n            _0: Debug$AcutisLang.nameBoundMultipleTimes(match$2.loc, match$2.binding, stack)\n          };\n  }\n}\n\nfunction trimStart(string) {\n  var _pos = 0;\n  while(true) {\n    var pos = _pos;\n    var match = string.charAt(pos);\n    switch (match) {\n      case \"\\t\" :\n      case \"\\n\" :\n      case \"\\r\" :\n      case \" \" :\n          _pos = pos + 1 | 0;\n          continue ;\n      default:\n        return string.slice(pos);\n    }\n  };\n}\n\nfunction trimEnd(string) {\n  var _pos = string.length;\n  while(true) {\n    var pos = _pos;\n    var match = string.charAt(pos - 1 | 0);\n    switch (match) {\n      case \"\\t\" :\n      case \"\\n\" :\n      case \"\\r\" :\n      case \" \" :\n          _pos = pos - 1 | 0;\n          continue ;\n      default:\n        return string.slice(0, pos);\n    }\n  };\n}\n\nfunction echo(head, tail, props, stack, children, env, error) {\n  var _head = head;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    var head$1 = _head;\n    switch (head$1.TAG | 0) {\n      case /* Binding */0 :\n          var binding = head$1._1;\n          var x = echoBinding(props, binding);\n          if (x.TAG === /* Ok */0) {\n            return env.return($$escape$1(head$1._2, x._0));\n          }\n          var type_ = x._0;\n          var match = Belt_Array.get(tail, i);\n          if (typeof type_ === \"number\" && type_ >= 2 && match !== undefined) {\n            _i = i + 1 | 0;\n            _head = match;\n            continue ;\n          }\n          return error([Debug$AcutisLang.badEchoType(head$1._0, binding, type_, stack)]);\n          break;\n      case /* Child */1 :\n          var child = head$1._1;\n          var x$1 = Js_dict.get(children, child);\n          if (x$1 !== undefined) {\n            return Caml_option.valFromOption(x$1);\n          }\n          var head$2 = Belt_Array.get(tail, i);\n          if (head$2 === undefined) {\n            return error([Debug$AcutisLang.childDoesNotExist(head$1._0, child, stack)]);\n          }\n          _i = i + 1 | 0;\n          _head = head$2;\n          continue ;\n      case /* String */2 :\n          return env.return($$escape$1(head$1._1, head$1._0));\n      case /* Number */3 :\n          return env.return($$escape$1(head$1._1, String(head$1._0)));\n      \n    }\n  };\n}\n\nfunction make(ast, props, children, envData, makeEnv, error, try_, reduceQueue) {\n  var stack = envData.stack;\n  var components = envData.components;\n  var env = makeEnv(envData);\n  var queue = Belt_MutableQueue.make(undefined);\n  Belt_Array.forEachU(ast, (function (node) {\n          switch (node.TAG | 0) {\n            case /* Text */0 :\n                var str = node._0;\n                var tmp;\n                switch (node._1) {\n                  case /* TrimStart */0 :\n                      tmp = trimStart(str);\n                      break;\n                  case /* TrimEnd */1 :\n                      tmp = trimEnd(str);\n                      break;\n                  case /* TrimBoth */2 :\n                      tmp = trimStart(trimEnd(str));\n                      break;\n                  case /* NoTrim */3 :\n                      tmp = str;\n                      break;\n                  \n                }\n                return Belt_MutableQueue.add(queue, env.return(tmp));\n            case /* Echo */1 :\n                var match$2 = node._1;\n                return Belt_MutableQueue.add(queue, echo(match$2._0, match$2._1, props, stack, children, env, error));\n            case /* Match */2 :\n                var patterns = Acutis_Types$AcutisLang.NonEmpty.map(node._2, (function (param) {\n                        var ast = param.ast;\n                        return {\n                                patterns: param.patterns,\n                                f: (function (props$prime) {\n                                    return make(ast, Object.assign({}, props, props$prime), children, {\n                                                components: envData.components,\n                                                stack: {\n                                                  hd: /* Match */0,\n                                                  tl: stack\n                                                }\n                                              }, makeEnv, error, try_, reduceQueue);\n                                  })\n                              };\n                      }));\n                var data = Acutis_Types$AcutisLang.NonEmpty.map(node._1, (function (param) {\n                        return getBindingOrNull(props, param[1]);\n                      }));\n                var result = match$1(patterns, data, node._0, stack);\n                if (result.TAG === /* Ok */0) {\n                  return Belt_MutableQueue.transfer(result._0, queue);\n                } else {\n                  return Belt_MutableQueue.add(queue, error([result._0]));\n                }\n            case /* Map */3 :\n                var cases = node._2;\n                var pattern = node._1;\n                var loc = node._0;\n                var variant = pattern.NAME;\n                var data$1;\n                if (variant === \"Array\" || variant === \"ArrayWithTailBinding\") {\n                  data$1 = toArray(pattern, props, stack);\n                } else {\n                  var match$3 = pattern.VAL;\n                  var binding = match$3[1];\n                  var loc$1 = match$3[0];\n                  var arr = Js_json.classify(getBindingOrNull(props, binding));\n                  data$1 = typeof arr === \"number\" || arr.TAG !== /* JSONArray */3 ? ({\n                        TAG: /* Error */1,\n                        _0: Debug$AcutisLang.badMapType(loc$1, binding, arr, stack)\n                      }) : ({\n                        TAG: /* Ok */0,\n                        _0: arr._0\n                      });\n                }\n                if (data$1.TAG === /* Ok */0) {\n                  return Belt_Array.forEachWithIndexU(data$1._0, (function (index, json) {\n                                var patterns = Acutis_Types$AcutisLang.NonEmpty.map(cases, (function (param) {\n                                        var ast = param.ast;\n                                        return {\n                                                patterns: Acutis_Types$AcutisLang.NonEmpty.map(param.patterns, addImplicitIndexBinding(loc)),\n                                                f: (function (props$prime) {\n                                                    return make(ast, Object.assign({}, props, props$prime), children, {\n                                                                components: envData.components,\n                                                                stack: {\n                                                                  hd: {\n                                                                    TAG: /* Index */2,\n                                                                    _0: index\n                                                                  },\n                                                                  tl: {\n                                                                    hd: /* Map */1,\n                                                                    tl: stack\n                                                                  }\n                                                                }\n                                                              }, makeEnv, error, try_, reduceQueue);\n                                                  })\n                                              };\n                                      }));\n                                var result = match$1(patterns, /* NonEmpty */{\n                                      _0: json,\n                                      _1: [index]\n                                    }, loc, stack);\n                                if (result.TAG === /* Ok */0) {\n                                  return Belt_MutableQueue.transfer(result._0, queue);\n                                } else {\n                                  return Belt_MutableQueue.add(queue, error([result._0]));\n                                }\n                              }));\n                } else {\n                  return Belt_MutableQueue.add(queue, error([data$1._0]));\n                }\n            case /* Component */4 :\n                var name = node.name;\n                var loc$2 = node.loc;\n                var component = Js_dict.get(components, name);\n                if (component === undefined) {\n                  return Belt_MutableQueue.add(queue, error([Debug$AcutisLang.componentDoesNotExist(loc$2, name, stack)]));\n                }\n                var compProps = {};\n                var compChildren = {};\n                var errors = Belt_MutableQueue.make(undefined);\n                Belt_Array.forEachU(node.children, (function (param) {\n                        var child = param[1];\n                        var key = param[0];\n                        if (child.TAG === /* ChildName */0) {\n                          var child$1 = child._0;\n                          var data = Js_dict.get(children, child$1);\n                          if (data !== undefined) {\n                            compChildren[key] = Caml_option.valFromOption(data);\n                            return ;\n                          } else {\n                            return Belt_MutableQueue.add(errors, Debug$AcutisLang.childDoesNotExist(loc$2, child$1, stack));\n                          }\n                        }\n                        compChildren[key] = reduceQueue(make(child._0, props, children, {\n                                  components: envData.components,\n                                  stack: {\n                                    hd: {\n                                      TAG: /* Section */1,\n                                      component: name,\n                                      section: key\n                                    },\n                                    tl: stack\n                                  }\n                                }, makeEnv, error, try_, reduceQueue));\n                        \n                      }));\n                Belt_Array.forEachU(node.props, (function (param) {\n                        var data = toJson(param[1], props, stack);\n                        if (data.TAG !== /* Ok */0) {\n                          return Belt_MutableQueue.add(errors, data._0);\n                        }\n                        compProps[param[0]] = data._0;\n                        \n                      }));\n                if (Belt_MutableQueue.isEmpty(errors)) {\n                  return Belt_MutableQueue.add(queue, try_((function () {\n                                    return component(env, compProps, compChildren);\n                                  }), (function (e) {\n                                    return error([Debug$AcutisLang.componentExn(e, stack)]);\n                                  })));\n                } else {\n                  return Belt_MutableQueue.add(queue, error(Belt_MutableQueue.toArray(errors)));\n                }\n            \n          }\n        }));\n  return queue;\n}\n\nvar Pattern = {\n  toJson: toJson,\n  test: test\n};\n\nexport {\n  Pattern ,\n  make ,\n  \n}\n/* No side effect */\n","\n\n\nfunction caml_int_compare(x, y) {\n  if (x < y) {\n    return -1;\n  } else if (x === y) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nfunction caml_bool_compare(x, y) {\n  if (x) {\n    if (y) {\n      return 0;\n    } else {\n      return 1;\n    }\n  } else if (y) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nfunction caml_float_compare(x, y) {\n  if (x === y) {\n    return 0;\n  } else if (x < y) {\n    return -1;\n  } else if (x > y || x === x) {\n    return 1;\n  } else if (y === y) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nfunction caml_string_compare(s1, s2) {\n  if (s1 === s2) {\n    return 0;\n  } else if (s1 < s2) {\n    return -1;\n  } else {\n    return 1;\n  }\n}\n\nfunction caml_bool_min(x, y) {\n  if (x) {\n    return y;\n  } else {\n    return x;\n  }\n}\n\nfunction caml_int_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_float_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_string_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_nativeint_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_int32_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_bool_max(x, y) {\n  if (x) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_int_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_float_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_string_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_nativeint_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_int32_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nvar caml_nativeint_compare = caml_int_compare;\n\nvar caml_int32_compare = caml_int_compare;\n\nexport {\n  caml_int_compare ,\n  caml_bool_compare ,\n  caml_float_compare ,\n  caml_nativeint_compare ,\n  caml_string_compare ,\n  caml_int32_compare ,\n  caml_bool_min ,\n  caml_int_min ,\n  caml_float_min ,\n  caml_string_min ,\n  caml_nativeint_min ,\n  caml_int32_min ,\n  caml_bool_max ,\n  caml_int_max ,\n  caml_float_max ,\n  caml_string_max ,\n  caml_nativeint_max ,\n  caml_int32_max ,\n  \n}\n/* No side effect */\n","// Generated by ReScript, PLEASE EDIT WITH CARE\n\nimport * as Belt_Array from \"bs-platform/lib/es6/belt_Array.js\";\nimport * as Debug$AcutisLang from \"./Debug.bs.js\";\nimport * as Belt_MutableQueue from \"bs-platform/lib/es6/belt_MutableQueue.js\";\nimport * as Render$AcutisLang from \"./Render.bs.js\";\nimport * as Caml_js_exceptions from \"bs-platform/lib/es6/caml_js_exceptions.js\";\nimport * as Acutis_Types$AcutisLang from \"./Acutis_Types.bs.js\";\n\nfunction returnAsync(x) {\n  return Promise.resolve({\n              NAME: \"data\",\n              VAL: x\n            });\n}\n\nfunction error(x) {\n  return Promise.resolve({\n              NAME: \"errors\",\n              VAL: x\n            });\n}\n\nfunction try_(f, $$catch) {\n  return f().catch(function (e) {\n              return $$catch(e);\n            });\n}\n\nfunction mapChildAsync(child, f) {\n  return child.then(function (child) {\n              if (child.NAME === \"errors\") {\n                return Promise.resolve(child);\n              } else {\n                return Promise.resolve({\n                            NAME: \"data\",\n                            VAL: f(child.VAL)\n                          });\n              }\n            });\n}\n\nfunction flatMapChildAsync(child, f) {\n  return child.then(function (child) {\n              if (child.NAME === \"errors\") {\n                return Promise.resolve(child);\n              } else {\n                return f(child.VAL);\n              }\n            });\n}\n\nfunction reduceArray(a) {\n  var result = {\n    contents: \"\"\n  };\n  var errors = Belt_MutableQueue.make(undefined);\n  Belt_Array.forEachU(a, (function (x) {\n          if (x.NAME === \"errors\") {\n            return Belt_Array.forEachU(x.VAL, (function (x) {\n                          return Belt_MutableQueue.add(errors, x);\n                        }));\n          } else {\n            result.contents = result.contents + x.VAL;\n            return ;\n          }\n        }));\n  if (Belt_MutableQueue.isEmpty(errors)) {\n    return Promise.resolve({\n                NAME: \"data\",\n                VAL: result.contents\n              });\n  } else {\n    return Promise.resolve({\n                NAME: \"errors\",\n                VAL: Belt_MutableQueue.toArray(errors)\n              });\n  }\n}\n\nfunction reduceQueue(q) {\n  return Promise.all(Belt_MutableQueue.toArray(q)).then(reduceArray);\n}\n\nfunction makeAux(param) {\n  var stack = param.stack;\n  var components = param.components;\n  return {\n          render: (function (ast, props, children) {\n              var match = Acutis_Types$AcutisLang.Valid.validate(ast);\n              if (match === undefined) {\n                return Promise.resolve({\n                            NAME: \"errors\",\n                            VAL: [Debug$AcutisLang.invalidInput(stack)]\n                          });\n              }\n              if (match.NAME === \"errors\") {\n                return Promise.resolve({\n                            NAME: \"errors\",\n                            VAL: [match.VAL]\n                          });\n              }\n              var match$1 = match.VAL;\n              return reduceQueue(Render$AcutisLang.make(match$1.ast, props, children, {\n                              components: components,\n                              stack: {\n                                hd: {\n                                  TAG: /* Component */0,\n                                  _0: match$1.name\n                                },\n                                tl: stack\n                              }\n                            }, makeAux, error, try_, reduceQueue));\n            }),\n          return: returnAsync,\n          error: (function (message) {\n              return Promise.resolve({\n                          NAME: \"errors\",\n                          VAL: [Debug$AcutisLang.customError(message, stack)]\n                        });\n            }),\n          mapChild: mapChildAsync,\n          flatMapChild: flatMapChildAsync\n        };\n}\n\nfunction make(components) {\n  return makeAux({\n              components: components,\n              stack: /* [] */0\n            });\n}\n\nfunction $$return(x) {\n  return {\n          NAME: \"data\",\n          VAL: x\n        };\n}\n\nfunction error$1(x) {\n  return {\n          NAME: \"errors\",\n          VAL: x\n        };\n}\n\nfunction try_$1(f, $$catch) {\n  try {\n    return f();\n  }\n  catch (raw_e){\n    var e = Caml_js_exceptions.internalToOCamlException(raw_e);\n    return $$catch(e);\n  }\n}\n\nfunction mapChild(child, f) {\n  if (child.NAME === \"errors\") {\n    return child;\n  } else {\n    return {\n            NAME: \"data\",\n            VAL: f(child.VAL)\n          };\n  }\n}\n\nfunction flatMapChild(child, f) {\n  if (child.NAME === \"errors\") {\n    return child;\n  } else {\n    return f(child.VAL);\n  }\n}\n\nfunction reduceQueue$1(q) {\n  var result = {\n    contents: \"\"\n  };\n  var errors = Belt_MutableQueue.make(undefined);\n  Belt_MutableQueue.forEachU(q, (function (x) {\n          if (x.NAME === \"errors\") {\n            return Belt_Array.forEachU(x.VAL, (function (x) {\n                          return Belt_MutableQueue.add(errors, x);\n                        }));\n          } else {\n            result.contents = result.contents + x.VAL;\n            return ;\n          }\n        }));\n  if (Belt_MutableQueue.isEmpty(errors)) {\n    return {\n            NAME: \"data\",\n            VAL: result.contents\n          };\n  } else {\n    return {\n            NAME: \"errors\",\n            VAL: Belt_MutableQueue.toArray(errors)\n          };\n  }\n}\n\nfunction makeAux$1(param) {\n  var stack = param.stack;\n  var components = param.components;\n  return {\n          render: (function (ast, props, children) {\n              var match = Acutis_Types$AcutisLang.Valid.validate(ast);\n              if (match === undefined) {\n                return {\n                        NAME: \"errors\",\n                        VAL: [Debug$AcutisLang.invalidInput(stack)]\n                      };\n              }\n              if (match.NAME === \"errors\") {\n                return {\n                        NAME: \"errors\",\n                        VAL: [match.VAL]\n                      };\n              }\n              var match$1 = match.VAL;\n              return reduceQueue$1(Render$AcutisLang.make(match$1.ast, props, children, {\n                              components: components,\n                              stack: {\n                                hd: {\n                                  TAG: /* Component */0,\n                                  _0: match$1.name\n                                },\n                                tl: stack\n                              }\n                            }, makeAux$1, error$1, try_$1, reduceQueue$1));\n            }),\n          return: $$return,\n          error: (function (message) {\n              return {\n                      NAME: \"errors\",\n                      VAL: [Debug$AcutisLang.customError(message, stack)]\n                    };\n            }),\n          mapChild: mapChild,\n          flatMapChild: flatMapChild\n        };\n}\n\nfunction make$1(components) {\n  return makeAux$1({\n              components: components,\n              stack: /* [] */0\n            });\n}\n\nvar Async = {\n  make: make\n};\n\nexport {\n  Async ,\n  make$1 as make,\n  \n}\n/* No side effect */\n","// Generated by ReScript, PLEASE EDIT WITH CARE\n\nimport * as Compile$AcutisLang from \"./Compile.bs.js\";\nimport * as Environment$AcutisLang from \"./Environment.bs.js\";\n\nvar Compile_makeAst = Compile$AcutisLang.Js.makeAst;\n\nvar Compile_make = Compile$AcutisLang.Js.make;\n\nvar Compile = {\n  makeAst: Compile_makeAst,\n  make: Compile_make\n};\n\nvar Environment = Environment$AcutisLang;\n\nexport {\n  Compile ,\n  Environment ,\n  \n}\n/* No side effect */\n"],"names":["some","x","undefined","BS_PRIVATE_NESTED_SOME_NONE","valFromOption","depth","get","arr","i","length","Caml_option.some","forEachU","a","f","i_finish","mapU","l","r","Array","id","contents","create","str","NonEmpty","map","param","_0","_1","Belt_Array.mapU","Errors","$$location","character","Stack","nameToJson","TAG","x$1","component","section","Token","toString","String","toLocation","Valid","make","data","acutis_is_valid","validate","Ast_Pattern","variant","NAME","VAL","stackToPath","len","xs","_x","_acc","tl","_i","hd","fillAux","Belt_List.toArray","Acutis_Types$AcutisLang.Errors","CompileError","Caml_exceptions.create","unexpectedEofExn","loc","name","RE_EXN_ID","message","kind","location","path","exn","Error","unterminatedCommentExn","unterminatedStringExn","invalidCharacterExn","unexpectedCharacterExn","expected","unexpectedTokenExn","t","Acutis_Types$AcutisLang.Token","badMapTypeParseExn","Acutis_Types$AcutisLang.Ast_Pattern","jsonTaggedTToString","componentDoesNotExist","stack","patternTypeMismatch","pattern","data$1","bindingTypeMismatch","binding","nameBoundMultipleTimes","noMatchFound","patternNumberMismatch","badEchoType","type_","bindingDoesNotExist","childDoesNotExist","child","badMapType","invalidInput","compileExn","e","componentExn","customError","clear","q","first","last","add","cell","content","next","isEmpty","_cell","transfer","q1","q2","toArray","v","peekCharAt","source","charAt","position","peekChar","skipChar","readChar","c","skipBy","readSubstring","until","start","end","peek","slice","readSubstringBy","endOfNumber","readText","tokens","_position","Belt_MutableQueue.add","readComment","_nested","nested","Debug$AcutisLang.unterminatedCommentExn","result","unescapeQuotes","readJsonString","Debug$AcutisLang.unterminatedStringExn","replace","readNumber","i$1","num","num$1","parseFloat","isNaN","identifier","Debug$AcutisLang.illegalIdentifierExn","identifierChar","endOfIdentifier","s","test","identifierStartChar","componentStart","readIdentifier","makeExpression","loop","exit","Debug$AcutisLang.unexpectedEofExn","c$1","Debug$AcutisLang.unexpectedCharacterExn","Debug$AcutisLang.invalidCharacterExn","peekExn","Belt_MutableQueue.peekExn","popExn","Belt_MutableQueue.popExn","$$Error","internalToOCamlException","Caml_exceptions.caml_is_extension","parseNode","t$1","Lexer$AcutisLang.popExn","t$2","t$3","t$4","Debug$AcutisLang.unexpectedTokenExn","Lexer$AcutisLang.name","t$5","Belt_MutableQueue.toArray","loc$1","t$6","q$1","parseObjectKeyValue","t$7","key","Lexer$AcutisLang.peekExn","head","parseBindingName","parseCommaSequence","parseEchoAux","esc","_2","parseEcho","parseEchoes","endOfMatchMap","endOfFile","slash","parse","_t","parseComponent","Debug$AcutisLang.badMapTypeParseExn","parseWithBlocks","x$2","match","parseWithBlock","patterns","ast","block","match$1","props","children","parseProps","makeAst","_mode","echoLoc","Lexer$AcutisLang.make","Acutis_Types$AcutisLang.Valid","raw_e","Caml_js_exceptions.internalToOCamlException","Debug$AcutisLang.CompileError","Debug$AcutisLang.compileExn","dict","k","classify","ty","isArray","opt","treeHeight","n","h","d","hl","hr","bal","ll","lr","rl","rr","set","newK","newD","newValue","Belt_internalAVLtree.bal","has","_n","arrayToQueueResult","Belt_Array.get","Caml_option.valFromOption","toJson","Belt_Result.mapU","Belt_MutableQueue.forEachU","Js_dict.get","Debug$AcutisLang.bindingDoesNotExist","binding$1","Js_json.classify","Debug$AcutisLang.bindingTypeMismatch","binding$2","a1","a2","l1","l2","a1a2","Belt_Array.concat","setBinding","bindings","json","Belt_MapString.has","Belt_MapString.set","testValue","Object","keys","obj","_bindings","bindings$1","json$1","bindings$2","match$2","match$3","match$4","bindLoc","array","testArray","offset","y","lena","ofs","Belt_Array.sliceToEnd","param$1","jsonTail","patternTail","_pattern","_json","Belt_MapString.forEachU","matchCase","jsonSequence","tail","pattern$1","$$escape","$$escape$1","_pos","_result","pos","getBindingOrNull","echoBinding","addImplicitIndexBinding","Debug$AcutisLang.noMatchFound","Debug$AcutisLang.patternNumberMismatch","Debug$AcutisLang.patternTypeMismatch","Debug$AcutisLang.nameBoundMultipleTimes","trimStart","string","trimEnd","envData","makeEnv","error","try_","reduceQueue","components","env","queue","Belt_Array.forEachU","node","tmp","return","_head","head$1","Debug$AcutisLang.badEchoType","head$2","Debug$AcutisLang.childDoesNotExist","echo","Acutis_Types$AcutisLang.NonEmpty","props$prime","assign","Belt_MutableQueue.transfer","cases","Debug$AcutisLang.badMapType","Belt_Array.forEachWithIndexU","index","loc$2","Debug$AcutisLang.componentDoesNotExist","compProps","compChildren","errors","child$1","Belt_MutableQueue.isEmpty","Debug$AcutisLang.componentExn","returnAsync","Promise","resolve","$$catch","catch","mapChildAsync","then","flatMapChildAsync","reduceArray","all","makeAux","render","Debug$AcutisLang.invalidInput","Render$AcutisLang.make","Debug$AcutisLang.customError","mapChild","flatMapChild","$$return","error$1","try_$1","reduceQueue$1","makeAux$1","Async","Compile","templates","make$1","Environment"],"mappings":"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"}
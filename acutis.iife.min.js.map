{"version":3,"file":"acutis.iife.min.js","sources":["../node_modules/bs-platform/lib/es6/caml_exceptions.js","../node_modules/bs-platform/lib/es6/caml_option.js","../node_modules/bs-platform/lib/es6/js_dict.js","../node_modules/bs-platform/lib/es6/belt_Array.js","../node_modules/bs-platform/lib/es6/caml_primitive.js","../node_modules/bs-platform/lib/es6/belt_List.js","../src/Acutis_Types.bs.js","../src/Debug.bs.js","../node_modules/bs-platform/lib/es6/js_json.js","../node_modules/bs-platform/lib/es6/belt_Result.js","../node_modules/bs-platform/lib/es6/belt_MutableQueue.js","../node_modules/bs-platform/lib/es6/caml_js_exceptions.js","../src/Render.bs.js","../node_modules/bs-platform/lib/es6/belt_Option.js","../src/Lexer.bs.js","../node_modules/bs-platform/lib/es6/belt_Float.js","../src/Compile.bs.js","../src/AcutisJs.bs.js"],"sourcesContent":["\n\n\nvar id = {\n  contents: 0\n};\n\nfunction create(str) {\n  id.contents = id.contents + 1 | 0;\n  return str + (\"/\" + id.contents);\n}\n\nfunction caml_is_extension(e) {\n  if (e == null) {\n    return false;\n  } else {\n    return typeof e.RE_EXN_ID === \"string\";\n  }\n}\n\nfunction caml_exn_slot_name(x) {\n  return x.RE_EXN_ID;\n}\n\nexport {\n  id ,\n  create ,\n  caml_is_extension ,\n  caml_exn_slot_name ,\n  \n}\n/* No side effect */\n","\n\n\nfunction isNested(x) {\n  return x.BS_PRIVATE_NESTED_SOME_NONE !== undefined;\n}\n\nfunction some(x) {\n  if (x === undefined) {\n    return {\n            BS_PRIVATE_NESTED_SOME_NONE: 0\n          };\n  } else if (x !== null && x.BS_PRIVATE_NESTED_SOME_NONE !== undefined) {\n    return {\n            BS_PRIVATE_NESTED_SOME_NONE: x.BS_PRIVATE_NESTED_SOME_NONE + 1 | 0\n          };\n  } else {\n    return x;\n  }\n}\n\nfunction nullable_to_opt(x) {\n  if (x == null) {\n    return ;\n  } else {\n    return some(x);\n  }\n}\n\nfunction undefined_to_opt(x) {\n  if (x === undefined) {\n    return ;\n  } else {\n    return some(x);\n  }\n}\n\nfunction null_to_opt(x) {\n  if (x === null) {\n    return ;\n  } else {\n    return some(x);\n  }\n}\n\nfunction valFromOption(x) {\n  if (!(x !== null && x.BS_PRIVATE_NESTED_SOME_NONE !== undefined)) {\n    return x;\n  }\n  var depth = x.BS_PRIVATE_NESTED_SOME_NONE;\n  if (depth === 0) {\n    return ;\n  } else {\n    return {\n            BS_PRIVATE_NESTED_SOME_NONE: depth - 1 | 0\n          };\n  }\n}\n\nfunction option_get(x) {\n  if (x === undefined) {\n    return ;\n  } else {\n    return valFromOption(x);\n  }\n}\n\nfunction option_unwrap(x) {\n  if (x !== undefined) {\n    return x.VAL;\n  } else {\n    return x;\n  }\n}\n\nexport {\n  nullable_to_opt ,\n  undefined_to_opt ,\n  null_to_opt ,\n  valFromOption ,\n  some ,\n  isNested ,\n  option_get ,\n  option_unwrap ,\n  \n}\n/* No side effect */\n","\n\nimport * as Caml_option from \"./caml_option.js\";\n\nfunction get(dict, k) {\n  if ((k in dict)) {\n    return Caml_option.some(dict[k]);\n  }\n  \n}\n\nvar unsafeDeleteKey = (function (dict,key){\n      delete dict[key];\n     });\n\nfunction entries(dict) {\n  var keys = Object.keys(dict);\n  var l = keys.length;\n  var values = new Array(l);\n  for(var i = 0; i < l; ++i){\n    var key = keys[i];\n    values[i] = [\n      key,\n      dict[key]\n    ];\n  }\n  return values;\n}\n\nfunction values(dict) {\n  var keys = Object.keys(dict);\n  var l = keys.length;\n  var values$1 = new Array(l);\n  for(var i = 0; i < l; ++i){\n    values$1[i] = dict[keys[i]];\n  }\n  return values$1;\n}\n\nfunction fromList(entries) {\n  var dict = {};\n  var _param = entries;\n  while(true) {\n    var param = _param;\n    if (!param) {\n      return dict;\n    }\n    var match = param.hd;\n    dict[match[0]] = match[1];\n    _param = param.tl;\n    continue ;\n  };\n}\n\nfunction fromArray(entries) {\n  var dict = {};\n  var l = entries.length;\n  for(var i = 0; i < l; ++i){\n    var match = entries[i];\n    dict[match[0]] = match[1];\n  }\n  return dict;\n}\n\nfunction map(f, source) {\n  var target = {};\n  var keys = Object.keys(source);\n  var l = keys.length;\n  for(var i = 0; i < l; ++i){\n    var key = keys[i];\n    target[key] = f(source[key]);\n  }\n  return target;\n}\n\nexport {\n  get ,\n  unsafeDeleteKey ,\n  entries ,\n  values ,\n  fromList ,\n  fromArray ,\n  map ,\n  \n}\n/* No side effect */\n","\n\nimport * as Curry from \"./curry.js\";\nimport * as Js_math from \"./js_math.js\";\nimport * as Caml_option from \"./caml_option.js\";\nimport * as Caml_primitive from \"./caml_primitive.js\";\n\nfunction get(arr, i) {\n  if (i >= 0 && i < arr.length) {\n    return Caml_option.some(arr[i]);\n  }\n  \n}\n\nfunction getExn(arr, i) {\n  if (!(i >= 0 && i < arr.length)) {\n    throw {\n          RE_EXN_ID: \"Assert_failure\",\n          _1: [\n            \"belt_Array.ml\",\n            27,\n            4\n          ],\n          Error: new Error()\n        };\n  }\n  return arr[i];\n}\n\nfunction set(arr, i, v) {\n  if (i >= 0 && i < arr.length) {\n    arr[i] = v;\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction setExn(arr, i, v) {\n  if (!(i >= 0 && i < arr.length)) {\n    throw {\n          RE_EXN_ID: \"Assert_failure\",\n          _1: [\n            \"belt_Array.ml\",\n            33,\n            2\n          ],\n          Error: new Error()\n        };\n  }\n  arr[i] = v;\n  \n}\n\nfunction swapUnsafe(xs, i, j) {\n  var tmp = xs[i];\n  xs[i] = xs[j];\n  xs[j] = tmp;\n  \n}\n\nfunction shuffleInPlace(xs) {\n  var len = xs.length;\n  for(var i = 0; i < len; ++i){\n    swapUnsafe(xs, i, Js_math.random_int(i, len));\n  }\n  \n}\n\nfunction shuffle(xs) {\n  var result = xs.slice(0);\n  shuffleInPlace(result);\n  return result;\n}\n\nfunction reverseInPlace(xs) {\n  var len = xs.length;\n  var ofs = 0;\n  for(var i = 0 ,i_finish = len / 2 | 0; i < i_finish; ++i){\n    swapUnsafe(xs, ofs + i | 0, ((ofs + len | 0) - i | 0) - 1 | 0);\n  }\n  \n}\n\nfunction reverse(xs) {\n  var len = xs.length;\n  var result = new Array(len);\n  for(var i = 0; i < len; ++i){\n    result[i] = xs[(len - 1 | 0) - i | 0];\n  }\n  return result;\n}\n\nfunction make(l, f) {\n  if (l <= 0) {\n    return [];\n  }\n  var res = new Array(l);\n  for(var i = 0; i < l; ++i){\n    res[i] = f;\n  }\n  return res;\n}\n\nfunction makeByU(l, f) {\n  if (l <= 0) {\n    return [];\n  }\n  var res = new Array(l);\n  for(var i = 0; i < l; ++i){\n    res[i] = f(i);\n  }\n  return res;\n}\n\nfunction makeBy(l, f) {\n  return makeByU(l, Curry.__1(f));\n}\n\nfunction makeByAndShuffleU(l, f) {\n  var u = makeByU(l, f);\n  shuffleInPlace(u);\n  return u;\n}\n\nfunction makeByAndShuffle(l, f) {\n  return makeByAndShuffleU(l, Curry.__1(f));\n}\n\nfunction range(start, finish) {\n  var cut = finish - start | 0;\n  if (cut < 0) {\n    return [];\n  }\n  var arr = new Array(cut + 1 | 0);\n  for(var i = 0; i <= cut; ++i){\n    arr[i] = start + i | 0;\n  }\n  return arr;\n}\n\nfunction rangeBy(start, finish, step) {\n  var cut = finish - start | 0;\n  if (cut < 0 || step <= 0) {\n    return [];\n  }\n  var nb = (cut / step | 0) + 1 | 0;\n  var arr = new Array(nb);\n  var cur = start;\n  for(var i = 0; i < nb; ++i){\n    arr[i] = cur;\n    cur = cur + step | 0;\n  }\n  return arr;\n}\n\nfunction zip(xs, ys) {\n  var lenx = xs.length;\n  var leny = ys.length;\n  var len = lenx < leny ? lenx : leny;\n  var s = new Array(len);\n  for(var i = 0; i < len; ++i){\n    s[i] = [\n      xs[i],\n      ys[i]\n    ];\n  }\n  return s;\n}\n\nfunction zipByU(xs, ys, f) {\n  var lenx = xs.length;\n  var leny = ys.length;\n  var len = lenx < leny ? lenx : leny;\n  var s = new Array(len);\n  for(var i = 0; i < len; ++i){\n    s[i] = f(xs[i], ys[i]);\n  }\n  return s;\n}\n\nfunction zipBy(xs, ys, f) {\n  return zipByU(xs, ys, Curry.__2(f));\n}\n\nfunction concat(a1, a2) {\n  var l1 = a1.length;\n  var l2 = a2.length;\n  var a1a2 = new Array(l1 + l2 | 0);\n  for(var i = 0; i < l1; ++i){\n    a1a2[i] = a1[i];\n  }\n  for(var i$1 = 0; i$1 < l2; ++i$1){\n    a1a2[l1 + i$1 | 0] = a2[i$1];\n  }\n  return a1a2;\n}\n\nfunction concatMany(arrs) {\n  var lenArrs = arrs.length;\n  var totalLen = 0;\n  for(var i = 0; i < lenArrs; ++i){\n    totalLen = totalLen + arrs[i].length | 0;\n  }\n  var result = new Array(totalLen);\n  totalLen = 0;\n  for(var j = 0; j < lenArrs; ++j){\n    var cur = arrs[j];\n    for(var k = 0 ,k_finish = cur.length; k < k_finish; ++k){\n      result[totalLen] = cur[k];\n      totalLen = totalLen + 1 | 0;\n    }\n  }\n  return result;\n}\n\nfunction slice(a, offset, len) {\n  if (len <= 0) {\n    return [];\n  }\n  var lena = a.length;\n  var ofs = offset < 0 ? Caml_primitive.caml_int_max(lena + offset | 0, 0) : offset;\n  var hasLen = lena - ofs | 0;\n  var copyLength = hasLen < len ? hasLen : len;\n  if (copyLength <= 0) {\n    return [];\n  }\n  var result = new Array(copyLength);\n  for(var i = 0; i < copyLength; ++i){\n    result[i] = a[ofs + i | 0];\n  }\n  return result;\n}\n\nfunction sliceToEnd(a, offset) {\n  var lena = a.length;\n  var ofs = offset < 0 ? Caml_primitive.caml_int_max(lena + offset | 0, 0) : offset;\n  var len = lena - ofs | 0;\n  var result = new Array(len);\n  for(var i = 0; i < len; ++i){\n    result[i] = a[ofs + i | 0];\n  }\n  return result;\n}\n\nfunction fill(a, offset, len, v) {\n  if (len <= 0) {\n    return ;\n  }\n  var lena = a.length;\n  var ofs = offset < 0 ? Caml_primitive.caml_int_max(lena + offset | 0, 0) : offset;\n  var hasLen = lena - ofs | 0;\n  var fillLength = hasLen < len ? hasLen : len;\n  if (fillLength <= 0) {\n    return ;\n  }\n  for(var i = ofs ,i_finish = ofs + fillLength | 0; i < i_finish; ++i){\n    a[i] = v;\n  }\n  \n}\n\nfunction blitUnsafe(a1, srcofs1, a2, srcofs2, blitLength) {\n  if (srcofs2 <= srcofs1) {\n    for(var j = 0; j < blitLength; ++j){\n      a2[j + srcofs2 | 0] = a1[j + srcofs1 | 0];\n    }\n    return ;\n  }\n  for(var j$1 = blitLength - 1 | 0; j$1 >= 0; --j$1){\n    a2[j$1 + srcofs2 | 0] = a1[j$1 + srcofs1 | 0];\n  }\n  \n}\n\nfunction blit(a1, ofs1, a2, ofs2, len) {\n  var lena1 = a1.length;\n  var lena2 = a2.length;\n  var srcofs1 = ofs1 < 0 ? Caml_primitive.caml_int_max(lena1 + ofs1 | 0, 0) : ofs1;\n  var srcofs2 = ofs2 < 0 ? Caml_primitive.caml_int_max(lena2 + ofs2 | 0, 0) : ofs2;\n  var blitLength = Caml_primitive.caml_int_min(len, Caml_primitive.caml_int_min(lena1 - srcofs1 | 0, lena2 - srcofs2 | 0));\n  if (srcofs2 <= srcofs1) {\n    for(var j = 0; j < blitLength; ++j){\n      a2[j + srcofs2 | 0] = a1[j + srcofs1 | 0];\n    }\n    return ;\n  }\n  for(var j$1 = blitLength - 1 | 0; j$1 >= 0; --j$1){\n    a2[j$1 + srcofs2 | 0] = a1[j$1 + srcofs1 | 0];\n  }\n  \n}\n\nfunction forEachU(a, f) {\n  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){\n    f(a[i]);\n  }\n  \n}\n\nfunction forEach(a, f) {\n  return forEachU(a, Curry.__1(f));\n}\n\nfunction mapU(a, f) {\n  var l = a.length;\n  var r = new Array(l);\n  for(var i = 0; i < l; ++i){\n    r[i] = f(a[i]);\n  }\n  return r;\n}\n\nfunction map(a, f) {\n  return mapU(a, Curry.__1(f));\n}\n\nfunction getByU(a, p) {\n  var l = a.length;\n  var i = 0;\n  var r;\n  while(r === undefined && i < l) {\n    var v = a[i];\n    if (p(v)) {\n      r = Caml_option.some(v);\n    }\n    i = i + 1 | 0;\n  };\n  return r;\n}\n\nfunction getBy(a, p) {\n  return getByU(a, Curry.__1(p));\n}\n\nfunction getIndexByU(a, p) {\n  var l = a.length;\n  var i = 0;\n  var r;\n  while(r === undefined && i < l) {\n    var v = a[i];\n    if (p(v)) {\n      r = i;\n    }\n    i = i + 1 | 0;\n  };\n  return r;\n}\n\nfunction getIndexBy(a, p) {\n  return getIndexByU(a, Curry.__1(p));\n}\n\nfunction keepU(a, f) {\n  var l = a.length;\n  var r = new Array(l);\n  var j = 0;\n  for(var i = 0; i < l; ++i){\n    var v = a[i];\n    if (f(v)) {\n      r[j] = v;\n      j = j + 1 | 0;\n    }\n    \n  }\n  r.length = j;\n  return r;\n}\n\nfunction keep(a, f) {\n  return keepU(a, Curry.__1(f));\n}\n\nfunction keepWithIndexU(a, f) {\n  var l = a.length;\n  var r = new Array(l);\n  var j = 0;\n  for(var i = 0; i < l; ++i){\n    var v = a[i];\n    if (f(v, i)) {\n      r[j] = v;\n      j = j + 1 | 0;\n    }\n    \n  }\n  r.length = j;\n  return r;\n}\n\nfunction keepWithIndex(a, f) {\n  return keepWithIndexU(a, Curry.__2(f));\n}\n\nfunction keepMapU(a, f) {\n  var l = a.length;\n  var r = new Array(l);\n  var j = 0;\n  for(var i = 0; i < l; ++i){\n    var v = a[i];\n    var v$1 = f(v);\n    if (v$1 !== undefined) {\n      r[j] = Caml_option.valFromOption(v$1);\n      j = j + 1 | 0;\n    }\n    \n  }\n  r.length = j;\n  return r;\n}\n\nfunction keepMap(a, f) {\n  return keepMapU(a, Curry.__1(f));\n}\n\nfunction forEachWithIndexU(a, f) {\n  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){\n    f(i, a[i]);\n  }\n  \n}\n\nfunction forEachWithIndex(a, f) {\n  return forEachWithIndexU(a, Curry.__2(f));\n}\n\nfunction mapWithIndexU(a, f) {\n  var l = a.length;\n  var r = new Array(l);\n  for(var i = 0; i < l; ++i){\n    r[i] = f(i, a[i]);\n  }\n  return r;\n}\n\nfunction mapWithIndex(a, f) {\n  return mapWithIndexU(a, Curry.__2(f));\n}\n\nfunction reduceU(a, x, f) {\n  var r = x;\n  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){\n    r = f(r, a[i]);\n  }\n  return r;\n}\n\nfunction reduce(a, x, f) {\n  return reduceU(a, x, Curry.__2(f));\n}\n\nfunction reduceReverseU(a, x, f) {\n  var r = x;\n  for(var i = a.length - 1 | 0; i >= 0; --i){\n    r = f(r, a[i]);\n  }\n  return r;\n}\n\nfunction reduceReverse(a, x, f) {\n  return reduceReverseU(a, x, Curry.__2(f));\n}\n\nfunction reduceReverse2U(a, b, x, f) {\n  var r = x;\n  var len = Caml_primitive.caml_int_min(a.length, b.length);\n  for(var i = len - 1 | 0; i >= 0; --i){\n    r = f(r, a[i], b[i]);\n  }\n  return r;\n}\n\nfunction reduceReverse2(a, b, x, f) {\n  return reduceReverse2U(a, b, x, Curry.__3(f));\n}\n\nfunction reduceWithIndexU(a, x, f) {\n  var r = x;\n  for(var i = 0 ,i_finish = a.length; i < i_finish; ++i){\n    r = f(r, a[i], i);\n  }\n  return r;\n}\n\nfunction reduceWithIndex(a, x, f) {\n  return reduceWithIndexU(a, x, Curry.__3(f));\n}\n\nfunction everyU(arr, b) {\n  var len = arr.length;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    if (i === len) {\n      return true;\n    }\n    if (!b(arr[i])) {\n      return false;\n    }\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction every(arr, f) {\n  return everyU(arr, Curry.__1(f));\n}\n\nfunction someU(arr, b) {\n  var len = arr.length;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    if (i === len) {\n      return false;\n    }\n    if (b(arr[i])) {\n      return true;\n    }\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction some(arr, f) {\n  return someU(arr, Curry.__1(f));\n}\n\nfunction everyAux2(arr1, arr2, _i, b, len) {\n  while(true) {\n    var i = _i;\n    if (i === len) {\n      return true;\n    }\n    if (!b(arr1[i], arr2[i])) {\n      return false;\n    }\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction every2U(a, b, p) {\n  return everyAux2(a, b, 0, p, Caml_primitive.caml_int_min(a.length, b.length));\n}\n\nfunction every2(a, b, p) {\n  return every2U(a, b, Curry.__2(p));\n}\n\nfunction some2U(a, b, p) {\n  var _i = 0;\n  var len = Caml_primitive.caml_int_min(a.length, b.length);\n  while(true) {\n    var i = _i;\n    if (i === len) {\n      return false;\n    }\n    if (p(a[i], b[i])) {\n      return true;\n    }\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction some2(a, b, p) {\n  return some2U(a, b, Curry.__2(p));\n}\n\nfunction eqU(a, b, p) {\n  var lena = a.length;\n  var lenb = b.length;\n  if (lena === lenb) {\n    return everyAux2(a, b, 0, p, lena);\n  } else {\n    return false;\n  }\n}\n\nfunction eq(a, b, p) {\n  return eqU(a, b, Curry.__2(p));\n}\n\nfunction cmpU(a, b, p) {\n  var lena = a.length;\n  var lenb = b.length;\n  if (lena > lenb) {\n    return 1;\n  } else if (lena < lenb) {\n    return -1;\n  } else {\n    var _i = 0;\n    while(true) {\n      var i = _i;\n      if (i === lena) {\n        return 0;\n      }\n      var c = p(a[i], b[i]);\n      if (c !== 0) {\n        return c;\n      }\n      _i = i + 1 | 0;\n      continue ;\n    };\n  }\n}\n\nfunction cmp(a, b, p) {\n  return cmpU(a, b, Curry.__2(p));\n}\n\nfunction partitionU(a, f) {\n  var l = a.length;\n  var i = 0;\n  var j = 0;\n  var a1 = new Array(l);\n  var a2 = new Array(l);\n  for(var ii = 0; ii < l; ++ii){\n    var v = a[ii];\n    if (f(v)) {\n      a1[i] = v;\n      i = i + 1 | 0;\n    } else {\n      a2[j] = v;\n      j = j + 1 | 0;\n    }\n  }\n  a1.length = i;\n  a2.length = j;\n  return [\n          a1,\n          a2\n        ];\n}\n\nfunction partition(a, f) {\n  return partitionU(a, Curry.__1(f));\n}\n\nfunction unzip(a) {\n  var l = a.length;\n  var a1 = new Array(l);\n  var a2 = new Array(l);\n  for(var i = 0; i < l; ++i){\n    var match = a[i];\n    a1[i] = match[0];\n    a2[i] = match[1];\n  }\n  return [\n          a1,\n          a2\n        ];\n}\n\nfunction joinWithU(a, sep, toString) {\n  var l = a.length;\n  if (l === 0) {\n    return \"\";\n  }\n  var lastIndex = l - 1 | 0;\n  var _i = 0;\n  var _res = \"\";\n  while(true) {\n    var res = _res;\n    var i = _i;\n    if (i === lastIndex) {\n      return res + toString(a[i]);\n    }\n    _res = res + (toString(a[i]) + sep);\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction joinWith(a, sep, toString) {\n  return joinWithU(a, sep, Curry.__1(toString));\n}\n\nexport {\n  get ,\n  getExn ,\n  set ,\n  setExn ,\n  shuffleInPlace ,\n  shuffle ,\n  reverseInPlace ,\n  reverse ,\n  make ,\n  range ,\n  rangeBy ,\n  makeByU ,\n  makeBy ,\n  makeByAndShuffleU ,\n  makeByAndShuffle ,\n  zip ,\n  zipByU ,\n  zipBy ,\n  unzip ,\n  concat ,\n  concatMany ,\n  slice ,\n  sliceToEnd ,\n  fill ,\n  blit ,\n  blitUnsafe ,\n  forEachU ,\n  forEach ,\n  mapU ,\n  map ,\n  getByU ,\n  getBy ,\n  getIndexByU ,\n  getIndexBy ,\n  keepU ,\n  keep ,\n  keepWithIndexU ,\n  keepWithIndex ,\n  keepMapU ,\n  keepMap ,\n  forEachWithIndexU ,\n  forEachWithIndex ,\n  mapWithIndexU ,\n  mapWithIndex ,\n  partitionU ,\n  partition ,\n  reduceU ,\n  reduce ,\n  reduceReverseU ,\n  reduceReverse ,\n  reduceReverse2U ,\n  reduceReverse2 ,\n  reduceWithIndexU ,\n  reduceWithIndex ,\n  joinWithU ,\n  joinWith ,\n  someU ,\n  some ,\n  everyU ,\n  every ,\n  every2U ,\n  every2 ,\n  some2U ,\n  some2 ,\n  cmpU ,\n  cmp ,\n  eqU ,\n  eq ,\n  \n}\n/* No side effect */\n","\n\n\nfunction caml_int_compare(x, y) {\n  if (x < y) {\n    return -1;\n  } else if (x === y) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nfunction caml_bool_compare(x, y) {\n  if (x) {\n    if (y) {\n      return 0;\n    } else {\n      return 1;\n    }\n  } else if (y) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nfunction caml_float_compare(x, y) {\n  if (x === y) {\n    return 0;\n  } else if (x < y) {\n    return -1;\n  } else if (x > y || x === x) {\n    return 1;\n  } else if (y === y) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nfunction caml_string_compare(s1, s2) {\n  if (s1 === s2) {\n    return 0;\n  } else if (s1 < s2) {\n    return -1;\n  } else {\n    return 1;\n  }\n}\n\nfunction caml_bool_min(x, y) {\n  if (x) {\n    return y;\n  } else {\n    return x;\n  }\n}\n\nfunction caml_int_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_float_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_string_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_nativeint_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_int32_min(x, y) {\n  if (x < y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_bool_max(x, y) {\n  if (x) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_int_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_float_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_string_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_nativeint_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nfunction caml_int32_max(x, y) {\n  if (x > y) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\nvar caml_nativeint_compare = caml_int_compare;\n\nvar caml_int32_compare = caml_int_compare;\n\nexport {\n  caml_int_compare ,\n  caml_bool_compare ,\n  caml_float_compare ,\n  caml_nativeint_compare ,\n  caml_string_compare ,\n  caml_int32_compare ,\n  caml_bool_min ,\n  caml_int_min ,\n  caml_float_min ,\n  caml_string_min ,\n  caml_nativeint_min ,\n  caml_int32_min ,\n  caml_bool_max ,\n  caml_int_max ,\n  caml_float_max ,\n  caml_string_max ,\n  caml_nativeint_max ,\n  caml_int32_max ,\n  \n}\n/* No side effect */\n","\n\nimport * as Curry from \"./curry.js\";\nimport * as Belt_Array from \"./belt_Array.js\";\nimport * as Caml_option from \"./caml_option.js\";\nimport * as Belt_SortArray from \"./belt_SortArray.js\";\n\nfunction head(x) {\n  if (x) {\n    return Caml_option.some(x.hd);\n  }\n  \n}\n\nfunction headExn(x) {\n  if (x) {\n    return x.hd;\n  }\n  throw {\n        RE_EXN_ID: \"Not_found\",\n        Error: new Error()\n      };\n}\n\nfunction tail(x) {\n  if (x) {\n    return x.tl;\n  }\n  \n}\n\nfunction tailExn(x) {\n  if (x) {\n    return x.tl;\n  }\n  throw {\n        RE_EXN_ID: \"Not_found\",\n        Error: new Error()\n      };\n}\n\nfunction add(xs, x) {\n  return {\n          hd: x,\n          tl: xs\n        };\n}\n\nfunction get(x, n) {\n  if (n < 0) {\n    return ;\n  } else {\n    var _x = x;\n    var _n = n;\n    while(true) {\n      var n$1 = _n;\n      var x$1 = _x;\n      if (!x$1) {\n        return ;\n      }\n      if (n$1 === 0) {\n        return Caml_option.some(x$1.hd);\n      }\n      _n = n$1 - 1 | 0;\n      _x = x$1.tl;\n      continue ;\n    };\n  }\n}\n\nfunction getExn(x, n) {\n  if (n < 0) {\n    throw {\n          RE_EXN_ID: \"Not_found\",\n          Error: new Error()\n        };\n  }\n  var _x = x;\n  var _n = n;\n  while(true) {\n    var n$1 = _n;\n    var x$1 = _x;\n    if (x$1) {\n      if (n$1 === 0) {\n        return x$1.hd;\n      }\n      _n = n$1 - 1 | 0;\n      _x = x$1.tl;\n      continue ;\n    }\n    throw {\n          RE_EXN_ID: \"Not_found\",\n          Error: new Error()\n        };\n  };\n}\n\nfunction partitionAux(p, _cell, _precX, _precY) {\n  while(true) {\n    var precY = _precY;\n    var precX = _precX;\n    var cell = _cell;\n    if (!cell) {\n      return ;\n    }\n    var t = cell.tl;\n    var h = cell.hd;\n    var next = {\n      hd: h,\n      tl: /* [] */0\n    };\n    if (p(h)) {\n      precX.tl = next;\n      _precX = next;\n      _cell = t;\n      continue ;\n    }\n    precY.tl = next;\n    _precY = next;\n    _cell = t;\n    continue ;\n  };\n}\n\nfunction splitAux(_cell, _precX, _precY) {\n  while(true) {\n    var precY = _precY;\n    var precX = _precX;\n    var cell = _cell;\n    if (!cell) {\n      return ;\n    }\n    var match = cell.hd;\n    var nextA = {\n      hd: match[0],\n      tl: /* [] */0\n    };\n    var nextB = {\n      hd: match[1],\n      tl: /* [] */0\n    };\n    precX.tl = nextA;\n    precY.tl = nextB;\n    _precY = nextB;\n    _precX = nextA;\n    _cell = cell.tl;\n    continue ;\n  };\n}\n\nfunction copyAuxCont(_cellX, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cellX = _cellX;\n    if (!cellX) {\n      return prec;\n    }\n    var next = {\n      hd: cellX.hd,\n      tl: /* [] */0\n    };\n    prec.tl = next;\n    _prec = next;\n    _cellX = cellX.tl;\n    continue ;\n  };\n}\n\nfunction copyAuxWitFilter(f, _cellX, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cellX = _cellX;\n    if (!cellX) {\n      return ;\n    }\n    var t = cellX.tl;\n    var h = cellX.hd;\n    if (f(h)) {\n      var next = {\n        hd: h,\n        tl: /* [] */0\n      };\n      prec.tl = next;\n      _prec = next;\n      _cellX = t;\n      continue ;\n    }\n    _cellX = t;\n    continue ;\n  };\n}\n\nfunction copyAuxWithFilterIndex(f, _cellX, _prec, _i) {\n  while(true) {\n    var i = _i;\n    var prec = _prec;\n    var cellX = _cellX;\n    if (!cellX) {\n      return ;\n    }\n    var t = cellX.tl;\n    var h = cellX.hd;\n    if (f(h, i)) {\n      var next = {\n        hd: h,\n        tl: /* [] */0\n      };\n      prec.tl = next;\n      _i = i + 1 | 0;\n      _prec = next;\n      _cellX = t;\n      continue ;\n    }\n    _i = i + 1 | 0;\n    _cellX = t;\n    continue ;\n  };\n}\n\nfunction copyAuxWitFilterMap(f, _cellX, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cellX = _cellX;\n    if (!cellX) {\n      return ;\n    }\n    var t = cellX.tl;\n    var h = f(cellX.hd);\n    if (h !== undefined) {\n      var next = {\n        hd: Caml_option.valFromOption(h),\n        tl: /* [] */0\n      };\n      prec.tl = next;\n      _prec = next;\n      _cellX = t;\n      continue ;\n    }\n    _cellX = t;\n    continue ;\n  };\n}\n\nfunction removeAssocAuxWithMap(_cellX, x, _prec, f) {\n  while(true) {\n    var prec = _prec;\n    var cellX = _cellX;\n    if (!cellX) {\n      return false;\n    }\n    var t = cellX.tl;\n    var h = cellX.hd;\n    if (f(h[0], x)) {\n      prec.tl = t;\n      return true;\n    }\n    var next = {\n      hd: h,\n      tl: /* [] */0\n    };\n    prec.tl = next;\n    _prec = next;\n    _cellX = t;\n    continue ;\n  };\n}\n\nfunction setAssocAuxWithMap(_cellX, x, k, _prec, eq) {\n  while(true) {\n    var prec = _prec;\n    var cellX = _cellX;\n    if (!cellX) {\n      return false;\n    }\n    var t = cellX.tl;\n    var h = cellX.hd;\n    if (eq(h[0], x)) {\n      prec.tl = {\n        hd: [\n          x,\n          k\n        ],\n        tl: t\n      };\n      return true;\n    }\n    var next = {\n      hd: h,\n      tl: /* [] */0\n    };\n    prec.tl = next;\n    _prec = next;\n    _cellX = t;\n    continue ;\n  };\n}\n\nfunction copyAuxWithMap(_cellX, _prec, f) {\n  while(true) {\n    var prec = _prec;\n    var cellX = _cellX;\n    if (!cellX) {\n      return ;\n    }\n    var next = {\n      hd: f(cellX.hd),\n      tl: /* [] */0\n    };\n    prec.tl = next;\n    _prec = next;\n    _cellX = cellX.tl;\n    continue ;\n  };\n}\n\nfunction zipAux(_cellX, _cellY, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cellY = _cellY;\n    var cellX = _cellX;\n    if (!cellX) {\n      return ;\n    }\n    if (!cellY) {\n      return ;\n    }\n    var next = {\n      hd: [\n        cellX.hd,\n        cellY.hd\n      ],\n      tl: /* [] */0\n    };\n    prec.tl = next;\n    _prec = next;\n    _cellY = cellY.tl;\n    _cellX = cellX.tl;\n    continue ;\n  };\n}\n\nfunction copyAuxWithMap2(f, _cellX, _cellY, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cellY = _cellY;\n    var cellX = _cellX;\n    if (!cellX) {\n      return ;\n    }\n    if (!cellY) {\n      return ;\n    }\n    var next = {\n      hd: f(cellX.hd, cellY.hd),\n      tl: /* [] */0\n    };\n    prec.tl = next;\n    _prec = next;\n    _cellY = cellY.tl;\n    _cellX = cellX.tl;\n    continue ;\n  };\n}\n\nfunction copyAuxWithMapI(f, _i, _cellX, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cellX = _cellX;\n    var i = _i;\n    if (!cellX) {\n      return ;\n    }\n    var next = {\n      hd: f(i, cellX.hd),\n      tl: /* [] */0\n    };\n    prec.tl = next;\n    _prec = next;\n    _cellX = cellX.tl;\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction takeAux(_n, _cell, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cell = _cell;\n    var n = _n;\n    if (n === 0) {\n      return true;\n    }\n    if (!cell) {\n      return false;\n    }\n    var cell$1 = {\n      hd: cell.hd,\n      tl: /* [] */0\n    };\n    prec.tl = cell$1;\n    _prec = cell$1;\n    _cell = cell.tl;\n    _n = n - 1 | 0;\n    continue ;\n  };\n}\n\nfunction splitAtAux(_n, _cell, _prec) {\n  while(true) {\n    var prec = _prec;\n    var cell = _cell;\n    var n = _n;\n    if (n === 0) {\n      return cell;\n    }\n    if (!cell) {\n      return ;\n    }\n    var cell$1 = {\n      hd: cell.hd,\n      tl: /* [] */0\n    };\n    prec.tl = cell$1;\n    _prec = cell$1;\n    _cell = cell.tl;\n    _n = n - 1 | 0;\n    continue ;\n  };\n}\n\nfunction take(lst, n) {\n  if (n < 0) {\n    return ;\n  }\n  if (n === 0) {\n    return /* [] */0;\n  }\n  if (!lst) {\n    return ;\n  }\n  var cell = {\n    hd: lst.hd,\n    tl: /* [] */0\n  };\n  var has = takeAux(n - 1 | 0, lst.tl, cell);\n  if (has) {\n    return cell;\n  }\n  \n}\n\nfunction drop(lst, n) {\n  if (n < 0) {\n    return ;\n  } else {\n    var _l = lst;\n    var _n = n;\n    while(true) {\n      var n$1 = _n;\n      var l = _l;\n      if (n$1 === 0) {\n        return l;\n      }\n      if (!l) {\n        return ;\n      }\n      _n = n$1 - 1 | 0;\n      _l = l.tl;\n      continue ;\n    };\n  }\n}\n\nfunction splitAt(lst, n) {\n  if (n < 0) {\n    return ;\n  }\n  if (n === 0) {\n    return [\n            /* [] */0,\n            lst\n          ];\n  }\n  if (!lst) {\n    return ;\n  }\n  var cell = {\n    hd: lst.hd,\n    tl: /* [] */0\n  };\n  var rest = splitAtAux(n - 1 | 0, lst.tl, cell);\n  if (rest !== undefined) {\n    return [\n            cell,\n            rest\n          ];\n  }\n  \n}\n\nfunction concat(xs, ys) {\n  if (!xs) {\n    return ys;\n  }\n  var cell = {\n    hd: xs.hd,\n    tl: /* [] */0\n  };\n  copyAuxCont(xs.tl, cell).tl = ys;\n  return cell;\n}\n\nfunction mapU(xs, f) {\n  if (!xs) {\n    return /* [] */0;\n  }\n  var cell = {\n    hd: f(xs.hd),\n    tl: /* [] */0\n  };\n  copyAuxWithMap(xs.tl, cell, f);\n  return cell;\n}\n\nfunction map(xs, f) {\n  return mapU(xs, Curry.__1(f));\n}\n\nfunction zipByU(l1, l2, f) {\n  if (!l1) {\n    return /* [] */0;\n  }\n  if (!l2) {\n    return /* [] */0;\n  }\n  var cell = {\n    hd: f(l1.hd, l2.hd),\n    tl: /* [] */0\n  };\n  copyAuxWithMap2(f, l1.tl, l2.tl, cell);\n  return cell;\n}\n\nfunction zipBy(l1, l2, f) {\n  return zipByU(l1, l2, Curry.__2(f));\n}\n\nfunction mapWithIndexU(xs, f) {\n  if (!xs) {\n    return /* [] */0;\n  }\n  var cell = {\n    hd: f(0, xs.hd),\n    tl: /* [] */0\n  };\n  copyAuxWithMapI(f, 1, xs.tl, cell);\n  return cell;\n}\n\nfunction mapWithIndex(xs, f) {\n  return mapWithIndexU(xs, Curry.__2(f));\n}\n\nfunction makeByU(n, f) {\n  if (n <= 0) {\n    return /* [] */0;\n  }\n  var headX = {\n    hd: f(0),\n    tl: /* [] */0\n  };\n  var cur = headX;\n  var i = 1;\n  while(i < n) {\n    var v = {\n      hd: f(i),\n      tl: /* [] */0\n    };\n    cur.tl = v;\n    cur = v;\n    i = i + 1 | 0;\n  };\n  return headX;\n}\n\nfunction makeBy(n, f) {\n  return makeByU(n, Curry.__1(f));\n}\n\nfunction make(n, v) {\n  if (n <= 0) {\n    return /* [] */0;\n  }\n  var headX = {\n    hd: v,\n    tl: /* [] */0\n  };\n  var cur = headX;\n  var i = 1;\n  while(i < n) {\n    var v$1 = {\n      hd: v,\n      tl: /* [] */0\n    };\n    cur.tl = v$1;\n    cur = v$1;\n    i = i + 1 | 0;\n  };\n  return headX;\n}\n\nfunction length(xs) {\n  var _x = xs;\n  var _acc = 0;\n  while(true) {\n    var acc = _acc;\n    var x = _x;\n    if (!x) {\n      return acc;\n    }\n    _acc = acc + 1 | 0;\n    _x = x.tl;\n    continue ;\n  };\n}\n\nfunction fillAux(arr, _i, _x) {\n  while(true) {\n    var x = _x;\n    var i = _i;\n    if (!x) {\n      return ;\n    }\n    arr[i] = x.hd;\n    _x = x.tl;\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction fromArray(a) {\n  var _i = a.length - 1 | 0;\n  var _res = /* [] */0;\n  while(true) {\n    var res = _res;\n    var i = _i;\n    if (i < 0) {\n      return res;\n    }\n    _res = {\n      hd: a[i],\n      tl: res\n    };\n    _i = i - 1 | 0;\n    continue ;\n  };\n}\n\nfunction toArray(x) {\n  var len = length(x);\n  var arr = new Array(len);\n  fillAux(arr, 0, x);\n  return arr;\n}\n\nfunction shuffle(xs) {\n  var v = toArray(xs);\n  Belt_Array.shuffleInPlace(v);\n  return fromArray(v);\n}\n\nfunction reverseConcat(_l1, _l2) {\n  while(true) {\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      return l2;\n    }\n    _l2 = {\n      hd: l1.hd,\n      tl: l2\n    };\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction reverse(l) {\n  return reverseConcat(l, /* [] */0);\n}\n\nfunction flattenAux(_prec, _xs) {\n  while(true) {\n    var xs = _xs;\n    var prec = _prec;\n    if (xs) {\n      _xs = xs.tl;\n      _prec = copyAuxCont(xs.hd, prec);\n      continue ;\n    }\n    prec.tl = /* [] */0;\n    return ;\n  };\n}\n\nfunction flatten(_xs) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return /* [] */0;\n    }\n    var match = xs.hd;\n    if (match) {\n      var cell = {\n        hd: match.hd,\n        tl: /* [] */0\n      };\n      flattenAux(copyAuxCont(match.tl, cell), xs.tl);\n      return cell;\n    }\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction concatMany(xs) {\n  var len = xs.length;\n  if (len === 1) {\n    return xs[0];\n  }\n  if (len === 0) {\n    return /* [] */0;\n  }\n  var len$1 = xs.length;\n  var v = xs[len$1 - 1 | 0];\n  for(var i = len$1 - 2 | 0; i >= 0; --i){\n    v = concat(xs[i], v);\n  }\n  return v;\n}\n\nfunction mapReverseU(l, f) {\n  var _accu = /* [] */0;\n  var _xs = l;\n  while(true) {\n    var xs = _xs;\n    var accu = _accu;\n    if (!xs) {\n      return accu;\n    }\n    _xs = xs.tl;\n    _accu = {\n      hd: f(xs.hd),\n      tl: accu\n    };\n    continue ;\n  };\n}\n\nfunction mapReverse(l, f) {\n  return mapReverseU(l, Curry.__1(f));\n}\n\nfunction forEachU(_xs, f) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return ;\n    }\n    f(xs.hd);\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction forEach(xs, f) {\n  return forEachU(xs, Curry.__1(f));\n}\n\nfunction forEachWithIndexU(l, f) {\n  var _xs = l;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    var xs = _xs;\n    if (!xs) {\n      return ;\n    }\n    f(i, xs.hd);\n    _i = i + 1 | 0;\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction forEachWithIndex(l, f) {\n  return forEachWithIndexU(l, Curry.__2(f));\n}\n\nfunction reduceU(_l, _accu, f) {\n  while(true) {\n    var accu = _accu;\n    var l = _l;\n    if (!l) {\n      return accu;\n    }\n    _accu = f(accu, l.hd);\n    _l = l.tl;\n    continue ;\n  };\n}\n\nfunction reduce(l, accu, f) {\n  return reduceU(l, accu, Curry.__2(f));\n}\n\nfunction reduceReverseUnsafeU(l, accu, f) {\n  if (l) {\n    return f(reduceReverseUnsafeU(l.tl, accu, f), l.hd);\n  } else {\n    return accu;\n  }\n}\n\nfunction reduceReverseU(l, acc, f) {\n  var len = length(l);\n  if (len < 1000) {\n    return reduceReverseUnsafeU(l, acc, f);\n  } else {\n    return Belt_Array.reduceReverseU(toArray(l), acc, f);\n  }\n}\n\nfunction reduceReverse(l, accu, f) {\n  return reduceReverseU(l, accu, Curry.__2(f));\n}\n\nfunction reduceWithIndexU(l, acc, f) {\n  var _l = l;\n  var _acc = acc;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    var acc$1 = _acc;\n    var l$1 = _l;\n    if (!l$1) {\n      return acc$1;\n    }\n    _i = i + 1 | 0;\n    _acc = f(acc$1, l$1.hd, i);\n    _l = l$1.tl;\n    continue ;\n  };\n}\n\nfunction reduceWithIndex(l, acc, f) {\n  return reduceWithIndexU(l, acc, Curry.__3(f));\n}\n\nfunction mapReverse2U(l1, l2, f) {\n  var _l1 = l1;\n  var _l2 = l2;\n  var _accu = /* [] */0;\n  while(true) {\n    var accu = _accu;\n    var l2$1 = _l2;\n    var l1$1 = _l1;\n    if (!l1$1) {\n      return accu;\n    }\n    if (!l2$1) {\n      return accu;\n    }\n    _accu = {\n      hd: f(l1$1.hd, l2$1.hd),\n      tl: accu\n    };\n    _l2 = l2$1.tl;\n    _l1 = l1$1.tl;\n    continue ;\n  };\n}\n\nfunction mapReverse2(l1, l2, f) {\n  return mapReverse2U(l1, l2, Curry.__2(f));\n}\n\nfunction forEach2U(_l1, _l2, f) {\n  while(true) {\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      return ;\n    }\n    if (!l2) {\n      return ;\n    }\n    f(l1.hd, l2.hd);\n    _l2 = l2.tl;\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction forEach2(l1, l2, f) {\n  return forEach2U(l1, l2, Curry.__2(f));\n}\n\nfunction reduce2U(_l1, _l2, _accu, f) {\n  while(true) {\n    var accu = _accu;\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      return accu;\n    }\n    if (!l2) {\n      return accu;\n    }\n    _accu = f(accu, l1.hd, l2.hd);\n    _l2 = l2.tl;\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction reduce2(l1, l2, acc, f) {\n  return reduce2U(l1, l2, acc, Curry.__3(f));\n}\n\nfunction reduceReverse2UnsafeU(l1, l2, accu, f) {\n  if (l1 && l2) {\n    return f(reduceReverse2UnsafeU(l1.tl, l2.tl, accu, f), l1.hd, l2.hd);\n  } else {\n    return accu;\n  }\n}\n\nfunction reduceReverse2U(l1, l2, acc, f) {\n  var len = length(l1);\n  if (len < 1000) {\n    return reduceReverse2UnsafeU(l1, l2, acc, f);\n  } else {\n    return Belt_Array.reduceReverse2U(toArray(l1), toArray(l2), acc, f);\n  }\n}\n\nfunction reduceReverse2(l1, l2, acc, f) {\n  return reduceReverse2U(l1, l2, acc, Curry.__3(f));\n}\n\nfunction everyU(_xs, p) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return true;\n    }\n    if (!p(xs.hd)) {\n      return false;\n    }\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction every(xs, p) {\n  return everyU(xs, Curry.__1(p));\n}\n\nfunction someU(_xs, p) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return false;\n    }\n    if (p(xs.hd)) {\n      return true;\n    }\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction some(xs, p) {\n  return someU(xs, Curry.__1(p));\n}\n\nfunction every2U(_l1, _l2, p) {\n  while(true) {\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      return true;\n    }\n    if (!l2) {\n      return true;\n    }\n    if (!p(l1.hd, l2.hd)) {\n      return false;\n    }\n    _l2 = l2.tl;\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction every2(l1, l2, p) {\n  return every2U(l1, l2, Curry.__2(p));\n}\n\nfunction cmpByLength(_l1, _l2) {\n  while(true) {\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      if (l2) {\n        return -1;\n      } else {\n        return 0;\n      }\n    }\n    if (!l2) {\n      return 1;\n    }\n    _l2 = l2.tl;\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction cmpU(_l1, _l2, p) {\n  while(true) {\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      if (l2) {\n        return -1;\n      } else {\n        return 0;\n      }\n    }\n    if (!l2) {\n      return 1;\n    }\n    var c = p(l1.hd, l2.hd);\n    if (c !== 0) {\n      return c;\n    }\n    _l2 = l2.tl;\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction cmp(l1, l2, f) {\n  return cmpU(l1, l2, Curry.__2(f));\n}\n\nfunction eqU(_l1, _l2, p) {\n  while(true) {\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      if (l2) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n    if (!l2) {\n      return false;\n    }\n    if (!p(l1.hd, l2.hd)) {\n      return false;\n    }\n    _l2 = l2.tl;\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction eq(l1, l2, f) {\n  return eqU(l1, l2, Curry.__2(f));\n}\n\nfunction some2U(_l1, _l2, p) {\n  while(true) {\n    var l2 = _l2;\n    var l1 = _l1;\n    if (!l1) {\n      return false;\n    }\n    if (!l2) {\n      return false;\n    }\n    if (p(l1.hd, l2.hd)) {\n      return true;\n    }\n    _l2 = l2.tl;\n    _l1 = l1.tl;\n    continue ;\n  };\n}\n\nfunction some2(l1, l2, p) {\n  return some2U(l1, l2, Curry.__2(p));\n}\n\nfunction hasU(_xs, x, eq) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return false;\n    }\n    if (eq(xs.hd, x)) {\n      return true;\n    }\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction has(xs, x, eq) {\n  return hasU(xs, x, Curry.__2(eq));\n}\n\nfunction getAssocU(_xs, x, eq) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return ;\n    }\n    var match = xs.hd;\n    if (eq(match[0], x)) {\n      return Caml_option.some(match[1]);\n    }\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction getAssoc(xs, x, eq) {\n  return getAssocU(xs, x, Curry.__2(eq));\n}\n\nfunction hasAssocU(_xs, x, eq) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return false;\n    }\n    if (eq(xs.hd[0], x)) {\n      return true;\n    }\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction hasAssoc(xs, x, eq) {\n  return hasAssocU(xs, x, Curry.__2(eq));\n}\n\nfunction removeAssocU(xs, x, eq) {\n  if (!xs) {\n    return /* [] */0;\n  }\n  var l = xs.tl;\n  var pair = xs.hd;\n  if (eq(pair[0], x)) {\n    return l;\n  }\n  var cell = {\n    hd: pair,\n    tl: /* [] */0\n  };\n  var removed = removeAssocAuxWithMap(l, x, cell, eq);\n  if (removed) {\n    return cell;\n  } else {\n    return xs;\n  }\n}\n\nfunction removeAssoc(xs, x, eq) {\n  return removeAssocU(xs, x, Curry.__2(eq));\n}\n\nfunction setAssocU(xs, x, k, eq) {\n  if (!xs) {\n    return {\n            hd: [\n              x,\n              k\n            ],\n            tl: /* [] */0\n          };\n  }\n  var l = xs.tl;\n  var pair = xs.hd;\n  if (eq(pair[0], x)) {\n    return {\n            hd: [\n              x,\n              k\n            ],\n            tl: l\n          };\n  }\n  var cell = {\n    hd: pair,\n    tl: /* [] */0\n  };\n  var replaced = setAssocAuxWithMap(l, x, k, cell, eq);\n  if (replaced) {\n    return cell;\n  } else {\n    return {\n            hd: [\n              x,\n              k\n            ],\n            tl: xs\n          };\n  }\n}\n\nfunction setAssoc(xs, x, k, eq) {\n  return setAssocU(xs, x, k, Curry.__2(eq));\n}\n\nfunction sortU(xs, cmp) {\n  var arr = toArray(xs);\n  Belt_SortArray.stableSortInPlaceByU(arr, cmp);\n  return fromArray(arr);\n}\n\nfunction sort(xs, cmp) {\n  return sortU(xs, Curry.__2(cmp));\n}\n\nfunction getByU(_xs, p) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return ;\n    }\n    var x = xs.hd;\n    if (p(x)) {\n      return Caml_option.some(x);\n    }\n    _xs = xs.tl;\n    continue ;\n  };\n}\n\nfunction getBy(xs, p) {\n  return getByU(xs, Curry.__1(p));\n}\n\nfunction keepU(_xs, p) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return /* [] */0;\n    }\n    var t = xs.tl;\n    var h = xs.hd;\n    if (p(h)) {\n      var cell = {\n        hd: h,\n        tl: /* [] */0\n      };\n      copyAuxWitFilter(p, t, cell);\n      return cell;\n    }\n    _xs = t;\n    continue ;\n  };\n}\n\nfunction keep(xs, p) {\n  return keepU(xs, Curry.__1(p));\n}\n\nfunction keepWithIndexU(xs, p) {\n  var _xs = xs;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    var xs$1 = _xs;\n    if (!xs$1) {\n      return /* [] */0;\n    }\n    var t = xs$1.tl;\n    var h = xs$1.hd;\n    if (p(h, i)) {\n      var cell = {\n        hd: h,\n        tl: /* [] */0\n      };\n      copyAuxWithFilterIndex(p, t, cell, i + 1 | 0);\n      return cell;\n    }\n    _i = i + 1 | 0;\n    _xs = t;\n    continue ;\n  };\n}\n\nfunction keepWithIndex(xs, p) {\n  return keepWithIndexU(xs, Curry.__2(p));\n}\n\nfunction keepMapU(_xs, p) {\n  while(true) {\n    var xs = _xs;\n    if (!xs) {\n      return /* [] */0;\n    }\n    var t = xs.tl;\n    var h = p(xs.hd);\n    if (h !== undefined) {\n      var cell = {\n        hd: Caml_option.valFromOption(h),\n        tl: /* [] */0\n      };\n      copyAuxWitFilterMap(p, t, cell);\n      return cell;\n    }\n    _xs = t;\n    continue ;\n  };\n}\n\nfunction keepMap(xs, p) {\n  return keepMapU(xs, Curry.__1(p));\n}\n\nfunction partitionU(l, p) {\n  if (!l) {\n    return [\n            /* [] */0,\n            /* [] */0\n          ];\n  }\n  var h = l.hd;\n  var nextX = {\n    hd: h,\n    tl: /* [] */0\n  };\n  var nextY = {\n    hd: h,\n    tl: /* [] */0\n  };\n  var b = p(h);\n  partitionAux(p, l.tl, nextX, nextY);\n  if (b) {\n    return [\n            nextX,\n            nextY.tl\n          ];\n  } else {\n    return [\n            nextX.tl,\n            nextY\n          ];\n  }\n}\n\nfunction partition(l, p) {\n  return partitionU(l, Curry.__1(p));\n}\n\nfunction unzip(xs) {\n  if (!xs) {\n    return [\n            /* [] */0,\n            /* [] */0\n          ];\n  }\n  var match = xs.hd;\n  var cellX = {\n    hd: match[0],\n    tl: /* [] */0\n  };\n  var cellY = {\n    hd: match[1],\n    tl: /* [] */0\n  };\n  splitAux(xs.tl, cellX, cellY);\n  return [\n          cellX,\n          cellY\n        ];\n}\n\nfunction zip(l1, l2) {\n  if (!l1) {\n    return /* [] */0;\n  }\n  if (!l2) {\n    return /* [] */0;\n  }\n  var cell = {\n    hd: [\n      l1.hd,\n      l2.hd\n    ],\n    tl: /* [] */0\n  };\n  zipAux(l1.tl, l2.tl, cell);\n  return cell;\n}\n\nvar size = length;\n\nvar filter = keep;\n\nvar filterWithIndex = keepWithIndex;\n\nexport {\n  length ,\n  size ,\n  head ,\n  headExn ,\n  tail ,\n  tailExn ,\n  add ,\n  get ,\n  getExn ,\n  make ,\n  makeByU ,\n  makeBy ,\n  shuffle ,\n  drop ,\n  take ,\n  splitAt ,\n  concat ,\n  concatMany ,\n  reverseConcat ,\n  flatten ,\n  mapU ,\n  map ,\n  zip ,\n  zipByU ,\n  zipBy ,\n  mapWithIndexU ,\n  mapWithIndex ,\n  fromArray ,\n  toArray ,\n  reverse ,\n  mapReverseU ,\n  mapReverse ,\n  forEachU ,\n  forEach ,\n  forEachWithIndexU ,\n  forEachWithIndex ,\n  reduceU ,\n  reduce ,\n  reduceWithIndexU ,\n  reduceWithIndex ,\n  reduceReverseU ,\n  reduceReverse ,\n  mapReverse2U ,\n  mapReverse2 ,\n  forEach2U ,\n  forEach2 ,\n  reduce2U ,\n  reduce2 ,\n  reduceReverse2U ,\n  reduceReverse2 ,\n  everyU ,\n  every ,\n  someU ,\n  some ,\n  every2U ,\n  every2 ,\n  some2U ,\n  some2 ,\n  cmpByLength ,\n  cmpU ,\n  cmp ,\n  eqU ,\n  eq ,\n  hasU ,\n  has ,\n  getByU ,\n  getBy ,\n  keepU ,\n  keep ,\n  filter ,\n  keepWithIndexU ,\n  keepWithIndex ,\n  filterWithIndex ,\n  keepMapU ,\n  keepMap ,\n  partitionU ,\n  partition ,\n  unzip ,\n  getAssocU ,\n  getAssoc ,\n  hasAssocU ,\n  hasAssoc ,\n  removeAssocU ,\n  removeAssoc ,\n  setAssocU ,\n  setAssoc ,\n  sortU ,\n  sort ,\n  \n}\n/* No side effect */\n","// Generated by ReScript, PLEASE EDIT WITH CARE\n\nimport * as Js_dict from \"bs-platform/lib/es6/js_dict.js\";\nimport * as Belt_List from \"bs-platform/lib/es6/belt_List.js\";\n\nfunction map(param, f) {\n  return /* List */{\n          _0: f(param._0),\n          _1: Belt_List.mapU(param._1, f)\n        };\n}\n\nfunction toList(param) {\n  return {\n          hd: param._0,\n          tl: param._1\n        };\n}\n\nvar NonEmpty = {\n  map: map,\n  toList: toList\n};\n\nvar get = Js_dict.get;\n\nfunction set(x, y, data) {\n  x[y] = data;\n  \n}\n\nvar IdDict = {\n  get: get,\n  set: set\n};\n\nvar identifierChar = /^[a-zA-Z0-9_]$/;\n\nfunction isEndOfIdentifier(s) {\n  return !identifierChar.test(s);\n}\n\nvar identifierStartChar = /^[a-z_]$/;\n\nfunction isValidIdentifierStart(c) {\n  return identifierStartChar.test(c);\n}\n\nvar componentStart = /^[A-Z]$/;\n\nfunction isValidComponentStart(c) {\n  return componentStart.test(c);\n}\n\nfunction isReservedKeyword(s) {\n  switch (s) {\n    case \"false\" :\n    case \"null\" :\n    case \"true\" :\n        return true;\n    default:\n      return false;\n  }\n}\n\nvar bindingRegEx = /^[a-z_][a-zA-Z0-9_]*$/;\n\nfunction isLegalBinding(x) {\n  if (bindingRegEx.test(x)) {\n    return !isReservedKeyword(x);\n  } else {\n    return false;\n  }\n}\n\nvar RegEx = {\n  identifierChar: identifierChar,\n  isEndOfIdentifier: isEndOfIdentifier,\n  identifierStartChar: identifierStartChar,\n  isValidIdentifierStart: isValidIdentifierStart,\n  componentStart: componentStart,\n  isValidComponentStart: isValidComponentStart,\n  isReservedKeyword: isReservedKeyword,\n  bindingRegEx: bindingRegEx,\n  isLegalBinding: isLegalBinding\n};\n\nfunction toString(x) {\n  switch (x.TAG | 0) {\n    case /* String */0 :\n        return \"%} \" + x._1;\n    case /* Comment */2 :\n        return \"{*\" + x._1 + \"*}\";\n    case /* Identifier */4 :\n    case /* ComponentName */5 :\n        return x._1;\n    case /* EchoIdentifier */6 :\n    case /* EchoChildComponent */7 :\n        return \"{{ \" + x._1 + \" }}\";\n    case /* JsonString */1 :\n    case /* EchoString */8 :\n        return \"\\\"\" + x._1 + \"\\\"\";\n    case /* Number */3 :\n    case /* EchoNumber */9 :\n        return String(x._1);\n    case /* Comma */10 :\n        return \",\";\n    case /* Colon */11 :\n        return \":\";\n    case /* Slash */12 :\n        return \"/\";\n    case /* OpenBracket */13 :\n        return \"[\";\n    case /* CloseBracket */14 :\n        return \"]\";\n    case /* OpenBrace */15 :\n        return \"{\";\n    case /* CloseBrace */16 :\n        return \"}\";\n    case /* Spread */17 :\n        return \"...\";\n    case /* Block */18 :\n        return \"#\";\n    case /* Equals */19 :\n        return \"=\";\n    case /* Tilde */20 :\n        return \"~\";\n    case /* EndOfFile */21 :\n        return \"[end of file]\";\n    \n  }\n}\n\nfunction toLocation(x) {\n  return x._0;\n}\n\nvar Tokens = {\n  toString: toString,\n  toLocation: toLocation\n};\n\nfunction toString$1(x) {\n  switch (x.TAG | 0) {\n    case /* Null */0 :\n        return \"null\";\n    case /* False */1 :\n    case /* True */2 :\n        return \"boolean\";\n    case /* String */3 :\n        return \"string\";\n    case /* Number */4 :\n        return \"number\";\n    case /* Array */5 :\n    case /* ArrayWithTailBinding */6 :\n        return \"array\";\n    case /* Object */7 :\n        return \"object\";\n    case /* Binding */8 :\n        return \"binding: `\" + x._1 + \"`\";\n    \n  }\n}\n\nfunction toLocation$1(x) {\n  if (x.TAG === /* ArrayWithTailBinding */6) {\n    return x.loc;\n  } else {\n    return x._0;\n  }\n}\n\nvar Pattern_Ast = {\n  toString: toString$1,\n  toLocation: toLocation$1\n};\n\nvar Ast = {};\n\nexport {\n  NonEmpty ,\n  IdDict ,\n  RegEx ,\n  Tokens ,\n  Pattern_Ast ,\n  Ast ,\n  \n}\n/* No side effect */\n","// Generated by ReScript, PLEASE EDIT WITH CARE\n\nimport * as Caml_exceptions from \"bs-platform/lib/es6/caml_exceptions.js\";\nimport * as Acutis_Types$Acutis from \"./Acutis_Types.bs.js\";\n\nvar UnexpectedEoF = Caml_exceptions.create(\"Debug-Acutis.UnexpectedEoF\");\n\nvar UnterminatedComment = Caml_exceptions.create(\"Debug-Acutis.UnterminatedComment\");\n\nvar UnterminatedString = Caml_exceptions.create(\"Debug-Acutis.UnterminatedString\");\n\nvar IllegalIdentifier = Caml_exceptions.create(\"Debug-Acutis.IllegalIdentifier\");\n\nvar InvalidCharacter = Caml_exceptions.create(\"Debug-Acutis.InvalidCharacter\");\n\nvar UnexpectedCharacter = Caml_exceptions.create(\"Debug-Acutis.UnexpectedCharacter\");\n\nvar UnexpectedToken = Caml_exceptions.create(\"Debug-Acutis.UnexpectedToken\");\n\nvar IllegalBindingName = Caml_exceptions.create(\"Debug-Acutis.IllegalBindingName\");\n\nvar InvalidStatement = Caml_exceptions.create(\"Debug-Acutis.InvalidStatement\");\n\nvar ComponentDoesNotExist = Caml_exceptions.create(\"Debug-Acutis.ComponentDoesNotExist\");\n\nvar PatternTypeMismatch = Caml_exceptions.create(\"Debug-Acutis.PatternTypeMismatch\");\n\nvar BindingTypeMismatch = Caml_exceptions.create(\"Debug-Acutis.BindingTypeMismatch\");\n\nvar NameBoundMultipleTimes = Caml_exceptions.create(\"Debug-Acutis.NameBoundMultipleTimes\");\n\nvar NoMatchFound = Caml_exceptions.create(\"Debug-Acutis.NoMatchFound\");\n\nvar PatternNumberMismatch = Caml_exceptions.create(\"Debug-Acutis.PatternNumberMismatch\");\n\nvar BadEchoType = Caml_exceptions.create(\"Debug-Acutis.BadEchoType\");\n\nvar BindingDoesNotExist = Caml_exceptions.create(\"Debug-Acutis.BindingDoesNotExist\");\n\nvar ChildDoesNotExist = Caml_exceptions.create(\"Debug-Acutis.ChildDoesNotExist\");\n\nvar BadMapType = Caml_exceptions.create(\"Debug-Acutis.BadMapType\");\n\nvar BadInputTemplate = Caml_exceptions.create(\"Debug-Acutis.BadInputTemplate\");\n\nvar BadRenderInput = Caml_exceptions.create(\"Debug-Acutis.BadRenderInput\");\n\nfunction jsonTaggedTToString(x) {\n  if (typeof x === \"number\") {\n    switch (x) {\n      case /* JSONFalse */0 :\n      case /* JSONTrue */1 :\n          return \"boolean\";\n      case /* JSONNull */2 :\n          return \"null\";\n      \n    }\n  } else {\n    switch (x.TAG | 0) {\n      case /* JSONString */0 :\n          return \"string\";\n      case /* JSONNumber */1 :\n          return \"number\";\n      case /* JSONObject */2 :\n          return \"object\";\n      case /* JSONArray */3 :\n          return \"array\";\n      \n    }\n  }\n}\n\nfunction makeMessage(kind, text, loc, name) {\n  var loc$1 = String(loc + 1 | 0);\n  var name$1 = name !== undefined ? name : \"[no name]\";\n  return \"There\\'s a problem with template \" + name$1 + \"\\n\\n\" + kind + \" error at character \" + loc$1 + \".\\n  \" + text + \"\\n\";\n}\n\nfunction errorMessage(err) {\n  if (err.RE_EXN_ID === UnexpectedEoF) {\n    return makeMessage(\"Syntax\", \"Unexpected end of file.\", err.loc, err.name);\n  }\n  if (err.RE_EXN_ID === UnterminatedComment) {\n    return makeMessage(\"Syntax\", \"Unterminated comment.\", err.loc, err.name);\n  }\n  if (err.RE_EXN_ID === UnterminatedString) {\n    return makeMessage(\"Syntax\", \"Unterminated string.\", err.loc, err.name);\n  }\n  if (err.RE_EXN_ID === IllegalIdentifier) {\n    return makeMessage(\"Parse\", \"\\\"\" + err.identifier + \"\\\" is an illegal identifier name.\", err.loc, err.name);\n  }\n  if (err.RE_EXN_ID === InvalidCharacter) {\n    return makeMessage(\"Syntax\", \"Invalid character: \\\"\" + err.character + \"\\\".\", err.loc, err.name);\n  }\n  if (err.RE_EXN_ID === UnexpectedCharacter) {\n    var expected = err.expected;\n    var message = expected.length === 1 ? \"Expected\" : \"Expected one of\";\n    var expected$1 = expected.join(\", \");\n    return makeMessage(\"Syntax\", \"Unexpected character: \\\"\" + err.character + \"\\\".\\n\" + message + \": \\\"\" + expected$1 + \"\\\".\", err.loc, err.name);\n  }\n  if (err.RE_EXN_ID === UnexpectedToken) {\n    var token = err.token;\n    var loc = Acutis_Types$Acutis.Tokens.toLocation(token);\n    var token$1 = Acutis_Types$Acutis.Tokens.toString(token);\n    return makeMessage(\"Parse\", \"Unexpected token: \\\"\" + token$1 + \"\\\".\", loc, err.name);\n  }\n  if (err.RE_EXN_ID === IllegalBindingName) {\n    return makeMessage(\"Parse\", \"\\\"\" + err.binding + \"\\\" is a reserved name\", err.loc, err.name);\n  }\n  if (err.RE_EXN_ID === InvalidStatement) {\n    return makeMessage(\"Parse\", \"Invalid statement: \\\"\" + err.statement + \"\\\".\", err.loc, err.name);\n  }\n  if (err.RE_EXN_ID === ComponentDoesNotExist) {\n    return makeMessage(\"Parse\", \"Component \\\"\" + err.component + \"\\\" does not exist.\", err.loc, err.name);\n  }\n  if (err.RE_EXN_ID === PatternTypeMismatch) {\n    var pattern = err.pattern;\n    var data = jsonTaggedTToString(err.data);\n    var loc$1 = Acutis_Types$Acutis.Pattern_Ast.toLocation(pattern);\n    var pattern$1 = Acutis_Types$Acutis.Pattern_Ast.toString(pattern);\n    return makeMessage(\"Type\", \"This pattern is type \" + pattern$1 + \" but the data is type \" + data + \".\", loc$1, err.name);\n  }\n  if (err.RE_EXN_ID === BindingTypeMismatch) {\n    var pattern$2 = err.pattern;\n    var data$1 = jsonTaggedTToString(err.data);\n    var loc$2 = Acutis_Types$Acutis.Pattern_Ast.toLocation(pattern$2);\n    var pattern$3 = Acutis_Types$Acutis.Pattern_Ast.toString(pattern$2);\n    return makeMessage(\"Pattern\", \"Type mismatch: \\\"\" + err.binding + \"\\\" is type \" + pattern$3 + \" but the data is type \" + data$1 + \".\", loc$2, err.name);\n  }\n  if (err.RE_EXN_ID === NameBoundMultipleTimes) {\n    return makeMessage(\"Pattern matching\", \"\\\"\" + err.binding + \"\\\" is bound multiple times in this pattern.\", err.loc, err.name);\n  }\n  if (err.RE_EXN_ID === NoMatchFound) {\n    return makeMessage(\"Pattern matching\", \"None of the patterns match the data. Consider a catch-all case to avoid this.\", err.loc, err.name);\n  }\n  if (err.RE_EXN_ID === PatternNumberMismatch) {\n    return makeMessage(\"Pattern Matching\", \"The number of patterns does not match the number of data.\", err.loc, err.name);\n  }\n  if (err.RE_EXN_ID === BadEchoType) {\n    var type_ = jsonTaggedTToString(err.type_);\n    return makeMessage(\"Render\", \"\\\"\" + err.binding + \"\\\" is a \" + type_ + \". I can only echo strings and numbers.\", err.loc, err.name);\n  }\n  if (err.RE_EXN_ID === BindingDoesNotExist) {\n    return makeMessage(\"Render\", \"Binding \\\"\" + err.binding + \"\\\" does not exist.\", err.loc, err.name);\n  }\n  if (err.RE_EXN_ID === ChildDoesNotExist) {\n    return makeMessage(\"Render\", \"Template child \\\"\" + err.child + \"\\\" does not exist.\", err.loc, err.name);\n  }\n  if (err.RE_EXN_ID === BadMapType) {\n    var type_$1 = jsonTaggedTToString(err.type_);\n    return makeMessage(\"Type\", \"\\\"\" + err.binding + \"\\\" is a \" + type_$1 + \". I can only map arrays.\", err.loc, err.name);\n  }\n  if (err.RE_EXN_ID === BadInputTemplate) {\n    return \"Input template is type \" + err._1 + \" but must be type string.\";\n  }\n  if (err.RE_EXN_ID === BadRenderInput) {\n    return \"The render function didn\\'t receive an AST. Did you forget to compile the source first?\";\n  }\n  var e = String(err);\n  return \"An unexpected error occured in a template. This is probably due to malformed input.\\n\\n\" + e;\n}\n\nexport {\n  UnexpectedEoF ,\n  UnterminatedComment ,\n  UnterminatedString ,\n  IllegalIdentifier ,\n  InvalidCharacter ,\n  UnexpectedCharacter ,\n  UnexpectedToken ,\n  IllegalBindingName ,\n  InvalidStatement ,\n  ComponentDoesNotExist ,\n  PatternTypeMismatch ,\n  BindingTypeMismatch ,\n  NameBoundMultipleTimes ,\n  NoMatchFound ,\n  PatternNumberMismatch ,\n  BadEchoType ,\n  BindingDoesNotExist ,\n  ChildDoesNotExist ,\n  BadMapType ,\n  BadInputTemplate ,\n  BadRenderInput ,\n  errorMessage ,\n  \n}\n/* No side effect */\n","\n\nimport * as Caml_option from \"./caml_option.js\";\n\nfunction classify(x) {\n  var ty = typeof x;\n  if (ty === \"string\") {\n    return {\n            TAG: /* JSONString */0,\n            _0: x\n          };\n  } else if (ty === \"number\") {\n    return {\n            TAG: /* JSONNumber */1,\n            _0: x\n          };\n  } else if (ty === \"boolean\") {\n    if (x === true) {\n      return /* JSONTrue */1;\n    } else {\n      return /* JSONFalse */0;\n    }\n  } else if (x === null) {\n    return /* JSONNull */2;\n  } else if (Array.isArray(x)) {\n    return {\n            TAG: /* JSONArray */3,\n            _0: x\n          };\n  } else {\n    return {\n            TAG: /* JSONObject */2,\n            _0: x\n          };\n  }\n}\n\nfunction test(x, v) {\n  switch (v) {\n    case /* String */0 :\n        return typeof x === \"string\";\n    case /* Number */1 :\n        return typeof x === \"number\";\n    case /* Object */2 :\n        if (x !== null && typeof x === \"object\") {\n          return !Array.isArray(x);\n        } else {\n          return false;\n        }\n    case /* Array */3 :\n        return Array.isArray(x);\n    case /* Boolean */4 :\n        return typeof x === \"boolean\";\n    case /* Null */5 :\n        return x === null;\n    \n  }\n}\n\nfunction decodeString(json) {\n  if (typeof json === \"string\") {\n    return json;\n  }\n  \n}\n\nfunction decodeNumber(json) {\n  if (typeof json === \"number\") {\n    return json;\n  }\n  \n}\n\nfunction decodeObject(json) {\n  if (typeof json === \"object\" && !Array.isArray(json) && json !== null) {\n    return Caml_option.some(json);\n  }\n  \n}\n\nfunction decodeArray(json) {\n  if (Array.isArray(json)) {\n    return json;\n  }\n  \n}\n\nfunction decodeBoolean(json) {\n  if (typeof json === \"boolean\") {\n    return json;\n  }\n  \n}\n\nfunction decodeNull(json) {\n  if (json === null) {\n    return null;\n  }\n  \n}\n\nvar patch = (function (json) {\n  var x = [json];\n  var q = [{ kind: 0, i: 0, parent: x }];\n  while (q.length !== 0) {\n    // begin pop the stack\n    var cur = q[q.length - 1];\n    if (cur.kind === 0) {\n      cur.val = cur.parent[cur.i]; // patch the undefined value for array\n      if (++cur.i === cur.parent.length) {\n        q.pop();\n      }\n    } else {\n      q.pop();\n    }\n    // finish\n    var task = cur.val;\n    if (typeof task === \"object\") {\n      if (Array.isArray(task) && task.length !== 0) {\n        q.push({ kind: 0, i: 0, parent: task, val: undefined });\n      } else {\n        for (var k in task) {\n          if (k === \"RE_PRIVATE_NONE\") {\n            if (cur.kind === 0) {\n              cur.parent[cur.i - 1] = undefined;\n            } else {\n              cur.parent[cur.i] = undefined;\n            }\n            continue;\n          }\n          q.push({ kind: 1, i: k, parent: task, val: task[k] });\n        }\n      }\n    }\n  }\n  return x[0];\n});\n\nfunction serializeExn(x) {\n  return (function(obj){\n  var output= JSON.stringify(obj,function(_,value){\n      if(value===undefined){\n          return {RE_PRIVATE_NONE : true}\n      }\n    return value\n  });\n  \n if(output === undefined){\n   // JSON.stringify will raise TypeError when it detects cylic objects\n   throw new TypeError(\"output is undefined\")\n }\n return output \n })(x);\n}\n\nfunction deserializeUnsafe(s) {\n  return patch(JSON.parse(s));\n}\n\nexport {\n  classify ,\n  test ,\n  decodeString ,\n  decodeNumber ,\n  decodeObject ,\n  decodeArray ,\n  decodeBoolean ,\n  decodeNull ,\n  deserializeUnsafe ,\n  serializeExn ,\n  \n}\n/* No side effect */\n","\n\nimport * as Curry from \"./curry.js\";\n\nfunction getExn(x) {\n  if (!x.TAG) {\n    return x._0;\n  }\n  throw {\n        RE_EXN_ID: \"Not_found\",\n        Error: new Error()\n      };\n}\n\nfunction mapWithDefaultU(opt, $$default, f) {\n  if (opt.TAG) {\n    return $$default;\n  } else {\n    return f(opt._0);\n  }\n}\n\nfunction mapWithDefault(opt, $$default, f) {\n  return mapWithDefaultU(opt, $$default, Curry.__1(f));\n}\n\nfunction mapU(opt, f) {\n  if (opt.TAG) {\n    return {\n            TAG: /* Error */1,\n            _0: opt._0\n          };\n  } else {\n    return {\n            TAG: /* Ok */0,\n            _0: f(opt._0)\n          };\n  }\n}\n\nfunction map(opt, f) {\n  return mapU(opt, Curry.__1(f));\n}\n\nfunction flatMapU(opt, f) {\n  if (opt.TAG) {\n    return {\n            TAG: /* Error */1,\n            _0: opt._0\n          };\n  } else {\n    return f(opt._0);\n  }\n}\n\nfunction flatMap(opt, f) {\n  return flatMapU(opt, Curry.__1(f));\n}\n\nfunction getWithDefault(opt, $$default) {\n  if (opt.TAG) {\n    return $$default;\n  } else {\n    return opt._0;\n  }\n}\n\nfunction isOk(param) {\n  if (param.TAG) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nfunction isError(param) {\n  if (param.TAG) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction eqU(a, b, f) {\n  if (a.TAG) {\n    if (b.TAG) {\n      return true;\n    } else {\n      return false;\n    }\n  } else if (b.TAG) {\n    return false;\n  } else {\n    return f(a._0, b._0);\n  }\n}\n\nfunction eq(a, b, f) {\n  return eqU(a, b, Curry.__2(f));\n}\n\nfunction cmpU(a, b, f) {\n  if (a.TAG) {\n    if (b.TAG) {\n      return 0;\n    } else {\n      return -1;\n    }\n  } else if (b.TAG) {\n    return 1;\n  } else {\n    return f(a._0, b._0);\n  }\n}\n\nfunction cmp(a, b, f) {\n  return cmpU(a, b, Curry.__2(f));\n}\n\nexport {\n  getExn ,\n  mapWithDefaultU ,\n  mapWithDefault ,\n  mapU ,\n  map ,\n  flatMapU ,\n  flatMap ,\n  getWithDefault ,\n  isOk ,\n  isError ,\n  eqU ,\n  eq ,\n  cmpU ,\n  cmp ,\n  \n}\n/* No side effect */\n","\n\nimport * as Curry from \"./curry.js\";\nimport * as Caml_option from \"./caml_option.js\";\n\nfunction make(param) {\n  return {\n          length: 0,\n          first: undefined,\n          last: undefined\n        };\n}\n\nfunction clear(q) {\n  q.length = 0;\n  q.first = undefined;\n  q.last = undefined;\n  \n}\n\nfunction add(q, x) {\n  var cell = {\n    content: x,\n    next: undefined\n  };\n  var last = q.last;\n  if (last !== undefined) {\n    q.length = q.length + 1 | 0;\n    last.next = cell;\n    q.last = cell;\n  } else {\n    q.length = 1;\n    q.first = cell;\n    q.last = cell;\n  }\n  \n}\n\nfunction peek(q) {\n  var v = q.first;\n  if (v !== undefined) {\n    return Caml_option.some(v.content);\n  }\n  \n}\n\nfunction peekUndefined(q) {\n  var v = q.first;\n  if (v !== undefined) {\n    return v.content;\n  }\n  \n}\n\nfunction peekExn(q) {\n  var v = q.first;\n  if (v !== undefined) {\n    return v.content;\n  }\n  throw {\n        RE_EXN_ID: \"Not_found\",\n        Error: new Error()\n      };\n}\n\nfunction pop(q) {\n  var x = q.first;\n  if (x === undefined) {\n    return ;\n  }\n  var next = x.next;\n  if (next === undefined) {\n    clear(q);\n    return Caml_option.some(x.content);\n  } else {\n    q.length = q.length - 1 | 0;\n    q.first = next;\n    return Caml_option.some(x.content);\n  }\n}\n\nfunction popExn(q) {\n  var x = q.first;\n  if (x !== undefined) {\n    var next = x.next;\n    if (next === undefined) {\n      clear(q);\n      return x.content;\n    } else {\n      q.length = q.length - 1 | 0;\n      q.first = next;\n      return x.content;\n    }\n  }\n  throw {\n        RE_EXN_ID: \"Not_found\",\n        Error: new Error()\n      };\n}\n\nfunction popUndefined(q) {\n  var x = q.first;\n  if (x === undefined) {\n    return ;\n  }\n  var next = x.next;\n  if (next === undefined) {\n    clear(q);\n    return x.content;\n  } else {\n    q.length = q.length - 1 | 0;\n    q.first = next;\n    return x.content;\n  }\n}\n\nfunction copy(q) {\n  var qRes = {\n    length: q.length,\n    first: undefined,\n    last: undefined\n  };\n  var _prev;\n  var _cell = q.first;\n  while(true) {\n    var cell = _cell;\n    var prev = _prev;\n    if (cell !== undefined) {\n      var content = cell.content;\n      var res = {\n        content: content,\n        next: undefined\n      };\n      if (prev !== undefined) {\n        prev.next = res;\n      } else {\n        qRes.first = res;\n      }\n      _cell = cell.next;\n      _prev = res;\n      continue ;\n    }\n    qRes.last = prev;\n    return qRes;\n  };\n}\n\nfunction mapU(q, f) {\n  var qRes = {\n    length: q.length,\n    first: undefined,\n    last: undefined\n  };\n  var _prev;\n  var _cell = q.first;\n  while(true) {\n    var cell = _cell;\n    var prev = _prev;\n    if (cell !== undefined) {\n      var content = f(cell.content);\n      var res = {\n        content: content,\n        next: undefined\n      };\n      if (prev !== undefined) {\n        prev.next = res;\n      } else {\n        qRes.first = res;\n      }\n      _cell = cell.next;\n      _prev = res;\n      continue ;\n    }\n    qRes.last = prev;\n    return qRes;\n  };\n}\n\nfunction map(q, f) {\n  return mapU(q, Curry.__1(f));\n}\n\nfunction isEmpty(q) {\n  return q.length === 0;\n}\n\nfunction size(q) {\n  return q.length;\n}\n\nfunction forEachU(q, f) {\n  var _cell = q.first;\n  while(true) {\n    var cell = _cell;\n    if (cell === undefined) {\n      return ;\n    }\n    f(cell.content);\n    _cell = cell.next;\n    continue ;\n  };\n}\n\nfunction forEach(q, f) {\n  return forEachU(q, Curry.__1(f));\n}\n\nfunction reduceU(q, accu, f) {\n  var _accu = accu;\n  var _cell = q.first;\n  while(true) {\n    var cell = _cell;\n    var accu$1 = _accu;\n    if (cell === undefined) {\n      return accu$1;\n    }\n    var accu$2 = f(accu$1, cell.content);\n    _cell = cell.next;\n    _accu = accu$2;\n    continue ;\n  };\n}\n\nfunction reduce(q, accu, f) {\n  return reduceU(q, accu, Curry.__2(f));\n}\n\nfunction transfer(q1, q2) {\n  if (q1.length <= 0) {\n    return ;\n  }\n  var l = q2.last;\n  if (l !== undefined) {\n    q2.length = q2.length + q1.length | 0;\n    l.next = q1.first;\n    q2.last = q1.last;\n    return clear(q1);\n  } else {\n    q2.length = q1.length;\n    q2.first = q1.first;\n    q2.last = q1.last;\n    return clear(q1);\n  }\n}\n\nfunction fillAux(_i, arr, _cell) {\n  while(true) {\n    var cell = _cell;\n    var i = _i;\n    if (cell === undefined) {\n      return ;\n    }\n    arr[i] = cell.content;\n    _cell = cell.next;\n    _i = i + 1 | 0;\n    continue ;\n  };\n}\n\nfunction toArray(x) {\n  var v = new Array(x.length);\n  fillAux(0, v, x.first);\n  return v;\n}\n\nfunction fromArray(arr) {\n  var q = {\n    length: 0,\n    first: undefined,\n    last: undefined\n  };\n  for(var i = 0 ,i_finish = arr.length; i < i_finish; ++i){\n    add(q, arr[i]);\n  }\n  return q;\n}\n\nexport {\n  make ,\n  clear ,\n  isEmpty ,\n  fromArray ,\n  add ,\n  peek ,\n  peekUndefined ,\n  peekExn ,\n  pop ,\n  popUndefined ,\n  popExn ,\n  copy ,\n  size ,\n  mapU ,\n  map ,\n  forEachU ,\n  forEach ,\n  reduceU ,\n  reduce ,\n  transfer ,\n  toArray ,\n  \n}\n/* No side effect */\n","\n\nimport * as Caml_option from \"./caml_option.js\";\nimport * as Caml_exceptions from \"./caml_exceptions.js\";\n\nvar $$Error = Caml_exceptions.create(\"Caml_js_exceptions.Error\");\n\nfunction internalToOCamlException(e) {\n  if (Caml_exceptions.caml_is_extension(e)) {\n    return e;\n  } else {\n    return {\n            RE_EXN_ID: $$Error,\n            _1: e\n          };\n  }\n}\n\nfunction caml_as_js_exn(exn) {\n  if (exn.RE_EXN_ID === $$Error) {\n    return Caml_option.some(exn._1);\n  }\n  \n}\n\nexport {\n  $$Error ,\n  internalToOCamlException ,\n  caml_as_js_exn ,\n  \n}\n/* No side effect */\n","// Generated by ReScript, PLEASE EDIT WITH CARE\n\nimport * as Js_dict from \"bs-platform/lib/es6/js_dict.js\";\nimport * as Js_json from \"bs-platform/lib/es6/js_json.js\";\nimport * as Belt_List from \"bs-platform/lib/es6/belt_List.js\";\nimport * as Belt_Array from \"bs-platform/lib/es6/belt_Array.js\";\nimport * as Belt_Option from \"bs-platform/lib/es6/belt_Option.js\";\nimport * as Belt_Result from \"bs-platform/lib/es6/belt_Result.js\";\nimport * as Caml_option from \"bs-platform/lib/es6/caml_option.js\";\nimport * as Debug$Acutis from \"./Debug.bs.js\";\nimport * as Belt_MutableQueue from \"bs-platform/lib/es6/belt_MutableQueue.js\";\nimport * as Caml_js_exceptions from \"bs-platform/lib/es6/caml_js_exceptions.js\";\nimport * as Acutis_Types$Acutis from \"./Acutis_Types.bs.js\";\n\nfunction listToArrayResult(l) {\n  var q = Belt_MutableQueue.make(undefined);\n  var _l = l;\n  while(true) {\n    var l$1 = _l;\n    if (!l$1) {\n      return {\n              TAG: /* Ok */0,\n              _0: Belt_MutableQueue.toArray(q)\n            };\n    }\n    var e = l$1.hd;\n    if (e.TAG) {\n      return e;\n    }\n    Belt_MutableQueue.add(q, e._0);\n    _l = l$1.tl;\n    continue ;\n  };\n}\n\nfunction toJson(pattern, props) {\n  switch (pattern.TAG | 0) {\n    case /* Null */0 :\n        return {\n                TAG: /* Ok */0,\n                _0: null\n              };\n    case /* False */1 :\n        return {\n                TAG: /* Ok */0,\n                _0: false\n              };\n    case /* True */2 :\n        return {\n                TAG: /* Ok */0,\n                _0: true\n              };\n    case /* String */3 :\n    case /* Number */4 :\n        return {\n                TAG: /* Ok */0,\n                _0: pattern._1\n              };\n    case /* Array */5 :\n        return Belt_Result.mapU(listToArrayResult(Belt_List.mapU(pattern._1, (function (x) {\n                              return toJson(x, props);\n                            }))), (function (x) {\n                      return x;\n                    }));\n    case /* ArrayWithTailBinding */6 :\n        var binding = pattern.binding;\n        var data = Belt_Option.mapU(Acutis_Types$Acutis.IdDict.get(props, binding), Js_json.classify);\n        if (data === undefined) {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* BindingDoesNotExistErr */1,\n                    loc: pattern.bindLoc,\n                    binding: binding\n                  }\n                };\n        }\n        if (typeof data === \"number\") {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* BindingTypeMismatchErr */0,\n                    data: data,\n                    pattern: pattern,\n                    binding: binding\n                  }\n                };\n        }\n        if (data.TAG !== /* JSONArray */3) {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* BindingTypeMismatchErr */0,\n                    data: data,\n                    pattern: pattern,\n                    binding: binding\n                  }\n                };\n        }\n        var tailBinding = data._0;\n        return Belt_Result.mapU(listToArrayResult(Belt_List.mapU(pattern.array, (function (x) {\n                              return toJson(x, props);\n                            }))), (function (x) {\n                      return Belt_Array.concat(x, tailBinding);\n                    }));\n    case /* Object */7 :\n        return Belt_Result.mapU(listToArrayResult(Belt_List.mapU(pattern._1, (function (param) {\n                              var v = toJson(param[1], props);\n                              if (v.TAG) {\n                                return v;\n                              } else {\n                                return {\n                                        TAG: /* Ok */0,\n                                        _0: [\n                                          param[0],\n                                          v._0\n                                        ]\n                                      };\n                              }\n                            }))), Js_dict.fromArray);\n    case /* Binding */8 :\n        var x = pattern._1;\n        var x$1 = Acutis_Types$Acutis.IdDict.get(props, x);\n        if (x$1 !== undefined) {\n          return {\n                  TAG: /* Ok */0,\n                  _0: Caml_option.valFromOption(x$1)\n                };\n        } else {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* BindingDoesNotExistErr */1,\n                    loc: pattern._0,\n                    binding: x\n                  }\n                };\n        }\n    \n  }\n}\n\nfunction setBinding(bindings, identifier, json, loc) {\n  if (identifier === \"_\") {\n    return {\n            TAG: /* Ok */0,\n            _0: bindings\n          };\n  }\n  var match = Acutis_Types$Acutis.IdDict.get(bindings, identifier);\n  if (match !== undefined) {\n    return {\n            TAG: /* Error */1,\n            _0: {\n              TAG: /* TooManyBindings */1,\n              loc: loc,\n              binding: identifier\n            }\n          };\n  } else {\n    Acutis_Types$Acutis.IdDict.set(bindings, identifier, json);\n    return {\n            TAG: /* Ok */0,\n            _0: bindings\n          };\n  }\n}\n\nfunction testValue(pattern, json, bindings) {\n  var match = Js_json.classify(json);\n  switch (pattern.TAG | 0) {\n    case /* Null */0 :\n        if (typeof match === \"number\" && match >= 2) {\n          return {\n                  TAG: /* Ok */0,\n                  _0: bindings\n                };\n        } else {\n          return {\n                  TAG: /* Error */1,\n                  _0: /* NoMatch */0\n                };\n        }\n    case /* False */1 :\n        if (typeof match !== \"number\") {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* PatternTypeMismatch */0,\n                    data: match,\n                    pattern: pattern\n                  }\n                };\n        }\n        switch (match) {\n          case /* JSONFalse */0 :\n              return {\n                      TAG: /* Ok */0,\n                      _0: bindings\n                    };\n          case /* JSONTrue */1 :\n          case /* JSONNull */2 :\n              return {\n                      TAG: /* Error */1,\n                      _0: /* NoMatch */0\n                    };\n          \n        }\n    case /* True */2 :\n        if (typeof match !== \"number\") {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* PatternTypeMismatch */0,\n                    data: match,\n                    pattern: pattern\n                  }\n                };\n        }\n        switch (match) {\n          case /* JSONTrue */1 :\n              return {\n                      TAG: /* Ok */0,\n                      _0: bindings\n                    };\n          case /* JSONFalse */0 :\n          case /* JSONNull */2 :\n              return {\n                      TAG: /* Error */1,\n                      _0: /* NoMatch */0\n                    };\n          \n        }\n    case /* String */3 :\n        if (typeof match === \"number\") {\n          if (match === /* JSONNull */2) {\n            return {\n                    TAG: /* Error */1,\n                    _0: /* NoMatch */0\n                  };\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: {\n                      TAG: /* PatternTypeMismatch */0,\n                      data: match,\n                      pattern: pattern\n                    }\n                  };\n          }\n        } else if (match.TAG) {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* PatternTypeMismatch */0,\n                    data: match,\n                    pattern: pattern\n                  }\n                };\n        } else if (pattern._1 === match._0) {\n          return {\n                  TAG: /* Ok */0,\n                  _0: bindings\n                };\n        } else {\n          return {\n                  TAG: /* Error */1,\n                  _0: /* NoMatch */0\n                };\n        }\n    case /* Number */4 :\n        if (typeof match === \"number\") {\n          if (match === /* JSONNull */2) {\n            return {\n                    TAG: /* Error */1,\n                    _0: /* NoMatch */0\n                  };\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: {\n                      TAG: /* PatternTypeMismatch */0,\n                      data: match,\n                      pattern: pattern\n                    }\n                  };\n          }\n        } else if (match.TAG === /* JSONNumber */1) {\n          if (pattern._1 === match._0) {\n            return {\n                    TAG: /* Ok */0,\n                    _0: bindings\n                  };\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: /* NoMatch */0\n                  };\n          }\n        } else {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* PatternTypeMismatch */0,\n                    data: match,\n                    pattern: pattern\n                  }\n                };\n        }\n    case /* Array */5 :\n        var x = pattern._1;\n        if (x) {\n          if (typeof match === \"number\") {\n            if (match === /* JSONNull */2) {\n              return {\n                      TAG: /* Error */1,\n                      _0: /* NoMatch */0\n                    };\n            } else {\n              return {\n                      TAG: /* Error */1,\n                      _0: {\n                        TAG: /* PatternTypeMismatch */0,\n                        data: match,\n                        pattern: pattern\n                      }\n                    };\n            }\n          } else if (match.TAG === /* JSONArray */3) {\n            return testArray(x, match._0, bindings, undefined);\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: {\n                      TAG: /* PatternTypeMismatch */0,\n                      data: match,\n                      pattern: pattern\n                    }\n                  };\n          }\n        } else if (typeof match === \"number\") {\n          if (match === /* JSONNull */2) {\n            return {\n                    TAG: /* Error */1,\n                    _0: /* NoMatch */0\n                  };\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: {\n                      TAG: /* PatternTypeMismatch */0,\n                      data: match,\n                      pattern: pattern\n                    }\n                  };\n          }\n        } else if (match.TAG === /* JSONArray */3) {\n          if (match._0.length === 0) {\n            return {\n                    TAG: /* Ok */0,\n                    _0: bindings\n                  };\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: /* NoMatch */0\n                  };\n          }\n        } else {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* PatternTypeMismatch */0,\n                    data: match,\n                    pattern: pattern\n                  }\n                };\n        }\n    case /* ArrayWithTailBinding */6 :\n        if (typeof match === \"number\") {\n          if (match === /* JSONNull */2) {\n            return {\n                    TAG: /* Error */1,\n                    _0: /* NoMatch */0\n                  };\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: {\n                      TAG: /* PatternTypeMismatch */0,\n                      data: match,\n                      pattern: pattern\n                    }\n                  };\n          }\n        } else if (match.TAG === /* JSONArray */3) {\n          return testArray(pattern.array, match._0, bindings, [\n                      pattern.bindLoc,\n                      pattern.binding\n                    ]);\n        } else {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* PatternTypeMismatch */0,\n                    data: match,\n                    pattern: pattern\n                  }\n                };\n        }\n    case /* Object */7 :\n        var x$1 = pattern._1;\n        if (x$1) {\n          if (typeof match === \"number\") {\n            if (match === /* JSONNull */2) {\n              return {\n                      TAG: /* Error */1,\n                      _0: /* NoMatch */0\n                    };\n            } else {\n              return {\n                      TAG: /* Error */1,\n                      _0: {\n                        TAG: /* PatternTypeMismatch */0,\n                        data: match,\n                        pattern: pattern\n                      }\n                    };\n            }\n          } else if (match.TAG === /* JSONObject */2) {\n            var _patterns = x$1;\n            var obj = match._0;\n            while(true) {\n              var patterns = _patterns;\n              if (!patterns) {\n                return {\n                        TAG: /* Ok */0,\n                        _0: bindings\n                      };\n              }\n              var match$1 = patterns.hd;\n              var json$1 = Js_dict.get(obj, match$1[0]);\n              if (json$1 === undefined) {\n                return {\n                        TAG: /* Error */1,\n                        _0: /* NoMatch */0\n                      };\n              }\n              var x$2 = testValue(match$1[1], Caml_option.valFromOption(json$1), bindings);\n              if (x$2.TAG) {\n                return x$2;\n              }\n              _patterns = patterns.tl;\n              continue ;\n            };\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: {\n                      TAG: /* PatternTypeMismatch */0,\n                      data: match,\n                      pattern: pattern\n                    }\n                  };\n          }\n        } else if (typeof match === \"number\") {\n          if (match === /* JSONNull */2) {\n            return {\n                    TAG: /* Error */1,\n                    _0: /* NoMatch */0\n                  };\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: {\n                      TAG: /* PatternTypeMismatch */0,\n                      data: match,\n                      pattern: pattern\n                    }\n                  };\n          }\n        } else if (match.TAG === /* JSONObject */2) {\n          if (Object.keys(match._0).length === 0) {\n            return {\n                    TAG: /* Ok */0,\n                    _0: bindings\n                  };\n          } else {\n            return {\n                    TAG: /* Error */1,\n                    _0: /* NoMatch */0\n                  };\n          }\n        } else {\n          return {\n                  TAG: /* Error */1,\n                  _0: {\n                    TAG: /* PatternTypeMismatch */0,\n                    data: match,\n                    pattern: pattern\n                  }\n                };\n        }\n    case /* Binding */8 :\n        return setBinding(bindings, pattern._1, json, pattern._0);\n    \n  }\n}\n\nfunction testArray(patterns, arr, bindings, tailBinding) {\n  var _patterns = patterns;\n  var _index = 0;\n  while(true) {\n    var index = _index;\n    var patterns$1 = _patterns;\n    if (!patterns$1) {\n      if (tailBinding !== undefined) {\n        return setBinding(bindings, tailBinding[1], Belt_Array.sliceToEnd(arr, index), tailBinding[0]);\n      } else {\n        return {\n                TAG: /* Ok */0,\n                _0: bindings\n              };\n      }\n    }\n    var json = Belt_Array.get(arr, index);\n    if (json === undefined) {\n      return {\n              TAG: /* Error */1,\n              _0: /* NoMatch */0\n            };\n    }\n    var x = testValue(patterns$1.hd, Caml_option.valFromOption(json), bindings);\n    if (x.TAG) {\n      return x;\n    }\n    _index = index + 1 | 0;\n    _patterns = patterns$1.tl;\n    continue ;\n  };\n}\n\nfunction test(patternSequence, jsonSequence) {\n  var bindings = {};\n  var _patternSequence = Acutis_Types$Acutis.NonEmpty.toList(patternSequence);\n  var _jsonSequence = Acutis_Types$Acutis.NonEmpty.toList(jsonSequence);\n  while(true) {\n    var jsonSequence$1 = _jsonSequence;\n    var patternSequence$1 = _patternSequence;\n    if (!patternSequence$1) {\n      if (jsonSequence$1) {\n        return {\n                TAG: /* Error */1,\n                _0: /* PatternNumberMismatch */1\n              };\n      } else {\n        return {\n                TAG: /* Ok */0,\n                _0: bindings\n              };\n      }\n    }\n    if (!jsonSequence$1) {\n      return {\n              TAG: /* Error */1,\n              _0: /* PatternNumberMismatch */1\n            };\n    }\n    var x = testValue(patternSequence$1.hd, jsonSequence$1.hd, bindings);\n    if (x.TAG) {\n      return x;\n    }\n    _jsonSequence = jsonSequence$1.tl;\n    _patternSequence = patternSequence$1.tl;\n    continue ;\n  };\n}\n\nfunction matchCase(param, jsonSequence) {\n  var f = param.f;\n  var _l = Acutis_Types$Acutis.NonEmpty.toList(param.patterns);\n  while(true) {\n    var l = _l;\n    if (!l) {\n      return {\n              TAG: /* Error */1,\n              _0: /* NoMatch */0\n            };\n    }\n    var bindings = test(l.hd, jsonSequence);\n    if (!bindings.TAG) {\n      return {\n              TAG: /* Ok */0,\n              _0: f(bindings._0)\n            };\n    }\n    var match = bindings._0;\n    if (typeof match !== \"number\") {\n      return bindings;\n    }\n    if (match !== 0) {\n      return bindings;\n    }\n    _l = l.tl;\n    continue ;\n  };\n}\n\nfunction match(patterns, data) {\n  var _l = Acutis_Types$Acutis.NonEmpty.toList(patterns);\n  while(true) {\n    var l = _l;\n    if (!l) {\n      return {\n              TAG: /* Error */1,\n              _0: /* NoMatch */0\n            };\n    }\n    var x = matchCase(l.hd, data);\n    if (!x.TAG) {\n      return x;\n    }\n    var match$1 = x._0;\n    if (typeof match$1 !== \"number\") {\n      return x;\n    }\n    if (match$1 !== 0) {\n      return x;\n    }\n    _l = l.tl;\n    continue ;\n  };\n}\n\nfunction $$escape(str) {\n  var _index = 0;\n  var _result = \"\";\n  while(true) {\n    var result = _result;\n    var index = _index;\n    var c = str.charAt(index);\n    switch (c) {\n      case \"\" :\n          return result;\n      case \"\\\"\" :\n          _result = result + \"&quot;\";\n          _index = index + 1 | 0;\n          continue ;\n      case \"&\" :\n          _result = result + \"&amp;\";\n          _index = index + 1 | 0;\n          continue ;\n      case \"'\" :\n          _result = result + \"&apos;\";\n          _index = index + 1 | 0;\n          continue ;\n      case \"/\" :\n          _result = result + \"&#x2F;\";\n          _index = index + 1 | 0;\n          continue ;\n      case \"<\" :\n          _result = result + \"&lt;\";\n          _index = index + 1 | 0;\n          continue ;\n      case \"=\" :\n          _result = result + \"&#x3D;\";\n          _index = index + 1 | 0;\n          continue ;\n      case \">\" :\n          _result = result + \"&gt;\";\n          _index = index + 1 | 0;\n          continue ;\n      case \"`\" :\n          _result = result + \"&#x60;\";\n          _index = index + 1 | 0;\n          continue ;\n      default:\n        _result = result + c;\n        _index = index + 1 | 0;\n        continue ;\n    }\n  };\n}\n\nfunction getBindingOrNull(props, key) {\n  var x = Acutis_Types$Acutis.IdDict.get(props, key);\n  if (x !== undefined) {\n    return Caml_option.valFromOption(x);\n  } else {\n    return null;\n  }\n}\n\nfunction echoBinding(props, binding) {\n  var x = Js_json.classify(getBindingOrNull(props, binding));\n  if (typeof x === \"number\") {\n    return {\n            TAG: /* Error */1,\n            _0: x\n          };\n  }\n  switch (x.TAG | 0) {\n    case /* JSONString */0 :\n        return {\n                TAG: /* Ok */0,\n                _0: x._0\n              };\n    case /* JSONNumber */1 :\n        return {\n                TAG: /* Ok */0,\n                _0: String(x._0)\n              };\n    default:\n      return {\n              TAG: /* Error */1,\n              _0: x\n            };\n  }\n}\n\nfunction addImplicitIndexBinding(loc) {\n  return function (x) {\n    if (x._1) {\n      return x;\n    } else {\n      return /* List */{\n              _0: x._0,\n              _1: {\n                hd: {\n                  TAG: /* Binding */8,\n                  _0: loc,\n                  _1: \"_\"\n                },\n                tl: /* [] */0\n              }\n            };\n    }\n  };\n}\n\nfunction match$1(patterns, json, loc, name) {\n  var x = match(patterns, json);\n  if (!x.TAG) {\n    return x._0;\n  }\n  var match$2 = x._0;\n  if (typeof match$2 === \"number\") {\n    if (match$2 === /* NoMatch */0) {\n      throw {\n            RE_EXN_ID: Debug$Acutis.NoMatchFound,\n            loc: loc,\n            name: name,\n            Error: new Error()\n          };\n    }\n    throw {\n          RE_EXN_ID: Debug$Acutis.PatternNumberMismatch,\n          loc: loc,\n          name: name,\n          Error: new Error()\n        };\n  } else {\n    if (match$2.TAG) {\n      throw {\n            RE_EXN_ID: Debug$Acutis.NameBoundMultipleTimes,\n            loc: match$2.loc,\n            binding: match$2.binding,\n            name: name,\n            Error: new Error()\n          };\n    }\n    throw {\n          RE_EXN_ID: Debug$Acutis.PatternTypeMismatch,\n          data: match$2.data,\n          pattern: match$2.pattern,\n          name: name,\n          Error: new Error()\n        };\n  }\n}\n\nfunction trimStart(string) {\n  var _pos = 0;\n  while(true) {\n    var pos = _pos;\n    var match = string.charAt(pos);\n    switch (match) {\n      case \"\\t\" :\n      case \"\\n\" :\n      case \"\\r\" :\n      case \" \" :\n          _pos = pos + 1 | 0;\n          continue ;\n      default:\n        return string.slice(pos);\n    }\n  };\n}\n\nfunction trimEnd(string) {\n  var _pos = string.length;\n  while(true) {\n    var pos = _pos;\n    var match = string.charAt(pos - 1 | 0);\n    switch (match) {\n      case \"\\t\" :\n      case \"\\n\" :\n      case \"\\r\" :\n      case \" \" :\n          _pos = pos - 1 | 0;\n          continue ;\n      default:\n        return string.slice(0, pos);\n    }\n  };\n}\n\nfunction make(queue, pure, ast, props, children, components, name, renderContext) {\n  var _ast = ast;\n  while(true) {\n    var ast$1 = _ast;\n    if (!ast$1) {\n      return ;\n    }\n    var str = ast$1.hd;\n    switch (str.TAG | 0) {\n      case /* Text */0 :\n          var str$1 = str._0;\n          var str$2;\n          switch (str._1) {\n            case /* TrimStart */0 :\n                str$2 = trimStart(str$1);\n                break;\n            case /* TrimEnd */1 :\n                str$2 = trimEnd(str$1);\n                break;\n            case /* TrimBoth */2 :\n                str$2 = trimStart(trimEnd(str$1));\n                break;\n            case /* NoTrim */3 :\n                str$2 = str$1;\n                break;\n            \n          }\n          Belt_MutableQueue.add(queue, pure(str$2));\n          _ast = ast$1.tl;\n          continue ;\n      case /* Unescaped */1 :\n          var binding = str._1;\n          var x = echoBinding(props, binding);\n          if (x.TAG) {\n            throw {\n                  RE_EXN_ID: Debug$Acutis.BadEchoType,\n                  loc: str._0,\n                  binding: binding,\n                  type_: x._0,\n                  name: name,\n                  Error: new Error()\n                };\n          }\n          Belt_MutableQueue.add(queue, pure(x._0));\n          _ast = ast$1.tl;\n          continue ;\n      case /* EchoBinding */2 :\n          var binding$1 = str._1;\n          var x$1 = echoBinding(props, binding$1);\n          if (x$1.TAG) {\n            throw {\n                  RE_EXN_ID: Debug$Acutis.BadEchoType,\n                  loc: str._0,\n                  binding: binding$1,\n                  type_: x$1._0,\n                  name: name,\n                  Error: new Error()\n                };\n          }\n          Belt_MutableQueue.add(queue, pure($$escape(x$1._0)));\n          _ast = ast$1.tl;\n          continue ;\n      case /* EchoChild */3 :\n          var child = str._1;\n          var x$2 = Acutis_Types$Acutis.IdDict.get(children, child);\n          if (x$2 !== undefined) {\n            Belt_MutableQueue.add(queue, Caml_option.valFromOption(x$2));\n          } else {\n            throw {\n                  RE_EXN_ID: Debug$Acutis.ChildDoesNotExist,\n                  loc: str._0,\n                  child: child,\n                  name: name,\n                  Error: new Error()\n                };\n          }\n          _ast = ast$1.tl;\n          continue ;\n      case /* EchoString */4 :\n          Belt_MutableQueue.add(queue, pure($$escape(str._0)));\n          _ast = ast$1.tl;\n          continue ;\n      case /* EchoNumber */5 :\n          Belt_MutableQueue.add(queue, pure($$escape(String(str._0))));\n          _ast = ast$1.tl;\n          continue ;\n      case /* Match */6 :\n          var patterns = Acutis_Types$Acutis.NonEmpty.map(str._2, (function (param) {\n                  var ast = param.ast;\n                  return {\n                          patterns: param.patterns,\n                          f: (function (props$prime) {\n                              return make(queue, pure, ast, Object.assign({}, props, props$prime), children, components, name, renderContext);\n                            })\n                        };\n                }));\n          var data = Acutis_Types$Acutis.NonEmpty.map(str._1, (function (param) {\n                  return getBindingOrNull(props, param[1]);\n                }));\n          match$1(patterns, data, str._0, name);\n          _ast = ast$1.tl;\n          continue ;\n      case /* Map */7 :\n          var cases = str._2;\n          var binding$2 = str._1;\n          var loc = str._0;\n          var arr = Js_json.classify(getBindingOrNull(props, binding$2));\n          if (typeof arr === \"number\") {\n            throw {\n                  RE_EXN_ID: Debug$Acutis.BadMapType,\n                  loc: loc,\n                  binding: binding$2,\n                  type_: arr,\n                  name: name,\n                  Error: new Error()\n                };\n          }\n          if (arr.TAG === /* JSONArray */3) {\n            Belt_Array.forEachWithIndexU(arr._0, (function(loc,cases){\n                return function (index, json) {\n                  return match$1(Acutis_Types$Acutis.NonEmpty.map(cases, (function (param) {\n                                    var ast = param.ast;\n                                    return {\n                                            patterns: Acutis_Types$Acutis.NonEmpty.map(param.patterns, addImplicitIndexBinding(loc)),\n                                            f: (function (props$prime) {\n                                                return make(queue, pure, ast, Object.assign({}, props, props$prime), children, components, name, renderContext);\n                                              })\n                                          };\n                                  })), /* List */{\n                              _0: json,\n                              _1: {\n                                hd: index,\n                                tl: /* [] */0\n                              }\n                            }, loc, name);\n                }\n                }(loc,cases)));\n            _ast = ast$1.tl;\n            continue ;\n          }\n          throw {\n                RE_EXN_ID: Debug$Acutis.BadMapType,\n                loc: loc,\n                binding: binding$2,\n                type_: arr,\n                name: name,\n                Error: new Error()\n              };\n      case /* Component */8 :\n          var comp = str.name;\n          var loc$1 = str.loc;\n          var component = Acutis_Types$Acutis.IdDict.get(components, comp);\n          if (component !== undefined) {\n            var compProps = {};\n            var compChildren = {};\n            Belt_List.forEachU(str.children, (function(loc$1,compChildren){\n                return function (param) {\n                  var child = param[1];\n                  var child$1;\n                  if (child.TAG) {\n                    child$1 = renderContext({\n                          ast: child._0,\n                          name: name,\n                          isCompiledAst: \"VALID_AST\"\n                        }, props, children);\n                  } else {\n                    var child$2 = child._0;\n                    var x = Acutis_Types$Acutis.IdDict.get(children, child$2);\n                    if (x !== undefined) {\n                      child$1 = Caml_option.valFromOption(x);\n                    } else {\n                      throw {\n                            RE_EXN_ID: Debug$Acutis.ChildDoesNotExist,\n                            loc: loc$1,\n                            child: child$2,\n                            name: name,\n                            Error: new Error()\n                          };\n                    }\n                  }\n                  return Acutis_Types$Acutis.IdDict.set(compChildren, param[0], child$1);\n                }\n                }(loc$1,compChildren)));\n            Belt_List.forEachU(str.props, (function(compProps){\n                return function (param) {\n                  var data = toJson(param[1], props);\n                  if (!data.TAG) {\n                    return Acutis_Types$Acutis.IdDict.set(compProps, param[0], data._0);\n                  }\n                  var match = data._0;\n                  if (match.TAG) {\n                    throw {\n                          RE_EXN_ID: Debug$Acutis.BindingDoesNotExist,\n                          loc: match.loc,\n                          binding: match.binding,\n                          name: name,\n                          Error: new Error()\n                        };\n                  }\n                  throw {\n                        RE_EXN_ID: Debug$Acutis.BindingTypeMismatch,\n                        data: match.data,\n                        pattern: match.pattern,\n                        binding: match.binding,\n                        name: name,\n                        Error: new Error()\n                      };\n                }\n                }(compProps)));\n            var result = component(renderContext, compProps, compChildren);\n            Belt_MutableQueue.add(queue, result);\n            _ast = ast$1.tl;\n            continue ;\n          }\n          throw {\n                RE_EXN_ID: Debug$Acutis.ComponentDoesNotExist,\n                loc: loc$1,\n                component: comp,\n                name: name,\n                Error: new Error()\n              };\n      \n    }\n  };\n}\n\nfunction isAstCompiledOrThrow(x) {\n  if (x.isCompiledAst === \"VALID_AST\") {\n    return ;\n  }\n  throw {\n        RE_EXN_ID: Debug$Acutis.BadRenderInput,\n        Error: new Error()\n      };\n}\n\nfunction pure(x) {\n  return x;\n}\n\nfunction makeContext(components) {\n  var renderContext = function (ast, props, children) {\n    isAstCompiledOrThrow(ast);\n    var queue = Belt_MutableQueue.make(undefined);\n    make(queue, pure, ast.ast, props, children, components, ast.name, renderContext);\n    var _result = \"\";\n    while(true) {\n      var result = _result;\n      var str = Belt_MutableQueue.pop(queue);\n      if (str === undefined) {\n        return result;\n      }\n      _result = result + str;\n      continue ;\n    };\n  };\n  return renderContext;\n}\n\nfunction pure$1(x) {\n  return Promise.resolve(x);\n}\n\nfunction toString(x) {\n  return Promise.resolve(x.join(\"\"));\n}\n\nfunction makeContextAsync(components) {\n  var renderContext = function (ast, props, children) {\n    try {\n      isAstCompiledOrThrow(ast);\n      var queue = Belt_MutableQueue.make(undefined);\n      make(queue, pure$1, ast.ast, props, children, components, ast.name, renderContext);\n      return Promise.all(Belt_MutableQueue.toArray(queue)).then(toString);\n    }\n    catch (raw_e){\n      return Promise.reject(Caml_js_exceptions.internalToOCamlException(raw_e));\n    }\n  };\n  return renderContext;\n}\n\nvar Pattern = {\n  toJson: toJson,\n  test: test,\n  match: match\n};\n\nexport {\n  Pattern ,\n  makeContext ,\n  makeContextAsync ,\n  \n}\n/* No side effect */\n","\n\nimport * as Curry from \"./curry.js\";\nimport * as Caml_option from \"./caml_option.js\";\n\nfunction forEachU(opt, f) {\n  if (opt !== undefined) {\n    return f(Caml_option.valFromOption(opt));\n  }\n  \n}\n\nfunction forEach(opt, f) {\n  return forEachU(opt, Curry.__1(f));\n}\n\nfunction getExn(x) {\n  if (x !== undefined) {\n    return Caml_option.valFromOption(x);\n  }\n  throw {\n        RE_EXN_ID: \"Not_found\",\n        Error: new Error()\n      };\n}\n\nfunction mapWithDefaultU(opt, $$default, f) {\n  if (opt !== undefined) {\n    return f(Caml_option.valFromOption(opt));\n  } else {\n    return $$default;\n  }\n}\n\nfunction mapWithDefault(opt, $$default, f) {\n  return mapWithDefaultU(opt, $$default, Curry.__1(f));\n}\n\nfunction mapU(opt, f) {\n  if (opt !== undefined) {\n    return Caml_option.some(f(Caml_option.valFromOption(opt)));\n  }\n  \n}\n\nfunction map(opt, f) {\n  return mapU(opt, Curry.__1(f));\n}\n\nfunction flatMapU(opt, f) {\n  if (opt !== undefined) {\n    return f(Caml_option.valFromOption(opt));\n  }\n  \n}\n\nfunction flatMap(opt, f) {\n  return flatMapU(opt, Curry.__1(f));\n}\n\nfunction getWithDefault(opt, $$default) {\n  if (opt !== undefined) {\n    return Caml_option.valFromOption(opt);\n  } else {\n    return $$default;\n  }\n}\n\nfunction isSome(param) {\n  return param !== undefined;\n}\n\nfunction isNone(x) {\n  return x === undefined;\n}\n\nfunction eqU(a, b, f) {\n  if (a !== undefined) {\n    if (b !== undefined) {\n      return f(Caml_option.valFromOption(a), Caml_option.valFromOption(b));\n    } else {\n      return false;\n    }\n  } else {\n    return b === undefined;\n  }\n}\n\nfunction eq(a, b, f) {\n  return eqU(a, b, Curry.__2(f));\n}\n\nfunction cmpU(a, b, f) {\n  if (a !== undefined) {\n    if (b !== undefined) {\n      return f(Caml_option.valFromOption(a), Caml_option.valFromOption(b));\n    } else {\n      return 1;\n    }\n  } else if (b !== undefined) {\n    return -1;\n  } else {\n    return 0;\n  }\n}\n\nfunction cmp(a, b, f) {\n  return cmpU(a, b, Curry.__2(f));\n}\n\nexport {\n  forEachU ,\n  forEach ,\n  getExn ,\n  mapWithDefaultU ,\n  mapWithDefault ,\n  mapU ,\n  map ,\n  flatMapU ,\n  flatMap ,\n  getWithDefault ,\n  isSome ,\n  isNone ,\n  eqU ,\n  eq ,\n  cmpU ,\n  cmp ,\n  \n}\n/* No side effect */\n","// Generated by ReScript, PLEASE EDIT WITH CARE\n\nimport * as Belt_Float from \"bs-platform/lib/es6/belt_Float.js\";\nimport * as Debug$Acutis from \"./Debug.bs.js\";\nimport * as Belt_MutableQueue from \"bs-platform/lib/es6/belt_MutableQueue.js\";\nimport * as Acutis_Types$Acutis from \"./Acutis_Types.bs.js\";\n\nfunction peekCharAt(source, x) {\n  return source.str.charAt(source.position + x | 0);\n}\n\nfunction peekChar(source) {\n  return source.str.charAt(source.position);\n}\n\nfunction skipChar(source) {\n  source.position = source.position + 1 | 0;\n  \n}\n\nfunction readChar(source) {\n  var c = peekChar(source);\n  skipChar(source);\n  return c;\n}\n\nfunction peek(source, until) {\n  var _position = source.position;\n  while(true) {\n    var position = _position;\n    if (until(source.str.charAt(position))) {\n      return position;\n    }\n    _position = position + 1 | 0;\n    continue ;\n  };\n}\n\nfunction skip(source, until) {\n  source.position = peek(source, until);\n  \n}\n\nfunction skipBy(source, x) {\n  source.position = source.position + x | 0;\n  \n}\n\nfunction readSubstring(source, until) {\n  var start = source.position;\n  var end = peek(source, until);\n  source.position = end;\n  return source.str.slice(start, end);\n}\n\nfunction readSubstringBy(source, x) {\n  var start = source.position;\n  source.position = source.position + x | 0;\n  return source.str.slice(start, source.position);\n}\n\nfunction endOfNumber(c) {\n  switch (c) {\n    case \"+\" :\n    case \"-\" :\n    case \".\" :\n    case \"0\" :\n    case \"1\" :\n    case \"2\" :\n    case \"3\" :\n    case \"4\" :\n    case \"5\" :\n    case \"6\" :\n    case \"7\" :\n    case \"8\" :\n    case \"9\" :\n    case \"E\" :\n    case \"e\" :\n        return false;\n    default:\n      return true;\n  }\n}\n\nfunction notWhiteSpace(c) {\n  switch (c) {\n    case \"\\t\" :\n    case \"\\n\" :\n    case \"\\r\" :\n    case \" \" :\n        return false;\n    default:\n      return true;\n  }\n}\n\nfunction readStringAux(source, _position) {\n  while(true) {\n    var position = _position;\n    var match = peekCharAt(source, position);\n    switch (match) {\n      case \"\" :\n          return readSubstringBy(source, position);\n      case \"{\" :\n          var match$1 = peekCharAt(source, position + 1 | 0);\n          switch (match$1) {\n            case \"%\" :\n            case \"*\" :\n            case \"{\" :\n                return readSubstringBy(source, position);\n            default:\n              _position = position + 2 | 0;\n              continue ;\n          }\n      default:\n        _position = position + 1 | 0;\n        continue ;\n    }\n  };\n}\n\nfunction readString(source, tokens) {\n  var loc = source.position;\n  var s = readStringAux(source, 0);\n  return Belt_MutableQueue.add(tokens, {\n              TAG: /* String */0,\n              _0: loc,\n              _1: s\n            });\n}\n\nfunction readComment(source, name) {\n  var loc = source.position;\n  var _position = 0;\n  var _nested = 0;\n  while(true) {\n    var nested = _nested;\n    var position = _position;\n    var match = peekCharAt(source, position);\n    switch (match) {\n      case \"\" :\n          throw {\n                RE_EXN_ID: Debug$Acutis.UnterminatedComment,\n                loc: loc,\n                name: name,\n                Error: new Error()\n              };\n      case \"*\" :\n          var match$1 = peekCharAt(source, position + 1 | 0);\n          if (match$1 === \"}\") {\n            if (nested === 0) {\n              var x = readSubstringBy(source, position);\n              skipBy(source, 2);\n              return x;\n            }\n            _nested = nested - 1 | 0;\n            _position = position + 2 | 0;\n            continue ;\n          }\n          _position = position + 2 | 0;\n          continue ;\n      case \"{\" :\n          var match$2 = peekCharAt(source, position + 1 | 0);\n          if (match$2 === \"*\") {\n            _nested = nested + 1 | 0;\n            _position = position + 2 | 0;\n            continue ;\n          }\n          _position = position + 1 | 0;\n          continue ;\n      default:\n        _position = position + 1 | 0;\n        continue ;\n    }\n  };\n}\n\nvar unescapeQuotes = /\\\\\"/g;\n\nfunction readJsonString(source, name) {\n  var loc = source.position;\n  var _position = 0;\n  while(true) {\n    var position = _position;\n    var match = peekCharAt(source, position);\n    switch (match) {\n      case \"\" :\n          throw {\n                RE_EXN_ID: Debug$Acutis.UnterminatedString,\n                loc: loc,\n                name: name,\n                Error: new Error()\n              };\n      case \"\\\"\" :\n          var result = readSubstringBy(source, position).replace(unescapeQuotes, \"\\\"\");\n          skipChar(source);\n          return result;\n      case \"\\\\\" :\n          var match$1 = peekCharAt(source, position + 1 | 0);\n          switch (match$1) {\n            case \"\\\"\" :\n            case \"\\\\\" :\n                _position = position + 2 | 0;\n                continue ;\n            default:\n              _position = position + 1 | 0;\n              continue ;\n          }\n      default:\n        _position = position + 1 | 0;\n        continue ;\n    }\n  };\n}\n\nfunction readNumber(source, name) {\n  var loc = source.position;\n  var value = readSubstring(source, endOfNumber);\n  var num = Belt_Float.fromString(value);\n  if (num !== undefined) {\n    return num;\n  }\n  throw {\n        RE_EXN_ID: Debug$Acutis.IllegalIdentifier,\n        loc: loc,\n        identifier: value,\n        name: name,\n        Error: new Error()\n      };\n}\n\nfunction makeExpression(source, tokens, name) {\n  var expression = true;\n  while(expression) {\n    var loc = source.position;\n    var c = peekChar(source);\n    var exit = 0;\n    switch (c) {\n      case \"\" :\n          throw {\n                RE_EXN_ID: Debug$Acutis.UnexpectedEoF,\n                loc: loc,\n                name: name,\n                Error: new Error()\n              };\n      case \"\\t\" :\n      case \"\\n\" :\n      case \"\\r\" :\n      case \" \" :\n          skipChar(source);\n          break;\n      case \"\\\"\" :\n          skipChar(source);\n          Belt_MutableQueue.add(tokens, {\n                TAG: /* JsonString */1,\n                _0: loc,\n                _1: readJsonString(source, name)\n              });\n          break;\n      case \"#\" :\n          Belt_MutableQueue.add(tokens, {\n                TAG: /* Block */18,\n                _0: loc\n              });\n          skipChar(source);\n          break;\n      case \"%\" :\n          skipChar(source);\n          var loc$1 = source.position;\n          var c$1 = readChar(source);\n          if (c$1 === \"}\") {\n            expression = false;\n          } else {\n            throw {\n                  RE_EXN_ID: Debug$Acutis.UnexpectedCharacter,\n                  loc: loc$1,\n                  character: c$1,\n                  expected: [\"}\"],\n                  name: name,\n                  Error: new Error()\n                };\n          }\n          break;\n      case \",\" :\n          Belt_MutableQueue.add(tokens, {\n                TAG: /* Comma */10,\n                _0: loc\n              });\n          skipChar(source);\n          break;\n      case \".\" :\n          var c$2 = readSubstringBy(source, 3);\n          if (c$2 === \"...\") {\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* Spread */17,\n                  _0: loc\n                });\n          } else {\n            throw {\n                  RE_EXN_ID: Debug$Acutis.UnexpectedCharacter,\n                  loc: loc,\n                  character: c$2,\n                  expected: [\"...\"],\n                  name: name,\n                  Error: new Error()\n                };\n          }\n          break;\n      case \"/\" :\n          Belt_MutableQueue.add(tokens, {\n                TAG: /* Slash */12,\n                _0: loc\n              });\n          skipChar(source);\n          break;\n      case \"-\" :\n      case \"0\" :\n      case \"1\" :\n      case \"2\" :\n      case \"3\" :\n      case \"4\" :\n      case \"5\" :\n      case \"6\" :\n      case \"7\" :\n      case \"8\" :\n      case \"9\" :\n          exit = 1;\n          break;\n      case \":\" :\n          Belt_MutableQueue.add(tokens, {\n                TAG: /* Colon */11,\n                _0: loc\n              });\n          skipChar(source);\n          break;\n      case \"=\" :\n          Belt_MutableQueue.add(tokens, {\n                TAG: /* Equals */19,\n                _0: loc\n              });\n          skipChar(source);\n          break;\n      case \"[\" :\n          Belt_MutableQueue.add(tokens, {\n                TAG: /* OpenBracket */13,\n                _0: loc\n              });\n          skipChar(source);\n          break;\n      case \"]\" :\n          Belt_MutableQueue.add(tokens, {\n                TAG: /* CloseBracket */14,\n                _0: loc\n              });\n          skipChar(source);\n          break;\n      case \"{\" :\n          Belt_MutableQueue.add(tokens, {\n                TAG: /* OpenBrace */15,\n                _0: loc\n              });\n          skipChar(source);\n          break;\n      case \"}\" :\n          Belt_MutableQueue.add(tokens, {\n                TAG: /* CloseBrace */16,\n                _0: loc\n              });\n          skipChar(source);\n          break;\n      case \"~\" :\n          skipChar(source);\n          Belt_MutableQueue.add(tokens, {\n                TAG: /* Tilde */20,\n                _0: loc\n              });\n          break;\n      default:\n        if (Acutis_Types$Acutis.RegEx.isValidIdentifierStart(c)) {\n          Belt_MutableQueue.add(tokens, {\n                TAG: /* Identifier */4,\n                _0: loc,\n                _1: readSubstring(source, Acutis_Types$Acutis.RegEx.isEndOfIdentifier)\n              });\n        } else if (Acutis_Types$Acutis.RegEx.isValidComponentStart(c)) {\n          Belt_MutableQueue.add(tokens, {\n                TAG: /* ComponentName */5,\n                _0: loc,\n                _1: readSubstring(source, Acutis_Types$Acutis.RegEx.isEndOfIdentifier)\n              });\n        } else {\n          throw {\n                RE_EXN_ID: Debug$Acutis.InvalidCharacter,\n                loc: loc,\n                character: c,\n                name: name,\n                Error: new Error()\n              };\n        }\n    }\n    if (exit === 1) {\n      Belt_MutableQueue.add(tokens, {\n            TAG: /* Number */3,\n            _0: loc,\n            _1: readNumber(source, name)\n          });\n    }\n    \n  };\n  \n}\n\nfunction readTildeMaybe(source, tokens) {\n  if (peekChar(source) === \"~\") {\n    Belt_MutableQueue.add(tokens, {\n          TAG: /* Tilde */20,\n          _0: source.position\n        });\n    return skipChar(source);\n  }\n  \n}\n\nfunction make(name, str) {\n  var source = {\n    str: str,\n    position: 0\n  };\n  var tokens = Belt_MutableQueue.make(undefined);\n  readString(source, tokens);\n  var $$char = readChar(source);\n  while($$char !== \"\") {\n    var c = $$char;\n    if (c === \"{\") {\n      var c$1 = readChar(source);\n      switch (c$1) {\n        case \"%\" :\n            makeExpression(source, tokens, name);\n            readString(source, tokens);\n            break;\n        case \"*\" :\n            var loc = source.position;\n            Belt_MutableQueue.add(tokens, {\n                  TAG: /* Comment */2,\n                  _0: loc,\n                  _1: readComment(source, name)\n                });\n            readString(source, tokens);\n            break;\n        case \"{\" :\n            readTildeMaybe(source, tokens);\n            skip(source, notWhiteSpace);\n            var c$2 = peekChar(source);\n            var exit = 0;\n            switch (c$2) {\n              case \"\\\"\" :\n                  var loc$1 = source.position;\n                  skipChar(source);\n                  Belt_MutableQueue.add(tokens, {\n                        TAG: /* EchoString */8,\n                        _0: loc$1,\n                        _1: readJsonString(source, name)\n                      });\n                  break;\n              case \"-\" :\n              case \"0\" :\n              case \"1\" :\n              case \"2\" :\n              case \"3\" :\n              case \"4\" :\n              case \"5\" :\n              case \"6\" :\n              case \"7\" :\n              case \"8\" :\n              case \"9\" :\n                  exit = 1;\n                  break;\n              default:\n                if (Acutis_Types$Acutis.RegEx.isValidIdentifierStart(c$2)) {\n                  var loc$2 = source.position;\n                  Belt_MutableQueue.add(tokens, {\n                        TAG: /* EchoIdentifier */6,\n                        _0: loc$2,\n                        _1: readSubstring(source, Acutis_Types$Acutis.RegEx.isEndOfIdentifier)\n                      });\n                } else if (Acutis_Types$Acutis.RegEx.isValidComponentStart(c$2)) {\n                  var loc$3 = source.position;\n                  Belt_MutableQueue.add(tokens, {\n                        TAG: /* EchoChildComponent */7,\n                        _0: loc$3,\n                        _1: readSubstring(source, Acutis_Types$Acutis.RegEx.isEndOfIdentifier)\n                      });\n                } else {\n                  throw {\n                        RE_EXN_ID: Debug$Acutis.InvalidCharacter,\n                        loc: source.position,\n                        character: c$2,\n                        name: name,\n                        Error: new Error()\n                      };\n                }\n            }\n            if (exit === 1) {\n              var loc$4 = source.position;\n              Belt_MutableQueue.add(tokens, {\n                    TAG: /* EchoNumber */9,\n                    _0: loc$4,\n                    _1: readNumber(source, name)\n                  });\n            }\n            skip(source, notWhiteSpace);\n            readTildeMaybe(source, tokens);\n            var c$3 = readSubstringBy(source, 2);\n            if (c$3 === \"}}\") {\n              readString(source, tokens);\n            } else {\n              throw {\n                    RE_EXN_ID: Debug$Acutis.UnexpectedCharacter,\n                    loc: source.position,\n                    character: c$3,\n                    expected: [\"}}\"],\n                    name: name,\n                    Error: new Error()\n                  };\n            }\n            break;\n        default:\n          throw {\n                RE_EXN_ID: Debug$Acutis.UnexpectedCharacter,\n                loc: source.position,\n                character: c$1,\n                expected: [\n                  \"{\",\n                  \"%\",\n                  \"*\"\n                ],\n                name: name,\n                Error: new Error()\n              };\n      }\n    } else {\n      throw {\n            RE_EXN_ID: Debug$Acutis.UnexpectedCharacter,\n            loc: source.position,\n            character: c,\n            expected: [\n              \"{\",\n              \"[end of file]\"\n            ],\n            name: name,\n            Error: new Error()\n          };\n    }\n    $$char = readChar(source);\n  };\n  Belt_MutableQueue.add(tokens, {\n        TAG: /* EndOfFile */21,\n        _0: source.position\n      });\n  return {\n          tokens: tokens,\n          name: name\n        };\n}\n\nfunction peekExn(x) {\n  return Belt_MutableQueue.peekExn(x.tokens);\n}\n\nfunction popExn(x) {\n  return Belt_MutableQueue.popExn(x.tokens);\n}\n\nfunction skipExn(x) {\n  Belt_MutableQueue.popExn(x.tokens);\n  \n}\n\nfunction name(x) {\n  return x.name;\n}\n\nfunction debugToArray(x) {\n  return Belt_MutableQueue.toArray(x.tokens);\n}\n\nexport {\n  make ,\n  peekExn ,\n  popExn ,\n  skipExn ,\n  name ,\n  debugToArray ,\n  \n}\n/* No side effect */\n","\n\n\nfunction fromString(i) {\n  var i$1 = parseFloat(i);\n  if (isNaN(i$1)) {\n    return ;\n  } else {\n    return i$1;\n  }\n}\n\nexport {\n  fromString ,\n  \n}\n/* No side effect */\n","// Generated by ReScript, PLEASE EDIT WITH CARE\n\nimport * as Belt_List from \"bs-platform/lib/es6/belt_List.js\";\nimport * as Debug$Acutis from \"./Debug.bs.js\";\nimport * as Lexer$Acutis from \"./Lexer.bs.js\";\nimport * as Acutis_Types$Acutis from \"./Acutis_Types.bs.js\";\n\nfunction parseNode(tokens) {\n  var loc = Lexer$Acutis.popExn(tokens);\n  switch (loc.TAG | 0) {\n    case /* JsonString */1 :\n        return {\n                TAG: /* String */3,\n                _0: loc._0,\n                _1: loc._1\n              };\n    case /* Number */3 :\n        return {\n                TAG: /* Number */4,\n                _0: loc._0,\n                _1: loc._1\n              };\n    case /* Identifier */4 :\n        var x = loc._1;\n        var loc$1 = loc._0;\n        switch (x) {\n          case \"false\" :\n              return {\n                      TAG: /* False */1,\n                      _0: loc$1\n                    };\n          case \"null\" :\n              return {\n                      TAG: /* Null */0,\n                      _0: loc$1\n                    };\n          case \"true\" :\n              return {\n                      TAG: /* True */2,\n                      _0: loc$1\n                    };\n          default:\n            return {\n                    TAG: /* Binding */8,\n                    _0: loc$1,\n                    _1: x\n                  };\n        }\n    case /* OpenBracket */13 :\n        var loc$2 = loc._0;\n        var match = Lexer$Acutis.peekExn(tokens);\n        if (match.TAG === /* CloseBracket */14) {\n          Lexer$Acutis.skipExn(tokens);\n          return {\n                  TAG: /* Array */5,\n                  _0: loc$2,\n                  _1: /* [] */0\n                };\n        }\n        var firstItem = parseNode(tokens);\n        var _valueList = {\n          hd: firstItem,\n          tl: /* [] */0\n        };\n        while(true) {\n          var valueList = _valueList;\n          var x$1 = Lexer$Acutis.popExn(tokens);\n          switch (x$1.TAG | 0) {\n            case /* Comma */10 :\n                var x$2 = Lexer$Acutis.peekExn(tokens);\n                switch (x$2.TAG | 0) {\n                  case /* JsonString */1 :\n                  case /* Number */3 :\n                  case /* Identifier */4 :\n                  case /* OpenBracket */13 :\n                  case /* OpenBrace */15 :\n                      break;\n                  case /* Spread */17 :\n                      Lexer$Acutis.skipExn(tokens);\n                      var x$3 = Lexer$Acutis.popExn(tokens);\n                      if (x$3.TAG === /* Identifier */4) {\n                        var result_1 = Belt_List.reverse(valueList);\n                        var result_2 = x$3._0;\n                        var result_3 = x$3._1;\n                        var result = {\n                          TAG: /* ArrayWithTailBinding */6,\n                          loc: loc$2,\n                          array: result_1,\n                          bindLoc: result_2,\n                          binding: result_3\n                        };\n                        var x$4 = Lexer$Acutis.popExn(tokens);\n                        if (x$4.TAG === /* CloseBracket */14) {\n                          return result;\n                        }\n                        throw {\n                              RE_EXN_ID: Debug$Acutis.UnexpectedToken,\n                              token: x$4,\n                              name: Lexer$Acutis.name(tokens),\n                              Error: new Error()\n                            };\n                      }\n                      throw {\n                            RE_EXN_ID: Debug$Acutis.UnexpectedToken,\n                            token: x$3,\n                            name: Lexer$Acutis.name(tokens),\n                            Error: new Error()\n                          };\n                  default:\n                    throw {\n                          RE_EXN_ID: Debug$Acutis.UnexpectedToken,\n                          token: x$2,\n                          name: Lexer$Acutis.name(tokens),\n                          Error: new Error()\n                        };\n                }\n                var item = parseNode(tokens);\n                _valueList = {\n                  hd: item,\n                  tl: valueList\n                };\n                continue ;\n            case /* CloseBracket */14 :\n                return {\n                        TAG: /* Array */5,\n                        _0: loc$2,\n                        _1: Belt_List.reverse(valueList)\n                      };\n            default:\n              throw {\n                    RE_EXN_ID: Debug$Acutis.UnexpectedToken,\n                    token: x$1,\n                    name: Lexer$Acutis.name(tokens),\n                    Error: new Error()\n                  };\n          }\n        };\n    case /* OpenBrace */15 :\n        var loc$3 = loc._0;\n        var match$1 = Lexer$Acutis.peekExn(tokens);\n        if (match$1.TAG === /* CloseBrace */16) {\n          Lexer$Acutis.skipExn(tokens);\n          return {\n                  TAG: /* Object */7,\n                  _0: loc$3,\n                  _1: /* [] */0\n                };\n        }\n        var firstItem$1 = parseObjectKeyValue(tokens);\n        var _keyValueList = {\n          hd: firstItem$1,\n          tl: /* [] */0\n        };\n        while(true) {\n          var keyValueList = _keyValueList;\n          var x$5 = Lexer$Acutis.popExn(tokens);\n          switch (x$5.TAG | 0) {\n            case /* Comma */10 :\n                var x$6 = parseObjectKeyValue(tokens);\n                _keyValueList = {\n                  hd: x$6,\n                  tl: keyValueList\n                };\n                continue ;\n            case /* CloseBrace */16 :\n                return {\n                        TAG: /* Object */7,\n                        _0: loc$3,\n                        _1: Belt_List.reverse(keyValueList)\n                      };\n            default:\n              throw {\n                    RE_EXN_ID: Debug$Acutis.UnexpectedToken,\n                    token: x$5,\n                    name: Lexer$Acutis.name(tokens),\n                    Error: new Error()\n                  };\n          }\n        };\n    default:\n      throw {\n            RE_EXN_ID: Debug$Acutis.UnexpectedToken,\n            token: loc,\n            name: Lexer$Acutis.name(tokens),\n            Error: new Error()\n          };\n  }\n}\n\nfunction parseObjectKeyValue(tokens) {\n  var x = Lexer$Acutis.popExn(tokens);\n  switch (x.TAG | 0) {\n    case /* JsonString */1 :\n    case /* Identifier */4 :\n        break;\n    default:\n      throw {\n            RE_EXN_ID: Debug$Acutis.UnexpectedToken,\n            token: x,\n            name: Lexer$Acutis.name(tokens),\n            Error: new Error()\n          };\n  }\n  var key = x._1;\n  var loc = x._0;\n  var match = Lexer$Acutis.peekExn(tokens);\n  if (match.TAG === /* Colon */11) {\n    Lexer$Acutis.skipExn(tokens);\n    var value = parseNode(tokens);\n    return [\n            key,\n            value\n          ];\n  }\n  if (Acutis_Types$Acutis.RegEx.isLegalBinding(key)) {\n    return [\n            key,\n            {\n              TAG: /* Binding */8,\n              _0: loc,\n              _1: key\n            }\n          ];\n  }\n  throw {\n        RE_EXN_ID: Debug$Acutis.IllegalIdentifier,\n        loc: loc,\n        identifier: key,\n        name: Lexer$Acutis.name(tokens),\n        Error: new Error()\n      };\n}\n\nfunction make(tokens) {\n  var head = parseNode(tokens);\n  var _l = /* [] */0;\n  while(true) {\n    var l = _l;\n    var match = Lexer$Acutis.peekExn(tokens);\n    if (match.TAG !== /* Comma */10) {\n      return /* List */{\n              _0: head,\n              _1: Belt_List.reverse(l)\n            };\n    }\n    Lexer$Acutis.skipExn(tokens);\n    var pattern = parseNode(tokens);\n    _l = {\n      hd: pattern,\n      tl: l\n    };\n    continue ;\n  };\n}\n\nfunction parseCommaSequence(tokens) {\n  var x = Lexer$Acutis.popExn(tokens);\n  if (x.TAG === /* Identifier */4) {\n    var head = x._1;\n    var loc = x._0;\n    if (Acutis_Types$Acutis.RegEx.isLegalBinding(head)) {\n      var _l = /* [] */0;\n      while(true) {\n        var l = _l;\n        var match = Lexer$Acutis.peekExn(tokens);\n        if (match.TAG !== /* Comma */10) {\n          return /* List */{\n                  _0: [\n                    loc,\n                    head\n                  ],\n                  _1: Belt_List.reverse(l)\n                };\n        }\n        Lexer$Acutis.skipExn(tokens);\n        var x$1 = Lexer$Acutis.popExn(tokens);\n        if (x$1.TAG === /* Identifier */4) {\n          var x$2 = x$1._1;\n          var loc$1 = x$1._0;\n          if (Acutis_Types$Acutis.RegEx.isLegalBinding(x$2)) {\n            _l = {\n              hd: [\n                loc$1,\n                x$2\n              ],\n              tl: l\n            };\n            continue ;\n          }\n          throw {\n                RE_EXN_ID: Debug$Acutis.IllegalBindingName,\n                loc: loc$1,\n                binding: x$2,\n                name: Lexer$Acutis.name(tokens),\n                Error: new Error()\n              };\n        }\n        throw {\n              RE_EXN_ID: Debug$Acutis.UnexpectedToken,\n              token: x$1,\n              name: Lexer$Acutis.name(tokens),\n              Error: new Error()\n            };\n      };\n    }\n    throw {\n          RE_EXN_ID: Debug$Acutis.IllegalBindingName,\n          loc: loc,\n          binding: head,\n          name: Lexer$Acutis.name(tokens),\n          Error: new Error()\n        };\n  }\n  throw {\n        RE_EXN_ID: Debug$Acutis.UnexpectedToken,\n        token: x,\n        name: Lexer$Acutis.name(tokens),\n        Error: new Error()\n      };\n}\n\nfunction parseMatchCasePatterns(tokens) {\n  var x = Lexer$Acutis.popExn(tokens);\n  if (x.TAG === /* Identifier */4) {\n    if (x._1 !== \"with\") {\n      throw {\n            RE_EXN_ID: Debug$Acutis.UnexpectedToken,\n            token: x,\n            name: Lexer$Acutis.name(tokens),\n            Error: new Error()\n          };\n    }\n    \n  } else {\n    throw {\n          RE_EXN_ID: Debug$Acutis.UnexpectedToken,\n          token: x,\n          name: Lexer$Acutis.name(tokens),\n          Error: new Error()\n        };\n  }\n  var firstPattern = make(tokens);\n  var _l = /* [] */0;\n  while(true) {\n    var l = _l;\n    var match = Lexer$Acutis.peekExn(tokens);\n    if (match.TAG !== /* Identifier */4) {\n      return /* List */{\n              _0: firstPattern,\n              _1: Belt_List.reverse(l)\n            };\n    }\n    if (match._1 !== \"with\") {\n      return /* List */{\n              _0: firstPattern,\n              _1: Belt_List.reverse(l)\n            };\n    }\n    Lexer$Acutis.skipExn(tokens);\n    var x$1 = make(tokens);\n    _l = {\n      hd: x$1,\n      tl: l\n    };\n    continue ;\n  };\n}\n\nfunction endOfMatchMap(x) {\n  switch (x.TAG | 0) {\n    case /* Identifier */4 :\n        if (x._1 === \"with\") {\n          return true;\n        } else {\n          return false;\n        }\n    case /* Slash */12 :\n        return true;\n    default:\n      return false;\n  }\n}\n\nfunction endOfFile(x) {\n  if (x.TAG === /* EndOfFile */21) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction slash(x) {\n  if (x.TAG === /* Slash */12) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction parse(tokens, until) {\n  var _l = /* [] */0;\n  while(true) {\n    var l = _l;\n    if (until(Lexer$Acutis.peekExn(tokens))) {\n      return Belt_List.reverse(l);\n    }\n    var x = Lexer$Acutis.popExn(tokens);\n    switch (x.TAG | 0) {\n      case /* String */0 :\n          var x$1 = x._1;\n          var match = Lexer$Acutis.peekExn(tokens);\n          if (match.TAG === /* Tilde */20) {\n            Lexer$Acutis.skipExn(tokens);\n            _l = {\n              hd: {\n                TAG: /* Text */0,\n                _0: x$1,\n                _1: /* TrimEnd */1\n              },\n              tl: l\n            };\n            continue ;\n          }\n          _l = {\n            hd: {\n              TAG: /* Text */0,\n              _0: x$1,\n              _1: /* NoTrim */3\n            },\n            tl: l\n          };\n          continue ;\n      case /* Comment */2 :\n          continue ;\n      case /* Identifier */4 :\n          var x$2 = x._1;\n          var loc = x._0;\n          switch (x$2) {\n            case \"map\" :\n                var x$3 = Lexer$Acutis.popExn(tokens);\n                var match$1;\n                if (x$3.TAG === /* Identifier */4) {\n                  var x$4 = x$3._1;\n                  var loc$1 = x$3._0;\n                  if (Acutis_Types$Acutis.RegEx.isLegalBinding(x$4)) {\n                    match$1 = [\n                      loc$1,\n                      x$4\n                    ];\n                  } else {\n                    throw {\n                          RE_EXN_ID: Debug$Acutis.IllegalBindingName,\n                          loc: loc$1,\n                          binding: x$4,\n                          name: Lexer$Acutis.name(tokens),\n                          Error: new Error()\n                        };\n                  }\n                } else {\n                  throw {\n                        RE_EXN_ID: Debug$Acutis.UnexpectedToken,\n                        token: x$3,\n                        name: Lexer$Acutis.name(tokens),\n                        Error: new Error()\n                      };\n                }\n                var firstCase = parseCaseBlock(tokens);\n                var cases = parseCaseBlocks(tokens, \"map\");\n                _l = {\n                  hd: {\n                    TAG: /* Map */7,\n                    _0: match$1[0],\n                    _1: match$1[1],\n                    _2: /* List */{\n                      _0: firstCase,\n                      _1: cases\n                    }\n                  },\n                  tl: l\n                };\n                continue ;\n            case \"match\" :\n                var identifiers = parseCommaSequence(tokens);\n                var firstCase$1 = parseCaseBlock(tokens);\n                var cases$1 = parseCaseBlocks(tokens, \"match\");\n                _l = {\n                  hd: {\n                    TAG: /* Match */6,\n                    _0: loc,\n                    _1: identifiers,\n                    _2: /* List */{\n                      _0: firstCase$1,\n                      _1: cases$1\n                    }\n                  },\n                  tl: l\n                };\n                continue ;\n            case \"raw\" :\n                var x$5 = Lexer$Acutis.popExn(tokens);\n                if (x$5.TAG === /* Identifier */4) {\n                  var x$6 = x$5._1;\n                  var loc$2 = x$5._0;\n                  if (Acutis_Types$Acutis.RegEx.isLegalBinding(x$6)) {\n                    _l = {\n                      hd: {\n                        TAG: /* Unescaped */1,\n                        _0: loc$2,\n                        _1: x$6\n                      },\n                      tl: l\n                    };\n                    continue ;\n                  }\n                  throw {\n                        RE_EXN_ID: Debug$Acutis.IllegalBindingName,\n                        loc: loc$2,\n                        binding: x$6,\n                        name: Lexer$Acutis.name(tokens),\n                        Error: new Error()\n                      };\n                }\n                throw {\n                      RE_EXN_ID: Debug$Acutis.UnexpectedToken,\n                      token: x$5,\n                      name: Lexer$Acutis.name(tokens),\n                      Error: new Error()\n                    };\n            default:\n              throw {\n                    RE_EXN_ID: Debug$Acutis.InvalidStatement,\n                    loc: loc,\n                    statement: x$2,\n                    name: Lexer$Acutis.name(tokens),\n                    Error: new Error()\n                  };\n          }\n      case /* ComponentName */5 :\n          var x$7 = parseComponent(x._0, x._1, tokens);\n          _l = {\n            hd: x$7,\n            tl: l\n          };\n          continue ;\n      case /* EchoIdentifier */6 :\n          var x$8 = x._1;\n          var loc$3 = x._0;\n          if (Acutis_Types$Acutis.RegEx.isLegalBinding(x$8)) {\n            _l = {\n              hd: {\n                TAG: /* EchoBinding */2,\n                _0: loc$3,\n                _1: x$8\n              },\n              tl: l\n            };\n            continue ;\n          }\n          throw {\n                RE_EXN_ID: Debug$Acutis.IllegalBindingName,\n                loc: loc$3,\n                binding: x$8,\n                name: Lexer$Acutis.name(tokens),\n                Error: new Error()\n              };\n      case /* EchoChildComponent */7 :\n          _l = {\n            hd: {\n              TAG: /* EchoChild */3,\n              _0: x._0,\n              _1: x._1\n            },\n            tl: l\n          };\n          continue ;\n      case /* EchoString */8 :\n          _l = {\n            hd: {\n              TAG: /* EchoString */4,\n              _0: x._1\n            },\n            tl: l\n          };\n          continue ;\n      case /* EchoNumber */9 :\n          _l = {\n            hd: {\n              TAG: /* EchoNumber */5,\n              _0: x._1\n            },\n            tl: l\n          };\n          continue ;\n      case /* Tilde */20 :\n          var x$9 = Lexer$Acutis.popExn(tokens);\n          if (x$9.TAG) {\n            throw {\n                  RE_EXN_ID: Debug$Acutis.UnexpectedToken,\n                  token: x$9,\n                  name: Lexer$Acutis.name(tokens),\n                  Error: new Error()\n                };\n          }\n          var x$10 = x$9._1;\n          var match$2 = Lexer$Acutis.peekExn(tokens);\n          if (match$2.TAG === /* Tilde */20) {\n            Lexer$Acutis.skipExn(tokens);\n            _l = {\n              hd: {\n                TAG: /* Text */0,\n                _0: x$10,\n                _1: /* TrimBoth */2\n              },\n              tl: l\n            };\n            continue ;\n          }\n          _l = {\n            hd: {\n              TAG: /* Text */0,\n              _0: x$10,\n              _1: /* TrimStart */0\n            },\n            tl: l\n          };\n          continue ;\n      default:\n        throw {\n              RE_EXN_ID: Debug$Acutis.UnexpectedToken,\n              token: x,\n              name: Lexer$Acutis.name(tokens),\n              Error: new Error()\n            };\n    }\n  };\n}\n\nfunction parseCaseBlock(tokens) {\n  var patterns = parseMatchCasePatterns(tokens);\n  var ast = parse(tokens, endOfMatchMap);\n  return {\n          patterns: patterns,\n          ast: ast\n        };\n}\n\nfunction parseCaseBlocks(tokens, block) {\n  var _l = /* [] */0;\n  while(true) {\n    var l = _l;\n    var match = Lexer$Acutis.peekExn(tokens);\n    if (match.TAG === /* Slash */12) {\n      Lexer$Acutis.skipExn(tokens);\n      var x = Lexer$Acutis.popExn(tokens);\n      if (x.TAG === /* Identifier */4) {\n        if (x._1 === block) {\n          return Belt_List.reverse(l);\n        }\n        throw {\n              RE_EXN_ID: Debug$Acutis.UnexpectedToken,\n              token: x,\n              name: Lexer$Acutis.name(tokens),\n              Error: new Error()\n            };\n      }\n      throw {\n            RE_EXN_ID: Debug$Acutis.UnexpectedToken,\n            token: x,\n            name: Lexer$Acutis.name(tokens),\n            Error: new Error()\n          };\n    }\n    var x$1 = parseCaseBlock(tokens);\n    _l = {\n      hd: x$1,\n      tl: l\n    };\n    continue ;\n  };\n}\n\nfunction parseComponent(loc, name, tokens) {\n  var match = parseProps(tokens, /* [] */0, /* [] */0);\n  var children = match[1];\n  var props = match[0];\n  var match$1 = Lexer$Acutis.peekExn(tokens);\n  if (match$1.TAG === /* Slash */12) {\n    Lexer$Acutis.skipExn(tokens);\n    return {\n            TAG: /* Component */8,\n            loc: loc,\n            name: name,\n            props: props,\n            children: children\n          };\n  }\n  var x = parse(tokens, slash);\n  Lexer$Acutis.skipExn(tokens);\n  var children_0 = [\n    \"Children\",\n    {\n      TAG: /* ChildBlock */1,\n      _0: x\n    }\n  ];\n  var children$1 = {\n    hd: children_0,\n    tl: children\n  };\n  var x$1 = Lexer$Acutis.popExn(tokens);\n  if (x$1.TAG === /* ComponentName */5) {\n    if (name === x$1._1) {\n      return {\n              TAG: /* Component */8,\n              loc: loc,\n              name: name,\n              props: props,\n              children: children$1\n            };\n    }\n    throw {\n          RE_EXN_ID: Debug$Acutis.UnexpectedToken,\n          token: x$1,\n          name: Lexer$Acutis.name(tokens),\n          Error: new Error()\n        };\n  }\n  throw {\n        RE_EXN_ID: Debug$Acutis.UnexpectedToken,\n        token: x$1,\n        name: Lexer$Acutis.name(tokens),\n        Error: new Error()\n      };\n}\n\nfunction parseProps(tokens, _props, _children) {\n  while(true) {\n    var children = _children;\n    var props = _props;\n    var match = Lexer$Acutis.peekExn(tokens);\n    switch (match.TAG | 0) {\n      case /* Identifier */4 :\n          var key = match._1;\n          Lexer$Acutis.skipExn(tokens);\n          var match$1 = Lexer$Acutis.peekExn(tokens);\n          if (match$1.TAG === /* Equals */19) {\n            Lexer$Acutis.skipExn(tokens);\n            var prop = parseNode(tokens);\n            _props = {\n              hd: [\n                key,\n                prop\n              ],\n              tl: props\n            };\n            continue ;\n          }\n          _props = {\n            hd: [\n              key,\n              {\n                TAG: /* Binding */8,\n                _0: match._0,\n                _1: key\n              }\n            ],\n            tl: props\n          };\n          continue ;\n      case /* ComponentName */5 :\n          var name = match._1;\n          Lexer$Acutis.skipExn(tokens);\n          var match$2 = Lexer$Acutis.peekExn(tokens);\n          if (match$2.TAG === /* Equals */19) {\n            Lexer$Acutis.skipExn(tokens);\n            var x = Lexer$Acutis.popExn(tokens);\n            switch (x.TAG | 0) {\n              case /* ComponentName */5 :\n                  _children = {\n                    hd: [\n                      name,\n                      {\n                        TAG: /* ChildName */0,\n                        _0: x._1\n                      }\n                    ],\n                    tl: children\n                  };\n                  continue ;\n              case /* Block */18 :\n                  var child = parseBlock(tokens);\n                  _children = {\n                    hd: [\n                      name,\n                      {\n                        TAG: /* ChildBlock */1,\n                        _0: child\n                      }\n                    ],\n                    tl: children\n                  };\n                  continue ;\n              default:\n                throw {\n                      RE_EXN_ID: Debug$Acutis.UnexpectedToken,\n                      token: x,\n                      name: Lexer$Acutis.name(tokens),\n                      Error: new Error()\n                    };\n            }\n          } else {\n            _children = {\n              hd: [\n                name,\n                {\n                  TAG: /* ChildName */0,\n                  _0: name\n                }\n              ],\n              tl: children\n            };\n            continue ;\n          }\n      default:\n        return [\n                props,\n                children\n              ];\n    }\n  };\n}\n\nfunction parseBlock(tokens) {\n  var result = parse(tokens, slash);\n  Lexer$Acutis.skipExn(tokens);\n  var x = Lexer$Acutis.popExn(tokens);\n  if (x.TAG === /* Block */18) {\n    return result;\n  }\n  throw {\n        RE_EXN_ID: Debug$Acutis.UnexpectedToken,\n        token: x,\n        name: Lexer$Acutis.name(tokens),\n        Error: new Error()\n      };\n}\n\nfunction makeAst(name, source) {\n  var name$1 = name !== undefined ? name : undefined;\n  return {\n          ast: parse(Lexer$Acutis.make(name$1, source), endOfFile),\n          name: name$1,\n          isCompiledAst: \"VALID_AST\"\n        };\n}\n\nfunction makeAstJs(source, name) {\n  var x = typeof source;\n  if (x === \"string\") {\n    return makeAst(name, source);\n  }\n  throw {\n        RE_EXN_ID: Debug$Acutis.BadInputTemplate,\n        _1: x,\n        Error: new Error()\n      };\n}\n\nfunction make$1(name, source) {\n  var ast = makeAst(name, source);\n  return function (render, props, templates) {\n    return render(ast, props, templates);\n  };\n}\n\nfunction makeJs(source, name) {\n  var x = typeof source;\n  if (x === \"string\") {\n    return make$1(name, source);\n  }\n  throw {\n        RE_EXN_ID: Debug$Acutis.BadInputTemplate,\n        _1: x,\n        Error: new Error()\n      };\n}\n\nvar Pattern = {\n  parseNode: parseNode,\n  make: make\n};\n\nexport {\n  Pattern ,\n  makeAst ,\n  makeAstJs ,\n  make$1 as make,\n  makeJs ,\n  \n}\n/* No side effect */\n","// Generated by ReScript, PLEASE EDIT WITH CARE\n\nimport * as Debug$Acutis from \"./Debug.bs.js\";\nimport * as Render$Acutis from \"./Render.bs.js\";\nimport * as Compile$Acutis from \"./Compile.bs.js\";\n\nvar makeAst = Compile$Acutis.makeAstJs;\n\nvar compile = Compile$Acutis.makeJs;\n\nvar renderContext = Render$Acutis.makeContext;\n\nvar renderContextAsync = Render$Acutis.makeContextAsync;\n\nvar errorMessage = Debug$Acutis.errorMessage;\n\nexport {\n  makeAst ,\n  compile ,\n  renderContext ,\n  renderContextAsync ,\n  errorMessage ,\n  \n}\n/* No side effect */\n"],"names":["id","contents","create","str","some","x","undefined","BS_PRIVATE_NESTED_SOME_NONE","valFromOption","depth","get","dict","k","Caml_option.some","fromArray","entries","l","length","i","match","arr","sliceToEnd","a","offset","y","lena","ofs","len","result","Array","forEachWithIndexU","f","i_finish","mapU","xs","cell","hd","tl","_cellX","_prec","prec","cellX","next","copyAuxWithMap","reverse","_l1","_l2","l2","l1","reverseConcat","forEachU","_xs","NonEmpty","map","param","_0","_1","Belt_List.mapU","toList","IdDict","Js_dict.get","set","data","identifierChar","identifierStartChar","componentStart","isReservedKeyword","s","bindingRegEx","RegEx","isEndOfIdentifier","test","isValidIdentifierStart","c","isValidComponentStart","isLegalBinding","Tokens","toString","TAG","String","toLocation","Pattern_Ast","loc","UnexpectedEoF","Caml_exceptions.create","UnterminatedComment","UnterminatedString","IllegalIdentifier","InvalidCharacter","UnexpectedCharacter","UnexpectedToken","IllegalBindingName","InvalidStatement","ComponentDoesNotExist","PatternTypeMismatch","BindingTypeMismatch","NameBoundMultipleTimes","NoMatchFound","PatternNumberMismatch","BadEchoType","BindingDoesNotExist","ChildDoesNotExist","BadMapType","BadInputTemplate","BadRenderInput","jsonTaggedTToString","makeMessage","kind","text","name","classify","ty","isArray","opt","clear","q","first","last","add","content","pop","popExn","RE_EXN_ID","Error","toArray","v","_i","_cell","fillAux","$$Error","listToArrayResult","_l","l$1","Belt_MutableQueue.toArray","e","Belt_MutableQueue.add","toJson","pattern","props","Belt_Result.mapU","binding","Caml_option.valFromOption","Belt_Option.mapU","Acutis_Types$Acutis.IdDict","Js_json.classify","bindLoc","tailBinding","array","a1","a2","a1a2","i$1","Belt_Array.concat","Js_dict.fromArray","x$1","setBinding","bindings","identifier","json","testValue","testArray","Object","keys","_patterns","obj","patterns","match$1","json$1","x$2","_index","index","patterns$1","Belt_Array.sliceToEnd","Belt_Array.get","patternSequence","jsonSequence","_patternSequence","Acutis_Types$Acutis.NonEmpty","_jsonSequence","jsonSequence$1","patternSequence$1","matchCase","$$escape","_result","charAt","getBindingOrNull","key","echoBinding","addImplicitIndexBinding","match$2","Debug$Acutis.NoMatchFound","Debug$Acutis.PatternNumberMismatch","Debug$Acutis.NameBoundMultipleTimes","Debug$Acutis.PatternTypeMismatch","trimStart","string","_pos","pos","slice","trimEnd","make","queue","pure","ast","children","components","renderContext","_ast","ast$1","str$2","str$1","Debug$Acutis.BadEchoType","type_","binding$1","child","Debug$Acutis.ChildDoesNotExist","_2","props$prime","assign","cases","binding$2","Debug$Acutis.BadMapType","Belt_Array.forEachWithIndexU","comp","loc$1","component","compProps","compChildren","Belt_List.forEachU","child$1","isCompiledAst","child$2","Debug$Acutis.BindingDoesNotExist","Debug$Acutis.BindingTypeMismatch","Debug$Acutis.ComponentDoesNotExist","isAstCompiledOrThrow","Debug$Acutis.BadRenderInput","pure$1","Promise","resolve","join","peekCharAt","source","position","peekChar","skipChar","readChar","peek","until","_position","skip","skipBy","readSubstring","start","end","readSubstringBy","endOfNumber","notWhiteSpace","readString","tokens","readStringAux","readComment","_nested","nested","Debug$Acutis.UnterminatedComment","unescapeQuotes","readJsonString","Debug$Acutis.UnterminatedString","replace","readNumber","value","num","parseFloat","isNaN","Debug$Acutis.IllegalIdentifier","makeExpression","expression","exit","Debug$Acutis.UnexpectedEoF","c$1","Debug$Acutis.UnexpectedCharacter","character","expected","c$2","Acutis_Types$Acutis.RegEx","Debug$Acutis.InvalidCharacter","readTildeMaybe","$$char","c$3","peekExn","Belt_MutableQueue.peekExn","Belt_MutableQueue.popExn","skipExn","parseNode","Lexer$Acutis.popExn","loc$2","Lexer$Acutis.peekExn","Lexer$Acutis.skipExn","_valueList","valueList","x$3","Belt_List.reverse","x$4","Debug$Acutis.UnexpectedToken","token","Lexer$Acutis.name","loc$3","_keyValueList","parseObjectKeyValue","keyValueList","x$5","head","parseCommaSequence","Debug$Acutis.IllegalBindingName","endOfMatchMap","endOfFile","slash","parse","firstCase","parseCaseBlock","parseCaseBlocks","x$6","Debug$Acutis.InvalidStatement","statement","parseComponent","x$8","x$9","x$10","firstPattern","parseMatchCasePatterns","block","_props","_children","parseBlock","parseProps","children$1","makeAst","name$1","Lexer$Acutis.make","Debug$Acutis.BadInputTemplate","compile","render","templates","make$1","Belt_MutableQueue.pop","renderContextAsync","all","then","raw_e","reject","Caml_exceptions.caml_is_extension","errorMessage","err","message","expected$1","Acutis_Types$Acutis.Tokens","Acutis_Types$Acutis.Pattern_Ast","pattern$2","data$1","pattern$3","type_$1"],"mappings":"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"}
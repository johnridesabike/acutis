<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Matching (acutis.Acutis.Matching)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">acutis</a> &#x00BB; <a href="../index.html">Acutis</a> &#x00BB; Matching</nav><header class="odoc-preamble"><h1>Module <code><span>Acutis.Matching</span></code></h1><p>Compile patterns into decision trees.</p></header><nav class="odoc-toc"><ul><li><a href="#example-patterns-and-their-resulting-trees.">Example patterns and their resulting trees.</a><ul><li><a href="#a-basic-list-of-integers.">A basic list of integers.</a></li><li><a href="#a-record-nested-in-a-tuple.">A record nested in a tuple.</a></li><li><a href="#a-list.">A list.</a></li><li><a href="#nested-tuples-with-wildcards.">Nested tuples with wildcards.</a></li></ul></li><li><a href="#type-definitions.">Type definitions.</a></li><li><a href="#functions.">Functions.</a></li><li><a href="#functions-for-tests.">Functions for tests.</a></li></ul></nav><div class="odoc-content"><p>Every pattern represents a one-dimensional path across a multi-dimensional data structure. A list of patterns is a two-dimensional matrix of paths. In order to transverse these paths efficiently, we need to combine them into a tree.</p><p>We take advantage of a few properties that can make our tree simpler. We only test discrete static values: integers, strings, etc. We sort record fields and replace omitted fields with wildcards, so every pattern &quot;lines up&quot; with the others in 2D space. We also sort the tested values (the integers, strings, etc.).</p><p>Every node has a set of integer &quot;IDs.&quot; These keep track of which values could potentially be bound to an identifier. Due to the merging and expanding of trees, nodes can have multiple IDs. Each leaf contains a map of binding names to their IDs. This is necessary because multiple patterns may merge that use different or overlapping binding names.</p><p>The most complicated part is how we handle wildcards. When we merge trees, each wildcard &quot;expands&quot; into its joining node. All of the nodes that come after the wildcard will also expand into all of the nodes after the other node. This has trade-offs. One advantage is that we can guarantee that every node is only visited once at runtime. One disadvantage is that some patterns may produce extremely large trees.</p><p>Detecting redundant patterns is &quot;free&quot; with this strategy because merging a redundant tree always fails.</p><h2 id="example-patterns-and-their-resulting-trees."><a href="#example-patterns-and-their-resulting-trees." class="anchor"></a>Example patterns and their resulting trees.</h2><p>Here are a few example patterns juxtaposed with the trees they produce. The trees are written in pseudo-code, since the real trees are much more verbose.</p><h3 id="a-basic-list-of-integers."><a href="#a-basic-list-of-integers." class="anchor"></a>A basic list of integers.</h3><pre>{% match a
   with 0  %} a
{% with 10 %} b
{% with 20 %} c
{% with _  %} d
{% /match %}</pre><pre>|- case 0 -&gt; a
|- case 10 -&gt; b
|- case 20 -&gt; c
|- wildcard -&gt; d</pre><h3 id="a-record-nested-in-a-tuple."><a href="#a-record-nested-in-a-tuple." class="anchor"></a>A record nested in a tuple.</h3><p>(Note: internally, all arguments passed to a <code>match</code> statement are implicitly wrapped in a tuple-like construct.)</p><pre>{% match a, b
   with {a: 10, b: 11}, 12 %} a
{% with {b: 21, a: 20}, 22 %} b
{% with _, _ %} c
{% /match %}|}</pre><pre>key 0
  |- begin nest
      |- key &quot;a&quot;
      |   |- case 10
      |   |   |- key &quot;b&quot;
      |   |       |- case 11
      |   |           |- end nest
      |   |               |- key 1
      |   |                   |- case 12 -&gt; a
      |   |                   |- wildcard -&gt; c
      |   |- case 20
      |       |- key &quot;b&quot;
      |           |- case 21
      |               |- end nest
      |                   |- key 1
      |                       |- case 22 -&gt; b
      |                       |- wildcard -&gt; c
      |- wildcard
          |----------------- key 1
                              |- wildcard -&gt; c</pre><h3 id="a-list."><a href="#a-list." class="anchor"></a>A list.</h3><p>Remember that the <code>[1, 2, ...tl]</code> list syntax is basically sugar for <code>!(1, !(2, tl))</code>.</p><pre>{% match a
   with [] %} a
{% with [x] %} b
{% with [x, ...y] %} c
{% /match %}|}</pre><pre>|- nil -&gt; a
|- cons
    |- begin nest
        |- key 0
            |- wildcard
                |- key 1
                    |- nil
                    |  |- end nest -&gt; b
                    |
                    |- cons
                        |- wildcard
                            |- end nest -&gt; c</pre><h3 id="nested-tuples-with-wildcards."><a href="#nested-tuples-with-wildcards." class="anchor"></a>Nested tuples with wildcards.</h3><p>We can see the effect of wildcard expansion. Some paths are duplicated throughout the tree. For larger, more complex patterns, this can create unexpectedly enormous trees.</p><pre>{% match              a,  b
   with               x, 41 %} a
{% with  ((10, 20), 30), 40 %} b
{% with               y,  z %} c
{% /match %}|}</pre><pre>key 0
  |- begin nest
      |- key 0
      |   |- begin nest
      |       |- key 0
      |           |- case 10
      |               |- key 1
      |                   |- case 20
      |                       |- end nest
      |                           |- key 1
      |                               |- case 30
      |                                   |- end nest
      |                                       |- key 1
      |                                           |- case 40 -&gt; b
      |                                           |- case 41 -&gt; a
      |                                           |- wildcard -&gt; c
      |- wildcard
          |------------------------------------- key 1
                                                  |- case 41 -&gt; a
                                                  |- wildcard -&gt; c</pre><h2 id="type-definitions."><a href="#type-definitions." class="anchor"></a>Type definitions.</h2><div class="odoc-spec"><div class="spec type" id="type-debug_nest_info" class="anchored"><a href="#type-debug_nest_info" class="anchor"></a><code><span><span class="keyword">type</span> debug_nest_info</span><span> = </span></code><table><tr id="type-debug_nest_info.Not_dict" class="anchored"><td class="def variant constructor"><a href="#type-debug_nest_info.Not_dict" class="anchor"></a><code><span>| </span><span><span class="constructor">Not_dict</span></span></code></td></tr><tr id="type-debug_nest_info.Dict" class="anchored"><td class="def variant constructor"><a href="#type-debug_nest_info.Dict" class="anchor"></a><code><span>| </span><span><span class="constructor">Dict</span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-tree" class="anchored"><a href="#type-tree" class="anchor"></a><code><span><span class="keyword">type</span> <span>('leaf, 'key) tree</span></span><span> = </span></code><table><tr id="type-tree.Switch" class="anchored"><td class="def variant constructor"><a href="#type-tree.Switch" class="anchor"></a><code><span>| </span><span><span class="constructor">Switch</span> <span class="keyword">of</span> </span><span>{</span></code><table><tr id="type-tree.key" class="anchored"><td class="def record field"><a href="#type-tree.key" class="anchor"></a><code><span>key : <span class="type-var">'key</span>;</span></code></td></tr><tr id="type-tree.ids" class="anchored"><td class="def record field"><a href="#type-tree.ids" class="anchor"></a><code><span>ids : <a href="../Set/Int/index.html#type-t">Set.Int.t</a>;</span></code></td></tr><tr id="type-tree.cases" class="anchored"><td class="def record field"><a href="#type-tree.cases" class="anchor"></a><code><span>cases : <span><span>( <span class="type-var">'leaf</span>, <span class="type-var">'key</span> )</span> <a href="#type-switchcase">switchcase</a></span>;</span></code></td></tr><tr id="type-tree.wildcard" class="anchored"><td class="def record field"><a href="#type-tree.wildcard" class="anchor"></a><code><span>wildcard : <span><span><span>( <span class="type-var">'leaf</span>, <span class="type-var">'key</span> )</span> <a href="#type-tree">tree</a></span> option</span>;</span></code></td></tr><tr id="type-tree.row" class="anchored"><td class="def record field"><a href="#type-tree.row" class="anchor"></a><code><span>row : <span>[ `Open <span>| `Closed</span> ]</span>;</span></code></td></tr></table><code><span>}</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A Switch represents a list of discreet values to test (i.e., <code>1</code>, <code>&quot;a&quot;</code>, etc.). If none of the values match the input, then the wildcard is used.</p><span class="comment-delim">*)</span></td></tr><tr id="type-tree.Nest" class="anchored"><td class="def variant constructor"><a href="#type-tree.Nest" class="anchor"></a><code><span>| </span><span><span class="constructor">Nest</span> <span class="keyword">of</span> </span><span>{</span></code><table><tr id="type-tree.key" class="anchored"><td class="def record field"><a href="#type-tree.key" class="anchor"></a><code><span>key : <span class="type-var">'key</span>;</span></code></td></tr><tr id="type-tree.ids" class="anchored"><td class="def record field"><a href="#type-tree.ids" class="anchor"></a><code><span>ids : <a href="../Set/Int/index.html#type-t">Set.Int.t</a>;</span></code></td></tr><tr id="type-tree.child" class="anchored"><td class="def record field"><a href="#type-tree.child" class="anchor"></a><code><span>child : <span><span>( <span class="type-var">'leaf</span>, <span class="type-var">'key</span> )</span> <a href="#type-nest">nest</a></span>;</span></code></td></tr><tr id="type-tree.wildcard" class="anchored"><td class="def record field"><a href="#type-tree.wildcard" class="anchor"></a><code><span>wildcard : <span><span><span>( <span class="type-var">'leaf</span>, <span class="type-var">'key</span> )</span> <a href="#type-tree">tree</a></span> option</span>;</span></code></td></tr><tr id="type-tree.debug" class="anchored"><td class="def record field"><a href="#type-tree.debug" class="anchor"></a><code><span>debug : <a href="#type-debug_nest_info">debug_nest_info</a>;</span></code></td></tr></table><code><span>}</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A Nest represents a structure such as tuple or a record.</p><span class="comment-delim">*)</span></td></tr><tr id="type-tree.Construct" class="anchored"><td class="def variant constructor"><a href="#type-tree.Construct" class="anchor"></a><code><span>| </span><span><span class="constructor">Construct</span> <span class="keyword">of</span> </span><span>{</span></code><table><tr id="type-tree.key" class="anchored"><td class="def record field"><a href="#type-tree.key" class="anchor"></a><code><span>key : <span class="type-var">'key</span>;</span></code></td></tr><tr id="type-tree.ids" class="anchored"><td class="def record field"><a href="#type-tree.ids" class="anchor"></a><code><span>ids : <a href="../Set/Int/index.html#type-t">Set.Int.t</a>;</span></code></td></tr><tr id="type-tree.nil" class="anchored"><td class="def record field"><a href="#type-tree.nil" class="anchor"></a><code><span>nil : <span><span><span>( <span class="type-var">'leaf</span>, <span class="type-var">'key</span> )</span> <a href="#type-tree">tree</a></span> option</span>;</span></code></td></tr><tr id="type-tree.cons" class="anchored"><td class="def record field"><a href="#type-tree.cons" class="anchor"></a><code><span>cons : <span><span><span>( <span class="type-var">'leaf</span>, <span class="type-var">'key</span> )</span> <a href="#type-tree">tree</a></span> option</span>;</span></code></td></tr></table><code><span>}</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A Construct represents one of the built-in variant types: lists and nullables. <code>nil</code> represents an empty list or a null value. It is like a wildcard in that it always points to the <b>next</b> node, whatever that may be. <code>cons</code> always points to a <a href="#type-tree.Wildcard"><code>Wildcard</code></a> or <a href="#type-tree.Nest"><code>Nest</code></a> node.</p><span class="comment-delim">*)</span></td></tr><tr id="type-tree.Wildcard" class="anchored"><td class="def variant constructor"><a href="#type-tree.Wildcard" class="anchor"></a><code><span>| </span><span><span class="constructor">Wildcard</span> <span class="keyword">of</span> </span><span>{</span></code><table><tr id="type-tree.key" class="anchored"><td class="def record field"><a href="#type-tree.key" class="anchor"></a><code><span>key : <span class="type-var">'key</span>;</span></code></td></tr><tr id="type-tree.ids" class="anchored"><td class="def record field"><a href="#type-tree.ids" class="anchor"></a><code><span>ids : <a href="../Set/Int/index.html#type-t">Set.Int.t</a>;</span></code></td></tr><tr id="type-tree.child" class="anchored"><td class="def record field"><a href="#type-tree.child" class="anchor"></a><code><span>child : <span><span>( <span class="type-var">'leaf</span>, <span class="type-var">'key</span> )</span> <a href="#type-tree">tree</a></span>;</span></code></td></tr></table><code><span>}</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Wildcards simply point to the next node in the tree.</p><span class="comment-delim">*)</span></td></tr><tr id="type-tree.End" class="anchored"><td class="def variant constructor"><a href="#type-tree.End" class="anchor"></a><code><span>| </span><span><span class="constructor">End</span> <span class="keyword">of</span> <span class="type-var">'leaf</span></span></code></td></tr></table></div><div class="spec-doc"><p>This is a polymorphic &quot;nested data type.&quot; Each tree can use itself as its own type variable, i.e. <code>(('a, 'key) tree, 'key) tree</code>. This allows the <code>End</code> nodes to be fully polymorphic. They can either lead to a <a href="#type-leaf"><code>leaf</code></a> or back to their containing tree. This type nesting corresponds to the nesting of physical patterns.</p><p>Nested types are simple to create, but complicated to manipulate. Functions cannot consume these types under normal polymorphism rules. We need to use explicitly polymorphic type annotations and GADTs.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-nest" class="anchored"><a href="#type-nest" class="anchor"></a><code><span><span class="keyword">and</span> <span>('leaf, 'key) nest</span></span><span> = </span></code><table><tr id="type-nest.Int_keys" class="anchored"><td class="def variant constructor"><a href="#type-nest.Int_keys" class="anchor"></a><code><span>| </span><span><span class="constructor">Int_keys</span> <span class="keyword">of</span> <span><span>( <span><span>( <span class="type-var">'leaf</span>, <span class="type-var">'key</span> )</span> <a href="#type-tree">tree</a></span>, int )</span> <a href="#type-tree">tree</a></span></span></code></td></tr><tr id="type-nest.String_keys" class="anchored"><td class="def variant constructor"><a href="#type-nest.String_keys" class="anchor"></a><code><span>| </span><span><span class="constructor">String_keys</span> <span class="keyword">of</span> <span><span>( <span><span>( <span class="type-var">'leaf</span>, <span class="type-var">'key</span> )</span> <a href="#type-tree">tree</a></span>, string )</span> <a href="#type-tree">tree</a></span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-switchcase" class="anchored"><a href="#type-switchcase" class="anchor"></a><code><span><span class="keyword">and</span> <span>('leaf, 'key) switchcase</span></span><span> = </span><span>{</span></code><table><tr id="type-switchcase.data" class="anchored"><td class="def record field"><a href="#type-switchcase.data" class="anchor"></a><code><span>data : <a href="../Data/Const/index.html#type-t">Data.Const.t</a>;</span></code></td></tr><tr id="type-switchcase.if_match" class="anchored"><td class="def record field"><a href="#type-switchcase.if_match" class="anchor"></a><code><span>if_match : <span><span>( <span class="type-var">'leaf</span>, <span class="type-var">'key</span> )</span> <a href="#type-tree">tree</a></span>;</span></code></td></tr><tr id="type-switchcase.next_case" class="anchored"><td class="def record field"><a href="#type-switchcase.next_case" class="anchor"></a><code><span>next_case : <span><span><span>( <span class="type-var">'leaf</span>, <span class="type-var">'key</span> )</span> <a href="#type-switchcase">switchcase</a></span> option</span>;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>The switch cases work like linked lists of values. If an input matches a value, then we follow its associated tree. If not, we try the next case.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Exit" class="anchored"><a href="#module-Exit" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Exit/index.html">Exit</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Each &quot;exit&quot; is given an integer key which we can use to look up the AST nodes to follow after the tree. We use integers as a level of indirection because exits can be copied when trees merge, and we don't want to duplicate entire ASTs.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-leaf" class="anchored"><a href="#type-leaf" class="anchor"></a><code><span><span class="keyword">type</span> leaf</span><span> = </span><span>{</span></code><table><tr id="type-leaf.names" class="anchored"><td class="def record field"><a href="#type-leaf.names" class="anchor"></a><code><span>names : <span>int <a href="../Map/String/index.html#type-t">Map.String.t</a></span>;</span></code></td></tr><tr id="type-leaf.exit" class="anchored"><td class="def record field"><a href="#type-leaf.exit" class="anchor"></a><code><span>exit : <a href="Exit/index.html#type-key">Exit.key</a>;</span></code></td></tr></table><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> = </span><span>{</span></code><table><tr id="type-t.tree" class="anchored"><td class="def record field"><a href="#type-t.tree" class="anchor"></a><code><span>tree : <span><span>( <a href="#type-leaf">leaf</a>, int )</span> <a href="#type-tree">tree</a></span>;</span></code></td></tr><tr id="type-t.exits" class="anchored"><td class="def record field"><a href="#type-t.exits" class="anchor"></a><code><span>exits : <span><span class="type-var">'a</span> <a href="Exit/index.html#type-t">Exit.t</a></span>;</span></code></td></tr></table><code><span>}</span></code></div></div><h2 id="functions."><a href="#functions." class="anchor"></a>Functions.</h2><div class="odoc-spec"><div class="spec value" id="val-make" class="anchored"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span><span><a href="../Typechecker/index.html#type-case">Typechecker.case</a> <a href="../Nonempty/index.html#type-t">Nonempty.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Typechecker/index.html#type-nodes">Typechecker.nodes</a> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-partial_match_check" class="anchored"><a href="#val-partial_match_check" class="anchor"></a><code><span><span class="keyword">val</span> partial_match_check : 
  <span><a href="../Loc/index.html#type-t">Loc.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Typescheme/index.html#type-t">Typescheme.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <a href="#type-leaf">leaf</a>, int )</span> <a href="#type-tree">tree</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Searches the tree for a counter-example to prove it does not cover a case. Raises <a href="../Error/index.html#exception-Acutis_error"><code>Error.Acutis_error</code></a> if it finds one.</p></div></div><h2 id="functions-for-tests."><a href="#functions-for-tests." class="anchor"></a>Functions for tests.</h2><div class="odoc-spec"><div class="spec value" id="val-equal_tree" class="anchored"><a href="#val-equal_tree" class="anchor"></a><code><span><span class="keyword">val</span> equal_tree : 
  <span><span>( <span><span class="type-var">'leaf</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'leaf</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> bool )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'leaf</span>, <span class="type-var">'key</span> )</span> <a href="#type-tree">tree</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'leaf</span>, <span class="type-var">'key</span> )</span> <a href="#type-tree">tree</a></span> <span class="arrow">&#45;&gt;</span></span>
  bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_tree" class="anchored"><a href="#val-pp_tree" class="anchor"></a><code><span><span class="keyword">val</span> pp_tree : 
  <span><span>( <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'leaf</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'key</span> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>( <span class="type-var">'leaf</span>, <span class="type-var">'key</span> )</span> <a href="#type-tree">tree</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-equal_leaf" class="anchored"><a href="#val-equal_leaf" class="anchor"></a><code><span><span class="keyword">val</span> equal_leaf : <span><a href="#type-leaf">leaf</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-leaf">leaf</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_leaf" class="anchored"><a href="#val-pp_leaf" class="anchor"></a><code><span><span class="keyword">val</span> pp_leaf : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-leaf">leaf</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div></div></div></body></html>
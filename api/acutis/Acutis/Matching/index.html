<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Matching (acutis.Acutis.Matching)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../';
let search_urls = ['../../db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">acutis</a> &#x00BB; <a href="../index.html">Acutis</a> &#x00BB; Matching</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Acutis.Matching</span></code></h1><p>Compile patterns into decision trees.</p></header><nav class="odoc-toc"><ul><li><a href="#example-patterns-and-their-resulting-trees.">Example patterns and their resulting trees.</a><ul><li><a href="#a-basic-list-of-integers.">A basic list of integers.</a></li><li><a href="#a-record-nested-in-a-tuple.">A record nested in a tuple.</a></li><li><a href="#a-list.">A list.</a></li><li><a href="#nested-tuples-with-wildcards.">Nested tuples with wildcards.</a></li></ul></li><li><a href="#type-definitions.">Type definitions.</a></li><li><a href="#functions.">Functions.</a></li></ul></nav><div class="odoc-content"><p>Every pattern represents a one-dimensional path across a multi-dimensional data structure. A list of patterns is a two-dimensional matrix of paths. In order to transverse these paths efficiently, we need to combine them into a tree.</p><p>We take advantage of a few properties that can make our tree simpler. We only test discrete static values: integers, strings, etc. We sort record fields and replace omitted fields with wildcards, so every pattern &quot;lines up&quot; with the others in 2D space. We also sort the tested values (the integers, strings, etc.).</p><p>Every node has a set of integer IDs. These keep track of which values could potentially be bound to an identifier. Due to the merging and expanding of trees, nodes may have multiple IDs. Each leaf at the end of the branches contains a map of names to their IDs. This is necessary because multiple patterns may merge that use different or overlapping names for bindings.</p><p>The most complicated part is how we handle wildcards. When we merge trees, each wildcard &quot;expands&quot; into its joining node. All of the nodes that come after the wildcard will also expand into all of the nodes after the other node. This has trade-offs. One advantage is that we can guarantee that every node is only visited once at runtime. One disadvantage is that some patterns may produce extremely large trees.</p><p>Detecting redundant patterns is almost &quot;free&quot; with this strategy because merging a redundant tree fails to produce a new, different tree.</p><h2 id="example-patterns-and-their-resulting-trees."><a href="#example-patterns-and-their-resulting-trees." class="anchor"></a>Example patterns and their resulting trees.</h2><p>Here are a few example patterns juxtaposed with the trees they produce. The trees are written in pseudo-code, since the real trees are much more verbose.</p><h3 id="a-basic-list-of-integers."><a href="#a-basic-list-of-integers." class="anchor"></a>A basic list of integers.</h3><pre>{% match a
   with 0  %} a
{% with 10 %} b
{% with 20 %} c
{% with _  %} d
{% /match %}</pre><pre>|- case 0 -&gt; a
|- case 10 -&gt; b
|- case 20 -&gt; c
|- wildcard -&gt; d</pre><h3 id="a-record-nested-in-a-tuple."><a href="#a-record-nested-in-a-tuple." class="anchor"></a>A record nested in a tuple.</h3><p>(Note: internally, all arguments passed to a <code>match</code> statement are implicitly wrapped in a tuple-like structure.)</p><pre>{% match a, b
   with {a: 10, b: 11}, 12 %} a
{% with {b: 21, a: 20}, 22 %} b
{% with _, _ %} c
{% /match %}</pre><pre>key 0
  |- begin nest
      |- key &quot;a&quot;
      |   |- case 10
      |   |   |- key &quot;b&quot;
      |   |       |- case 11
      |   |           |- end nest
      |   |               |- key 1
      |   |                   |- case 12 -&gt; a
      |   |                   |- wildcard -&gt; c
      |   |- case 20
      |       |- key &quot;b&quot;
      |           |- case 21
      |               |- end nest
      |                   |- key 1
      |                       |- case 22 -&gt; b
      |                       |- wildcard -&gt; c
      |- wildcard
          |----------------- key 1
                              |- wildcard -&gt; c</pre><h3 id="a-list."><a href="#a-list." class="anchor"></a>A list.</h3><p>Remember that the <code>[1, 2, ...tl]</code> list syntax is basically sugar for <code>!(1, !(2, tl))</code>.</p><pre>{% match a
   with [] %} a
{% with [x] %} b
{% with [x, ...y] %} c
{% /match %}</pre><pre>|- nil -&gt; a
|- cons
    |- begin nest
        |- key 0
            |- wildcard
                |- key 1
                    |- nil
                    |  |- end nest -&gt; b
                    |
                    |- cons
                        |- wildcard
                            |- end nest -&gt; c</pre><h3 id="nested-tuples-with-wildcards."><a href="#nested-tuples-with-wildcards." class="anchor"></a>Nested tuples with wildcards.</h3><p>We can see the effect of wildcard expansion. Some paths are duplicated throughout the tree. For larger, more complex patterns, this can create unexpectedly enormous trees.</p><pre>{% match              a,  b
   with               x, 41 %} a
{% with  ((10, 20), 30), 40 %} b
{% with               y,  z %} c
{% /match %}</pre><pre>key 0
  |- begin nest
      |- key 0
      |   |- begin nest
      |       |- key 0
      |           |- case 10
      |               |- key 1
      |                   |- case 20
      |                       |- end nest
      |                           |- key 1
      |                               |- case 30
      |                                   |- end nest
      |                                       |- key 1
      |                                           |- case 40 -&gt; b
      |                                           |- case 41 -&gt; a
      |                                           |- wildcard -&gt; c
      |- wildcard
          |------------------------------------- key 1
                                                  |- case 41 -&gt; a
                                                  |- wildcard -&gt; c</pre><h2 id="type-definitions."><a href="#type-definitions." class="anchor"></a>Type definitions.</h2><div class="odoc-spec"><div class="spec type anchored" id="type-internal_check_cases"><a href="#type-internal_check_cases" class="anchor"></a><code><span><span class="keyword">type</span> internal_check_cases</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-tree"><a href="#type-tree" class="anchor"></a><code><span><span class="keyword">type</span> <span>('leaf, 'key) tree</span></span><span> = </span></code><ol><li id="type-tree.Switch" class="def variant constructor anchored"><a href="#type-tree.Switch" class="anchor"></a><code><span>| </span><span><span class="constructor">Switch</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-tree.key" class="def record field anchored"><a href="#type-tree.key" class="anchor"></a><code><span>key : <span class="type-var">'key</span>;</span></code></li><li id="type-tree.ids" class="def record field anchored"><a href="#type-tree.ids" class="anchor"></a><code><span>ids : <a href="../Set/Int/index.html#type-t">Set.Int.t</a>;</span></code></li><li id="type-tree.cases" class="def record field anchored"><a href="#type-tree.cases" class="anchor"></a><code><span>cases : <span><span>(<span class="type-var">'leaf</span>, <span class="type-var">'key</span>)</span> <a href="#type-switchcase">switchcase</a></span>;</span></code></li><li id="type-tree.wildcard" class="def record field anchored"><a href="#type-tree.wildcard" class="anchor"></a><code><span>wildcard : <span><span><span>(<span class="type-var">'leaf</span>, <span class="type-var">'key</span>)</span> <a href="#type-tree">tree</a></span> option</span>;</span></code></li><li id="type-tree.check_cases" class="def record field anchored"><a href="#type-tree.check_cases" class="anchor"></a><code><span>check_cases : <a href="#type-internal_check_cases">internal_check_cases</a>;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A Switch represents a list of discreet values to test (i.e., <code>1</code>, <code>&quot;a&quot;</code>, etc.). If none of the values match the input, then the wildcard is used.</p><span class="comment-delim">*)</span></div></li><li id="type-tree.Nest" class="def variant constructor anchored"><a href="#type-tree.Nest" class="anchor"></a><code><span>| </span><span><span class="constructor">Nest</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-tree.key" class="def record field anchored"><a href="#type-tree.key" class="anchor"></a><code><span>key : <span class="type-var">'key</span>;</span></code></li><li id="type-tree.ids" class="def record field anchored"><a href="#type-tree.ids" class="anchor"></a><code><span>ids : <a href="../Set/Int/index.html#type-t">Set.Int.t</a>;</span></code></li><li id="type-tree.child" class="def record field anchored"><a href="#type-tree.child" class="anchor"></a><code><span>child : <span><span>(<span class="type-var">'leaf</span>, <span class="type-var">'key</span>)</span> <a href="#type-nest">nest</a></span>;</span></code></li><li id="type-tree.wildcard" class="def record field anchored"><a href="#type-tree.wildcard" class="anchor"></a><code><span>wildcard : <span><span><span>(<span class="type-var">'leaf</span>, <span class="type-var">'key</span>)</span> <a href="#type-tree">tree</a></span> option</span>;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A Nest represents a structure such as tuple or a record.</p><span class="comment-delim">*)</span></div></li><li id="type-tree.Nil" class="def variant constructor anchored"><a href="#type-tree.Nil" class="anchor"></a><code><span>| </span><span><span class="constructor">Nil</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-tree.key" class="def record field anchored"><a href="#type-tree.key" class="anchor"></a><code><span>key : <span class="type-var">'key</span>;</span></code></li><li id="type-tree.ids" class="def record field anchored"><a href="#type-tree.ids" class="anchor"></a><code><span>ids : <a href="../Set/Int/index.html#type-t">Set.Int.t</a>;</span></code></li><li id="type-tree.child" class="def record field anchored"><a href="#type-tree.child" class="anchor"></a><code><span>child : <span><span>(<span class="type-var">'leaf</span>, <span class="type-var">'key</span>)</span> <a href="#type-tree">tree</a></span>;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A <code>null</code> or <code>[]</code>. The <code>child</code> points to the next node in the tree.</p><span class="comment-delim">*)</span></div></li><li id="type-tree.Cons" class="def variant constructor anchored"><a href="#type-tree.Cons" class="anchor"></a><code><span>| </span><span><span class="constructor">Cons</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-tree.key" class="def record field anchored"><a href="#type-tree.key" class="anchor"></a><code><span>key : <span class="type-var">'key</span>;</span></code></li><li id="type-tree.ids" class="def record field anchored"><a href="#type-tree.ids" class="anchor"></a><code><span>ids : <a href="../Set/Int/index.html#type-t">Set.Int.t</a>;</span></code></li><li id="type-tree.child" class="def record field anchored"><a href="#type-tree.child" class="anchor"></a><code><span>child : <span><span>(<span class="type-var">'leaf</span>, <span class="type-var">'key</span>)</span> <a href="#type-tree">tree</a></span>;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>A not-null value or a non-empty list. The <code>child</code> points to a node representing the &quot;current&quot; data, either a <a href="#type-tree.Wildcard"><code>Wildcard</code></a> or a <a href="#type-tree.Nest"><code>Nest</code></a>.</p><span class="comment-delim">*)</span></div></li><li id="type-tree.Nil_or_cons" class="def variant constructor anchored"><a href="#type-tree.Nil_or_cons" class="anchor"></a><code><span>| </span><span><span class="constructor">Nil_or_cons</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-tree.key" class="def record field anchored"><a href="#type-tree.key" class="anchor"></a><code><span>key : <span class="type-var">'key</span>;</span></code></li><li id="type-tree.ids" class="def record field anchored"><a href="#type-tree.ids" class="anchor"></a><code><span>ids : <a href="../Set/Int/index.html#type-t">Set.Int.t</a>;</span></code></li><li id="type-tree.nil" class="def record field anchored"><a href="#type-tree.nil" class="anchor"></a><code><span>nil : <span><span>(<span class="type-var">'leaf</span>, <span class="type-var">'key</span>)</span> <a href="#type-tree">tree</a></span>;</span></code></li><li id="type-tree.cons" class="def record field anchored"><a href="#type-tree.cons" class="anchor"></a><code><span>cons : <span><span>(<span class="type-var">'leaf</span>, <span class="type-var">'key</span>)</span> <a href="#type-tree">tree</a></span>;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>An exhaustive combination of <a href="#type-tree.Nil"><code>Nil</code></a> and <a href="#type-tree.Cons"><code>Cons</code></a>.</p><span class="comment-delim">*)</span></div></li><li id="type-tree.Wildcard" class="def variant constructor anchored"><a href="#type-tree.Wildcard" class="anchor"></a><code><span>| </span><span><span class="constructor">Wildcard</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-tree.key" class="def record field anchored"><a href="#type-tree.key" class="anchor"></a><code><span>key : <span class="type-var">'key</span>;</span></code></li><li id="type-tree.ids" class="def record field anchored"><a href="#type-tree.ids" class="anchor"></a><code><span>ids : <a href="../Set/Int/index.html#type-t">Set.Int.t</a>;</span></code></li><li id="type-tree.child" class="def record field anchored"><a href="#type-tree.child" class="anchor"></a><code><span>child : <span><span>(<span class="type-var">'leaf</span>, <span class="type-var">'key</span>)</span> <a href="#type-tree">tree</a></span>;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Wildcards simply point to the next node in the tree.</p><span class="comment-delim">*)</span></div></li><li id="type-tree.Optional" class="def variant constructor anchored"><a href="#type-tree.Optional" class="anchor"></a><code><span>| </span><span><span class="constructor">Optional</span> <span class="keyword">of</span> </span><span>{</span></code><ol><li id="type-tree.child" class="def record field anchored"><a href="#type-tree.child" class="anchor"></a><code><span>child : <span><span>(<span class="type-var">'leaf</span>, <span class="type-var">'key</span>)</span> <a href="#type-tree">tree</a></span>;</span></code></li><li id="type-tree.next" class="def record field anchored"><a href="#type-tree.next" class="anchor"></a><code><span>next : <span><span><span>(<span class="type-var">'leaf</span>, <span class="type-var">'key</span>)</span> <a href="#type-tree">tree</a></span> option</span>;</span></code></li></ol><code><span>}</span></code><div class="def-doc"><span class="comment-delim">(*</span><p>Optionals are only used, and always used, inside of dictionary nests. They denote that the item in <code>child</code> does not need to be present during runtime. If following a <code>child</code> path fails, then follow the <code>next</code> path instead. <code>next</code> is analogous to a wildcard except that it cannot bind a value to an ID.</p><span class="comment-delim">*)</span></div></li><li id="type-tree.End" class="def variant constructor anchored"><a href="#type-tree.End" class="anchor"></a><code><span>| </span><span><span class="constructor">End</span> <span class="keyword">of</span> <span class="type-var">'leaf</span></span></code></li></ol></div><div class="spec-doc"><p>This is a polymorphic &quot;nested data type.&quot; Each tree can use itself as its own type variable, i.e. <code>(('a, 'key) tree, 'key) tree</code>. This allows the <code>End</code> nodes to be fully polymorphic. They can either lead to a <a href="#type-leaf"><code>leaf</code></a> or back to their containing tree. This type nesting corresponds to the nesting of physical patterns.</p><p>One way to think about this is that our input patterns are non-nested types, but their physical structure can be nested in many dimensions. Our trees are the inverse. We need a tree that is always structurally two-dimensional, but its type can be nested on multiple dimensions.</p><p>Nested types are simple to create, but complicated to manipulate. Functions cannot consume these types under normal polymorphism rules. We need to use explicitly polymorphic type annotations and GADTs.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-nest"><a href="#type-nest" class="anchor"></a><code><span><span class="keyword">and</span> <span>('leaf, 'key) nest</span></span><span> = </span></code><ol><li id="type-nest.Int_keys" class="def variant constructor anchored"><a href="#type-nest.Int_keys" class="anchor"></a><code><span>| </span><span><span class="constructor">Int_keys</span> <span class="keyword">of</span> <span><span>(<span><span>(<span class="type-var">'leaf</span>, <span class="type-var">'key</span>)</span> <a href="#type-tree">tree</a></span>, int)</span> <a href="#type-tree">tree</a></span></span></code></li><li id="type-nest.String_keys" class="def variant constructor anchored"><a href="#type-nest.String_keys" class="anchor"></a><code><span>| </span><span><span class="constructor">String_keys</span> <span class="keyword">of</span> <span><span>(<span><span>(<span class="type-var">'leaf</span>, <span class="type-var">'key</span>)</span> <a href="#type-tree">tree</a></span>, string)</span> <a href="#type-tree">tree</a></span></span></code></li></ol></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-switchcase"><a href="#type-switchcase" class="anchor"></a><code><span><span class="keyword">and</span> <span>('leaf, 'key) switchcase</span></span><span> = </span><span>{</span></code><ol><li id="type-switchcase.data" class="def record field anchored"><a href="#type-switchcase.data" class="anchor"></a><code><span>data : <span>[ <span>`Int of int</span> <span><span>| `Float</span> of float</span> <span><span>| `String</span> of string</span> ]</span>;</span></code></li><li id="type-switchcase.if_match" class="def record field anchored"><a href="#type-switchcase.if_match" class="anchor"></a><code><span>if_match : <span><span>(<span class="type-var">'leaf</span>, <span class="type-var">'key</span>)</span> <a href="#type-tree">tree</a></span>;</span></code></li><li id="type-switchcase.next" class="def record field anchored"><a href="#type-switchcase.next" class="anchor"></a><code><span>next : <span><span><span>(<span class="type-var">'leaf</span>, <span class="type-var">'key</span>)</span> <a href="#type-switchcase">switchcase</a></span> option</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>The switch cases work like linked lists of values to test. If an input matches a value, then we follow its associated tree. If not, we try the next case.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Exit"><a href="#module-Exit" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Exit/index.html">Exit</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Each &quot;exit&quot; is given an integer key which we can use to look up the AST nodes to follow after the tree. We use integers because exits can be copied when trees merge, and we don't want to duplicate entire ASTs.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-leaf"><a href="#type-leaf" class="anchor"></a><code><span><span class="keyword">type</span> leaf</span><span> = </span><span>{</span></code><ol><li id="type-leaf.names" class="def record field anchored"><a href="#type-leaf.names" class="anchor"></a><code><span>names : <span>int <a href="../Map/String/index.html#type-t">Map.String.t</a></span>;</span></code></li><li id="type-leaf.exit" class="def record field anchored"><a href="#type-leaf.exit" class="anchor"></a><code><span>exit : <a href="Exit/index.html#type-key">Exit.key</a>;</span></code></li></ol><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span><span> = </span><span>{</span></code><ol><li id="type-t.tree" class="def record field anchored"><a href="#type-t.tree" class="anchor"></a><code><span>tree : <span><span>(<a href="#type-leaf">leaf</a>, int)</span> <a href="#type-tree">tree</a></span>;</span></code></li><li id="type-t.exits" class="def record field anchored"><a href="#type-t.exits" class="anchor"></a><code><span>exits : <span><span class="type-var">'a</span> <a href="Exit/index.html#type-t">Exit.t</a></span>;</span></code></li></ol><code><span>}</span></code></div></div><h2 id="functions."><a href="#functions." class="anchor"></a>Functions.</h2><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span><span><a href="../Typechecker/index.html#type-case">Typechecker.case</a> <a href="../Nonempty/index.html#type-t">Nonempty.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Typechecker/index.html#type-nodes">Typechecker.nodes</a> <a href="#type-t">t</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-partial_match_check"><a href="#val-partial_match_check" class="anchor"></a><code><span><span class="keyword">val</span> partial_match_check : 
  <span><a href="../Loc/index.html#type-t">Loc.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><a href="../Typechecker/Type/index.html#type-t">Typechecker.Type.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<a href="#type-leaf">leaf</a>, int)</span> <a href="#type-tree">tree</a></span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>Searches the tree for a counterexample to prove it does not cover a case. Raises <a href="../Error/index.html#exception-Acutis_error"><code>Error.Acutis_error</code></a> if it finds one.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_sexp"><a href="#val-to_sexp" class="anchor"></a><code><span><span class="keyword">val</span> to_sexp : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="../Sexp/index.html#type-t">Sexp.t</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="../Sexp/index.html#type-t">Sexp.t</a></span></code></div></div></div></body></html>

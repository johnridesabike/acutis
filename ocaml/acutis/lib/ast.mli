(**************************************************************************)
(*                                                                        *)
(*                   Copyright (c) 2022 John Jackson.                     *)
(*                                                                        *)
(*  This Source Code Form is subject to the terms of the Mozilla Public   *)
(*  License, v. 2.0. If a copy of the MPL was not distributed with this   *)
(*  file, You can obtain one at http://mozilla.org/MPL/2.0/.              *)
(*                                                                        *)
(**************************************************************************)

(** This defines the untyped abstract syntax tree, generated by the {!Parser}. *)

module Dict : sig
  (** This is a {!Map.String} which enforces that keys cannot be changed after
      they're set. *)

  type 'a t

  val empty : _ t
  val add : Loc.t -> string -> 'a -> 'a t -> 'a t
  val singleton : string -> 'a -> 'a t
  val to_map : 'a t -> 'a Map.String.t
end

module Record : sig
  type 'a t = Untagged of 'a Dict.t | Tagged of string * 'a * 'a Dict.t

  val add : Loc.t -> [ `Tag | `Notag ] -> string -> 'a -> 'a t -> 'a t
  val singleton : [ `Tag | `Notag ] -> string -> 'a -> 'a t
end

module Pattern : sig
  type t =
    | Var of Loc.t * string
    | Bool of Loc.t * int
    | Int of Loc.t * int
    | Float of Loc.t * float
    | String of Loc.t * string
    | Nullable of Loc.t * t option
    | Enum_string of Loc.t * string
    | Enum_int of Loc.t * int
    | List of Loc.t * t list * t option
    | Tuple of Loc.t * t list
    | Record of Loc.t * t Record.t
    | Dict of Loc.t * t Dict.t
end

type trim = No_trim | Trim
type escape = No_escape | Escape

type echo =
  | Ech_var of Loc.t * string * escape
  | Ech_component of Loc.t * string
  | Ech_string of Loc.t * string

type node =
  | Text of string * trim * trim
  | Echo of echo list * echo
  | Match of Loc.t * Pattern.t Nonempty.t * case Nonempty.t
  | Map_list of Loc.t * Pattern.t * case Nonempty.t
  | Map_dict of Loc.t * Pattern.t * case Nonempty.t
  | Component of Loc.t * string * string * Pattern.t Dict.t * child Dict.t

and case = { pats : (Loc.t * Pattern.t Nonempty.t) Nonempty.t; nodes : t }
and child = Child_name of Loc.t * string | Child_block of t
and t = node list

val equal : t -> t -> bool
val pp : Format.formatter -> t -> unit
